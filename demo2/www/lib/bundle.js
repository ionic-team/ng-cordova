/* */ 
"format global";
!function(a){"use strict";function b(a,b,c){for(var d=[b],e=0;e<c.length;e++)d[e+1]=c[e];var f=A(Function.prototype.bind,a,d);return f}function c(a,c){var d=new(b(a,null,c));return d}function d(){return"__$"+Math.floor(1e9*Math.random())+"$"+ ++B+"$__"}function e(a){return C[a]}function f(){var a=d();return C[a]=!0,a}function g(a,b,c){return[D,a,b,c]}function h(a){return a&&a[0]===D}function i(){E=f(),Function.prototype.call=j(function(a){var b=l(function(a){for(var b=[],c=1;c<arguments.length;++c)b[c-1]=arguments[c];var d=g(this,a,b);return d},this,arguments);return b}),Function.prototype.apply=j(function(a,b){var c=l(function(a,b){var c=g(this,a,b);return c},this,arguments);return c})}function j(a){return null===E&&i(),a[E]=!0,a}function k(a){return!!a[E]}function l(a,b,c){var d=c[0];if(h(d))return d=A(a,b,d[3]);for(d=g(a,b,c);;){if(d=k(a)?A(a,d[2],[d]):A(a,d[2],d[3]),!h(d))return d;a=d[1]}}function m(){var a;return a=k(this)?c(this,[g(null,null,arguments)]):c(this,arguments)}if(!a.$traceurRuntime){var n=Object,o=TypeError,p=n.create,q=n.defineProperties,r=n.defineProperty,s=n.freeze,t=n.getOwnPropertyDescriptor,u=n.getOwnPropertyNames,v=n.keys,w=n.prototype.hasOwnProperty,x=(n.prototype.toString,Object.preventExtensions),y=Object.seal,z=Object.isExtensible,A=Function.prototype.call.bind(Function.prototype.apply),B=0,C=p(null),D=Object.create(null),E=null;!function(){function b(a){return{configurable:!0,enumerable:!1,value:a,writable:!0}}function c(a){return"object"==typeof a&&a instanceof k}function h(a){return c(a)?"symbol":typeof a}function i(a){var b=new k(a);if(!(this instanceof i))return b;throw new TypeError("Symbol cannot be new'ed")}function k(a){var b=d();r(this,Z,{value:this}),r(this,X,{value:b}),r(this,Y,{value:a}),B(this),$[b]=this}function A(a){var b=a[_];return b&&b.self===a?b:z(a)?(ba.hash.value=ca++,ba.self.value=a,aa.value=p(null,ba),r(a,_,aa),aa.value):void 0}function B(a){return A(a),s.apply(this,arguments)}function D(a){return A(a),x.apply(this,arguments)}function E(a){return A(a),y.apply(this,arguments)}function F(a){return $[a]||C[a]}function G(a){return c(a)?a[X]:a}function H(a){for(var b=[],c=0;c<a.length;c++)F(a[c])||b.push(a[c]);return b}function I(a){return H(u(a))}function J(a){return H(v(a))}function K(a){for(var b=[],c=u(a),d=0;d<c.length;d++){var e=$[c[d]];e&&b.push(e)}return b}function L(a,b){return t(a,G(b))}function M(a){return w.call(this,G(a))}function N(b){return a.$traceurRuntime.options[b]}function O(a,b,d){return c(b)&&(b=b[X]),r(a,b,d),a}function P(a){r(a,"defineProperty",{value:O}),r(a,"getOwnPropertyNames",{value:I}),r(a,"getOwnPropertyDescriptor",{value:L}),r(a.prototype,"hasOwnProperty",{value:M}),r(a,"freeze",{value:B}),r(a,"preventExtensions",{value:D}),r(a,"seal",{value:E}),r(a,"keys",{value:J})}function Q(a){for(var b=1;b<arguments.length;b++)for(var c=u(arguments[b]),d=0;d<c.length;d++){var e=c[d];"__esModule"===e||F(e)||!function(b,c){r(a,c,{get:function(){return b[c]},enumerable:!0})}(arguments[b],c[d])}return a}function R(a){return null!=a&&("object"==typeof a||"function"==typeof a)}function S(a){if(null==a)throw o();return n(a)}function T(a){if(null==a)throw new TypeError("Value cannot be converted to an Object");return a}function U(a,b){a.Symbol||(a.Symbol=b,Object.getOwnPropertySymbols=K),a.Symbol.iterator||(a.Symbol.iterator=b("Symbol.iterator")),a.Symbol.observer||(a.Symbol.observer=b("Symbol.observer"))}function V(a){U(a,i),a.Reflect=a.Reflect||{},a.Reflect.global=a.Reflect.global||a,P(a.Object)}var W=b,X=d(),Y=d(),Z=d(),$=p(null);r(i.prototype,"constructor",b(i)),r(i.prototype,"toString",W(function(){var a=this[Z];return a[X]})),r(i.prototype,"valueOf",W(function(){var a=this[Z];if(!a)throw TypeError("Conversion from symbol to string");return N("symbols")?a:a[X]})),r(k.prototype,"constructor",b(i)),r(k.prototype,"toString",{value:i.prototype.toString,enumerable:!1}),r(k.prototype,"valueOf",{value:i.prototype.valueOf,enumerable:!1});var _=f(),aa={value:void 0},ba={hash:{value:void 0},self:{value:void 0}},ca=0;B(k.prototype),V(a),a.$traceurRuntime={call:l,checkObjectCoercible:T,construct:m,continuation:g,createPrivateName:f,defineProperties:q,defineProperty:r,exportStar:Q,getOwnHashObject:A,getOwnPropertyDescriptor:t,getOwnPropertyNames:u,initTailRecursiveFunction:j,isObject:R,isPrivateName:e,isSymbolString:F,keys:v,options:{},setupGlobals:V,toObject:S,toProperty:G,"typeof":h}}()}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),function(){function a(a,b,c,d,e,f,g){var h=[];return a&&h.push(a,":"),c&&(h.push("//"),b&&h.push(b,"@"),h.push(c),d&&h.push(":",d)),e&&h.push(e),f&&h.push("?",f),g&&h.push("#",g),h.join("")}function b(a){return a.match(h)}function c(a){if("/"===a)return"/";for(var b="/"===a[0]?"/":"",c="/"===a.slice(-1)?"/":"",d=a.split("/"),e=[],f=0,g=0;g<d.length;g++){var h=d[g];switch(h){case"":case".":break;case"..":e.length?e.pop():f++;break;default:e.push(h)}}if(!b){for(;f-->0;)e.unshift("..");0===e.length&&e.push(".")}return b+e.join("/")+c}function d(b){var d=b[i.PATH]||"";return d=c(d),b[i.PATH]=d,a(b[i.SCHEME],b[i.USER_INFO],b[i.DOMAIN],b[i.PORT],b[i.PATH],b[i.QUERY_DATA],b[i.FRAGMENT])}function e(a){var c=b(a);return d(c)}function f(a,c){var e=b(c),f=b(a);if(e[i.SCHEME])return d(e);e[i.SCHEME]=f[i.SCHEME];for(var g=i.SCHEME;g<=i.PORT;g++)e[g]||(e[g]=f[g]);if("/"==e[i.PATH][0])return d(e);var h=f[i.PATH],j=h.lastIndexOf("/");return h=h.slice(0,j+1)+e[i.PATH],e[i.PATH]=h,d(e)}function g(a){if(!a)return!1;if("/"===a[0])return!0;var c=b(a);return c[i.SCHEME]?!0:!1}var h=new RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([\\w\\d\\-\\u0100-\\uffff.%]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$"),i={SCHEME:1,USER_INFO:2,DOMAIN:3,PORT:4,PATH:5,QUERY_DATA:6,FRAGMENT:7};$traceurRuntime.canonicalizeUrl=e,$traceurRuntime.isAbsolute=g,$traceurRuntime.removeDotSegments=c,$traceurRuntime.resolveUrl=f}(),function(a){"use strict";function b(a,b){this.url=a,this.value_=b}function c(a,b){this.message=this.constructor.name+": "+this.stripCause(b)+" in "+a,this.stack=b instanceof c||!b.stack?"":this.stripStack(b.stack)}function d(a,b){var c=[],d=b-3;0>d&&(d=0);for(var e=d;b>e;e++)c.push(a[e]);return c}function e(a,b){var c=b+1;c>a.length-1&&(c=a.length-1);for(var d=[],e=b;c>=e;e++)d.push(a[e]);return d}function f(a){for(var b="",c=0;a-1>c;c++)b+="-";return b}function g(a,c){b.call(this,a,null),this.func=c}function h(a){if(a){var b=r.normalize(a);return o[b]}}function i(a){var b=arguments[1],c=Object.create(null);return Object.getOwnPropertyNames(a).forEach(function(d){var e,f;if(b===q){var g=Object.getOwnPropertyDescriptor(a,d);g.get&&(e=g.get)}e||(f=a[d],e=function(){return f}),Object.defineProperty(c,d,{get:e,enumerable:!0})}),Object.preventExtensions(c),c}var j,k=$traceurRuntime,l=k.canonicalizeUrl,m=k.resolveUrl,n=k.isAbsolute,o=Object.create(null);j=a.location&&a.location.href?m(a.location.href,"./"):"",c.prototype=Object.create(Error.prototype),c.prototype.constructor=c,c.prototype.stripError=function(a){return a.replace(/.*Error:/,this.constructor.name+":")},c.prototype.stripCause=function(a){return a?a.message?this.stripError(a.message):a+"":""},c.prototype.loadedBy=function(a){this.stack+="\n loaded by "+a},c.prototype.stripStack=function(a){var b=[];return a.split("\n").some(function(a){return/UncoatedModuleInstantiator/.test(a)?!0:void b.push(a)}),b[0]=this.stripError(b[0]),b.join("\n")},g.prototype=Object.create(b.prototype),g.prototype.getUncoatedModule=function(){var b=this;if(this.value_)return this.value_;try{var g;return void 0!==typeof $traceurRuntime&&$traceurRuntime.require&&(g=$traceurRuntime.require.bind(null,this.url)),this.value_=this.func.call(a,g)}catch(h){if(h instanceof c)throw h.loadedBy(this.url),h;if(h.stack){var i=this.func.toString().split("\n"),j=[];h.stack.split("\n").some(function(a,c){if(a.indexOf("UncoatedModuleInstantiator.getUncoatedModule")>0)return!0;var g=/(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(a);if(g){var h=parseInt(g[2],10);j=j.concat(d(i,h)),j.push(1===c?f(g[3])+"^ "+b.url:f(g[3])+"^"),j=j.concat(e(i,h)),j.push("= = = = = = = = =")}else j.push(a)}),h.stack=j.join("\n")}throw new c(this.url,h)}};var p=Object.create(null),q={},r={normalize:function(a,b,c){if("string"!=typeof a)throw new TypeError("module name must be a string, not "+typeof a);if(n(a))return l(a);if(/[^\.]\/\.\.\//.test(a))throw new Error("module name embeds /../: "+a);return"."===a[0]&&b?m(b,a):l(a)},get:function(a){var b=h(a);if(!b)return void 0;var c=p[b.url];return c?c:(c=i(b.getUncoatedModule(),q),p[b.url]=c)},set:function(a,b){a=String(a),o[a]=new g(a,function(){return b}),p[a]=b},get baseURL(){return j},set baseURL(a){j=String(a)},registerModule:function(a,b,c){var d=r.normalize(a);if(o[d])throw new Error("duplicate module named "+d);o[d]=new g(d,c)},bundleStore:Object.create(null),register:function(a,b,c){b&&(b.length||c.length)?this.bundleStore[a]={deps:b,execute:function(){var a=arguments,d={};b.forEach(function(b,c){return d[b]=a[c]});var e=c.call(this,d);return e.execute.call(this),e.exports}}:this.registerModule(a,b,c)},getAnonymousModule:function(b){return new i(b.call(a),q)},getForTesting:function(a){var b=this;return this.testingPrefix_||Object.keys(p).some(function(a){var c=/(traceur@[^\/]*\/)/.exec(a);return c?(b.testingPrefix_=c[1],!0):void 0}),this.get(this.testingPrefix_+a)}},s=new i({ModuleStore:r});r.set("@traceur/src/runtime/ModuleStore.js",s);var t=$traceurRuntime.setupGlobals;$traceurRuntime.setupGlobals=function(a){t(a)},$traceurRuntime.ModuleStore=r,a.System={register:r.register.bind(r),registerModule:r.registerModule.bind(r),get:r.get,set:r.set,normalize:r.normalize}}("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this),System.registerModule("traceur-runtime@0.0.88/src/runtime/async.js",[],function(){"use strict";function a(){}function b(){}function c(a){return a.prototype=j(b.prototype),a.__proto__=b,a}function d(a,b){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];var e=j(b.prototype);return e[k]=this,e[l]=c,e[m]=a,e}function e(a,b){return new Promise(function(c,d){var e=a({next:function(a){return b.call(e,a)},"throw":function(a){d(a)},"return":function(a){c(a)}})})}function f(a){return Promise.resolve().then(a)}function g(a,b){return new q(a,b)}if("object"!=typeof $traceurRuntime)throw new Error("traceur runtime not found.");var h=$traceurRuntime.createPrivateName,i=$traceurRuntime.defineProperty,j=($traceurRuntime.defineProperties,Object.create),k=h(),l=h(),m=h();a.prototype=b,b.constructor=a,i(b,"constructor",{enumerable:!1});var n=function(){function a(a){var b=this;this.decoratedObserver=$traceurRuntime.createDecoratedGenerator(a,function(){b.done=!0}),this.done=!1,this.inReturn=!1}return $traceurRuntime.createClass(a,{"throw":function(a){if(!this.inReturn)throw a},"yield":function(a){if(this.done)throw void(this.inReturn=!0);var b;try{b=this.decoratedObserver.next(a)}catch(c){throw this.done=!0,c}if(void 0!==b){if(b.done)throw this.done=!0,void(this.inReturn=!0);return b.value}},yieldFor:function(a){var b=this;return $traceurRuntime.observeForEach(a[$traceurRuntime.toProperty(Symbol.observer)].bind(a),function(a){if(b.done)return void this["return"]();var c;try{c=b.decoratedObserver.next(a)}catch(d){throw b.done=!0,d}if(void 0!==c)return c.done&&(b.done=!0),c})}},{})}();b.prototype[Symbol.observer]=function(a){var b=this[m],c=new n(a);return $traceurRuntime.schedule(function(){return b(c)}).then(function(a){c.done||c.decoratedObserver["return"](a)})["catch"](function(a){c.done||c.decoratedObserver["throw"](a)}),c.decoratedObserver},i(b.prototype,Symbol.observer,{enumerable:!1});var o=Symbol(),p=Symbol(),q=function(){function a(a,b){this[o]=a,this[p]=b}return $traceurRuntime.createClass(a,{next:function(a){var b=this[o].next(a);return void 0!==b&&b.done&&this[p].call(this),b},"throw":function(a){return this[p].call(this),this[o]["throw"](a)},"return":function(a){return this[p].call(this),this[o]["return"](a)}},{})}();return $traceurRuntime.initAsyncGeneratorFunction=c,$traceurRuntime.createAsyncGeneratorInstance=d,$traceurRuntime.observeForEach=e,$traceurRuntime.schedule=f,$traceurRuntime.createDecoratedGenerator=g,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/classes.js",[],function(){"use strict";function a(a,b){var c=p(a);do{var d=o(c,b);if(d)return d;c=p(c)}while(c);return void 0}function b(a){return a.__proto__}function c(b,c,d){var e=a(c,d);return e?e.get?e.get.call(b):e.value:void 0}function d(b,c,d,e){var f=a(c,d);if(f&&f.set)return f.set.call(b,e),e;throw k("super has no setter '"+d+"'.")}function e(a,b){r(a).forEach(b),s(a).forEach(b)}function f(a){var b={};return e(a,function(c){b[c]=o(a,c),b[c].enumerable=!1}),b}function g(a){e(a,function(b){n(a,b,t)})}function h(a,b,c,d){return n(b,"constructor",{value:a,configurable:!0,enumerable:!1,writable:!0}),arguments.length>3?("function"==typeof d&&(a.__proto__=d),a.prototype=l(i(d),f(b))):(g(b),a.prototype=b),n(a,"prototype",{configurable:!1,writable:!1}),m(a,f(c))}function i(a){if("function"==typeof a){var b=a.prototype;if(j(b)===b||null===b)return a.prototype;throw new k("super prototype must be an Object or null")}if(null===a)return null;throw new k("Super expression must either be null or a function, not "+typeof a+".")}var j=Object,k=TypeError,l=j.create,m=$traceurRuntime.defineProperties,n=$traceurRuntime.defineProperty,o=$traceurRuntime.getOwnPropertyDescriptor,p=($traceurRuntime.getOwnPropertyNames,Object.getPrototypeOf),q=Object,r=q.getOwnPropertyNames,s=q.getOwnPropertySymbols,t={enumerable:!1};return $traceurRuntime.createClass=h,$traceurRuntime.superConstructor=b,$traceurRuntime.superGet=c,$traceurRuntime.superSet=d,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/destructuring.js",[],function(){"use strict";function a(a){for(var b,c=[],d=0;!(b=a.next()).done;)c[d++]=b.value;return c}return $traceurRuntime.iteratorToArray=a,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/generators.js",[],function(){"use strict";function a(a){return{configurable:!0,enumerable:!1,value:a,writable:!0}}function b(a){return new Error("Traceur compiler bug: invalid state in state machine: "+a)}function c(){this.state=0,this.GState=r,this.storedException=void 0,this.finallyFallThrough=void 0,this.sent_=void 0,this.returnValue=void 0,this.oldReturnValue=void 0,this.tryStack_=[]}function d(a,b,c,d){switch(a.GState){case s:throw new Error('"'+c+'" on executing generator');case u:if("next"==c)return{value:void 0,done:!0};if(d===x)return{value:a.returnValue,done:!0};throw d;case r:if("throw"===c){if(a.GState=u,d===x)return{value:a.returnValue,done:!0};throw d}if(void 0!==d)throw q("Sent value to newborn generator");case t:a.GState=s,a.action=c,a.sent=d;var e;try{e=b(a)}catch(f){if(f!==x)throw f;e=a}var g=e===a;return g&&(e=a.returnValue),a.GState=g?u:t,{value:e,done:g}}}function e(){}function f(){}function g(a,b,d){var e=k(a,d),f=new c,g=p(b.prototype);return g[y]=f,g[z]=e,g}function h(a){return a.prototype=p(f.prototype),a.__proto__=f,a}function i(){c.call(this),this.err=void 0;var a=this;a.result=new Promise(function(b,c){a.resolve=b,a.reject=c})}function j(a,b){var c=k(a,b),d=new i;return d.createCallback=function(a){return function(b){d.state=a,d.value=b,c(d)}},d.errback=function(a){l(d,a),c(d)},c(d),d.result}function k(a,b){return function(c){for(;;)try{return a.call(b,c)}catch(d){l(c,d)}}}function l(a,b){a.storedException=b;var c=a.tryStack_[a.tryStack_.length-1];return c?(a.state=void 0!==c["catch"]?c["catch"]:c["finally"],void(void 0!==c.finallyFallThrough&&(a.finallyFallThrough=c.finallyFallThrough))):void a.handleException(b)}if("object"!=typeof $traceurRuntime)throw new Error("traceur runtime not found.");var m=$traceurRuntime.createPrivateName,n=$traceurRuntime.defineProperties,o=$traceurRuntime.defineProperty,p=Object.create,q=TypeError,r=0,s=1,t=2,u=3,v=-2,w=-3,x={};c.prototype={pushTry:function(a,b){if(null!==b){for(var c=null,d=this.tryStack_.length-1;d>=0;d--)if(void 0!==this.tryStack_[d]["catch"]){c=this.tryStack_[d]["catch"];break}null===c&&(c=w),this.tryStack_.push({"finally":b,finallyFallThrough:c})}null!==a&&this.tryStack_.push({"catch":a})},popTry:function(){this.tryStack_.pop()},maybeUncatchable:function(){if(this.storedException===x)throw x},get sent(){return this.maybeThrow(),this.sent_},set sent(a){this.sent_=a},get sentIgnoreThrow(){return this.sent_},maybeThrow:function(){if("throw"===this.action)throw this.action="next",this.sent_},end:function(){switch(this.state){case v:return this;case w:throw this.storedException;default:throw b(this.state)}},handleException:function(a){throw this.GState=u,this.state=v,a},wrapYieldStar:function(a){var b=this;return{next:function(b){return a.next(b)},"throw":function(c){var d;if(c===x){if(a["return"]){if(d=a["return"](b.returnValue),!d.done)return b.returnValue=b.oldReturnValue,d;b.returnValue=d.value}throw c}if(a["throw"])return a["throw"](c);throw a["return"]&&a["return"](),q("Inner iterator does not have a throw method")}}}};var y=m(),z=m();return e.prototype=f,o(f,"constructor",a(e)),f.prototype={constructor:f,next:function(a){return d(this[y],this[z],"next",a)},"throw":function(a){return d(this[y],this[z],"throw",a)},"return":function(a){return this[y].oldReturnValue=this[y].returnValue,this[y].returnValue=a,d(this[y],this[z],"throw",x)}},n(f.prototype,{constructor:{enumerable:!1},next:{enumerable:!1},"throw":{enumerable:!1},"return":{enumerable:!1}}),Object.defineProperty(f.prototype,Symbol.iterator,a(function(){return this})),i.prototype=p(c.prototype),i.prototype.end=function(){switch(this.state){case v:this.resolve(this.returnValue);break;case w:this.reject(this.storedException);break;default:this.reject(b(this.state))}},i.prototype.handleException=function(){this.state=w},$traceurRuntime.asyncWrap=j,$traceurRuntime.initGeneratorFunction=h,$traceurRuntime.createGeneratorInstance=g,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/relativeRequire.js",[],function(){"use strict";function a(a,c){function d(a){return"/"===a.slice(-1)}function e(a){return"/"===a[0]}function f(a){return"."===a[0]}return b=b||"undefined"!=typeof require&&require("path"),d(c)||e(c)?void 0:require(f(c)?b.resolve(b.dirname(a),c):c)}var b;return $traceurRuntime.require=a,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/spread.js",[],function(){"use strict";function a(){for(var a,b=[],c=0,d=0;d<arguments.length;d++){var e=$traceurRuntime.checkObjectCoercible(arguments[d]);if("function"!=typeof e[$traceurRuntime.toProperty(Symbol.iterator)])throw new TypeError("Cannot spread non-iterable object.");for(var f=e[$traceurRuntime.toProperty(Symbol.iterator)]();!(a=f.next()).done;)b[c++]=a.value}return b}return $traceurRuntime.spread=a,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/template.js",[],function(){"use strict";function a(a){var b=arguments[1],g=a.join("${}"),h=f[g];return h?h:(b||(b=e.call(a)),f[g]=d(c(b,"raw",{value:d(a)})))}var b=Object,c=b.defineProperty,d=b.freeze,e=Array.prototype.slice,f=Object.create(null);return $traceurRuntime.getTemplateObject=a,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/type-assertions.js",[],function(){"use strict";function a(a){for(var b=[],e=1;e<arguments.length;e++)b[e-1]=arguments[e];var f=d,g=$traceurRuntime.getOwnHashObject(a).hash;f[g]||(f[g]=Object.create(null)),f=f[g];for(var h=0;h<b.length-1;h++)g=$traceurRuntime.getOwnHashObject(b[h]).hash,f[g]||(f[g]=Object.create(null)),f=f[g];var i=b[b.length-1];return g=$traceurRuntime.getOwnHashObject(i).hash,f[g]||(f[g]=new c(a,b)),f[g]}var b={any:{name:"any"},"boolean":{name:"boolean"},number:{name:"number"},string:{name:"string"},symbol:{name:"symbol"},"void":{name:"void"}},c=function(){function a(a,b){this.type=a,this.argumentTypes=b}return $traceurRuntime.createClass(a,{},{})}(),d=Object.create(null);return $traceurRuntime.GenericType=c,$traceurRuntime.genericType=a,$traceurRuntime.type=b,{}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/runtime-modules.js",[],function(){"use strict";return System.get("traceur-runtime@0.0.88/src/runtime/relativeRequire.js"),System.get("traceur-runtime@0.0.88/src/runtime/spread.js"),System.get("traceur-runtime@0.0.88/src/runtime/destructuring.js"),System.get("traceur-runtime@0.0.88/src/runtime/classes.js"),System.get("traceur-runtime@0.0.88/src/runtime/async.js"),System.get("traceur-runtime@0.0.88/src/runtime/generators.js"),System.get("traceur-runtime@0.0.88/src/runtime/template.js"),System.get("traceur-runtime@0.0.88/src/runtime/type-assertions.js"),{}}),System.get("traceur-runtime@0.0.88/src/runtime/runtime-modules.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js",[],function(){"use strict";function a(a){return a>>>0}function b(a){return a&&("object"==typeof a||"function"==typeof a)}function c(a){return"function"==typeof a}function d(a){return"number"==typeof a}function e(a){return a=+a,u(a)?0:0!==a&&t(a)?a>0?s(a):r(a):a}function f(a){var b=e(a);return 0>b?0:w(b,y)}function g(a){return b(a)?a[Symbol.iterator]:void 0}function h(a){return c(a)}function i(a,b){return{value:a,done:b}}function j(a,b,c){b in a||Object.defineProperty(a,b,c)}function k(a,b,c){j(a,b,{value:c,configurable:!0,enumerable:!1,writable:!0})}function l(a,b,c){j(a,b,{value:c,configurable:!1,enumerable:!1,writable:!1})}function m(a,b){for(var c=0;c<b.length;c+=2){var d=b[c],e=b[c+1];k(a,d,e)}}function n(a,b){for(var c=0;c<b.length;c+=2){var d=b[c],e=b[c+1];l(a,d,e)}}function o(a,b,c){c&&c.iterator&&!a[c.iterator]&&(a["@@iterator"]&&(b=a["@@iterator"]),Object.defineProperty(a,c.iterator,{value:b,configurable:!0,enumerable:!1,writable:!0}))}function p(a){z.push(a)}function q(a){z.forEach(function(b){return b(a)})}var r=Math.ceil,s=Math.floor,t=isFinite,u=isNaN,v=Math.pow,w=Math.min,x=$traceurRuntime.toObject,y=v(2,53)-1,z=[];return{get toObject(){return x},get toUint32(){return a},get isObject(){return b},get isCallable(){return c},get isNumber(){return d},get toInteger(){return e},get toLength(){return f},get checkIterable(){return g},get isConstructor(){return h},get createIteratorResultObject(){return i},get maybeDefine(){return j},get maybeDefineMethod(){return k},get maybeDefineConst(){return l},get maybeAddFunctions(){return m},get maybeAddConsts(){return n},get maybeAddIterator(){return o},get registerPolyfill(){return p},get polyfillAll(){return q}}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Map.js",[],function(){"use strict";function a(a,b){if(e(b)){var c=h(b);return c&&a.objectIndex_[c.hash]}return"string"==typeof b?a.stringIndex_[b]:a.primitiveIndex_[b]}function b(a){a.entries_=[],a.objectIndex_=Object.create(null),a.stringIndex_=Object.create(null),a.primitiveIndex_=Object.create(null),a.deletedCount_=0}function c(a){var b=a,c=b.Object,d=b.Symbol;a.Map||(a.Map=k);var e=a.Map.prototype;void 0===e.entries&&(a.Map=k),e.entries&&(f(e,e.entries,d),f(c.getPrototypeOf((new a.Map).entries()),function(){return this},d))}var d=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),e=d.isObject,f=d.maybeAddIterator,g=d.registerPolyfill,h=$traceurRuntime.getOwnHashObject,i=Object.prototype.hasOwnProperty,j={},k=function(){function c(){var a,c,d=arguments[0];if(!e(this))throw new TypeError("Map called on incompatible type");if(i.call(this,"entries_"))throw new TypeError("Map can not be reentrantly initialised");if(b(this),null!==d&&void 0!==d){var f=!0,g=!1,h=void 0;try{for(var j=void 0,k=d[$traceurRuntime.toProperty(Symbol.iterator)]();!(f=(j=k.next()).done);f=!0){var l=j.value,m=(a=l[$traceurRuntime.toProperty(Symbol.iterator)](),(c=a.next()).done?void 0:c.value),n=(c=a.next()).done?void 0:c.value;this.set(m,n)}}catch(o){g=!0,h=o}finally{try{f||null==k["return"]||k["return"]()}finally{if(g)throw h}}}}return $traceurRuntime.createClass(c,{get size(){return this.entries_.length/2-this.deletedCount_},get:function(b){var c=a(this,b);return void 0!==c?this.entries_[c+1]:void 0},set:function(b,c){var d=e(b),f="string"==typeof b,g=a(this,b);if(void 0!==g)this.entries_[g+1]=c;else if(g=this.entries_.length,this.entries_[g]=b,this.entries_[g+1]=c,d){var i=h(b),j=i.hash;this.objectIndex_[j]=g}else f?this.stringIndex_[b]=g:this.primitiveIndex_[b]=g;return this},has:function(b){return void 0!==a(this,b)},"delete":function(a){var b,c,d=e(a),f="string"==typeof a;if(d){var g=h(a);g&&(b=this.objectIndex_[c=g.hash],delete this.objectIndex_[c])}else f?(b=this.stringIndex_[a],delete this.stringIndex_[a]):(b=this.primitiveIndex_[a],delete this.primitiveIndex_[a]);return void 0!==b?(this.entries_[b]=j,this.entries_[b+1]=void 0,this.deletedCount_++,!0):!1},clear:function(){b(this)},forEach:function(a){for(var b=arguments[1],c=0;c<this.entries_.length;c+=2){var d=this.entries_[c],e=this.entries_[c+1];d!==j&&a.call(b,e,d,this)}},entries:$traceurRuntime.initGeneratorFunction(function d(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,[b,c];case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},d,this)}),keys:$traceurRuntime.initGeneratorFunction(function f(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,b;case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},f,this)}),values:$traceurRuntime.initGeneratorFunction(function g(){var a,b,c;return $traceurRuntime.createGeneratorInstance(function(d){for(;;)switch(d.state){case 0:a=0,d.state=12;break;case 12:d.state=a<this.entries_.length?8:-2;break;case 4:a+=2,d.state=12;break;case 8:b=this.entries_[a],c=this.entries_[a+1],d.state=9;break;case 9:d.state=b===j?4:6;break;case 6:return d.state=2,c;case 2:d.maybeThrow(),d.state=4;break;default:return d.end()}},g,this)})},{})}();return Object.defineProperty(k.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:k.prototype.entries}),g(c),{get Map(){return k},get polyfillMap(){return c}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Map.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Set.js",[],function(){"use strict";function a(a){a.map_=new g}function b(a){var b=a,c=b.Object,d=b.Symbol;a.Set||(a.Set=i);var f=a.Set.prototype;f.values&&(e(f,f.values,d),e(c.getPrototypeOf((new a.Set).values()),function(){return this},d))}var c=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),d=c.isObject,e=c.maybeAddIterator,f=c.registerPolyfill,g=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Map.js").Map,h=($traceurRuntime.getOwnHashObject,Object.prototype.hasOwnProperty),i=function(){function b(){var b=arguments[0];if(!d(this))throw new TypeError("Set called on incompatible type");if(h.call(this,"map_"))throw new TypeError("Set can not be reentrantly initialised");if(a(this),null!==b&&void 0!==b){var c=!0,e=!1,f=void 0;try{for(var g=void 0,i=b[$traceurRuntime.toProperty(Symbol.iterator)]();!(c=(g=i.next()).done);c=!0){var j=g.value;this.add(j)}}catch(k){e=!0,f=k}finally{try{c||null==i["return"]||i["return"]()}finally{if(e)throw f}}}}return $traceurRuntime.createClass(b,{get size(){return this.map_.size},has:function(a){return this.map_.has(a)},add:function(a){return this.map_.set(a,a),this},"delete":function(a){return this.map_["delete"](a)},clear:function(){return this.map_.clear()},forEach:function(a){var b=arguments[1],c=this;return this.map_.forEach(function(d,e){a.call(b,e,e,c)})},values:$traceurRuntime.initGeneratorFunction(function c(){var a,b;return $traceurRuntime.createGeneratorInstance(function(c){for(;;)switch(c.state){case 0:a=c.wrapYieldStar(this.map_.keys()[Symbol.iterator]()),c.sent=void 0,c.action="next",c.state=12;break;case 12:b=a[c.action](c.sentIgnoreThrow),c.state=9;break;case 9:c.state=b.done?3:2;break;case 3:c.sent=b.value,c.state=-2;break;case 2:return c.state=12,b.value;default:return c.end()}},c,this)}),entries:$traceurRuntime.initGeneratorFunction(function e(){var a,b;return $traceurRuntime.createGeneratorInstance(function(c){for(;;)switch(c.state){case 0:a=c.wrapYieldStar(this.map_.entries()[Symbol.iterator]()),c.sent=void 0,c.action="next",c.state=12;break;case 12:b=a[c.action](c.sentIgnoreThrow),c.state=9;break;case 9:c.state=b.done?3:2;break;case 3:c.sent=b.value,c.state=-2;break;case 2:return c.state=12,b.value;default:return c.end()}},e,this)})},{})}();return Object.defineProperty(i.prototype,Symbol.iterator,{configurable:!0,writable:!0,value:i.prototype.values}),Object.defineProperty(i.prototype,"keys",{configurable:!0,writable:!0,value:i.prototype.values}),f(b),{get Set(){return i},get polyfillSet(){return b}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Set.js"),System.registerModule("traceur-runtime@0.0.88/node_modules/rsvp/lib/rsvp/asap.js",[],function(){"use strict";function a(a,b){m[h]=a,m[h+1]=b,h+=2,2===h&&g()}function b(){return function(){process.nextTick(f)}}function c(){var a=0,b=new k(f),c=document.createTextNode("");return b.observe(c,{characterData:!0}),function(){c.data=a=++a%2}}function d(){var a=new MessageChannel;return a.port1.onmessage=f,function(){a.port2.postMessage(0)}}function e(){return function(){setTimeout(f,1)}}function f(){for(var a=0;h>a;a+=2){var b=m[a],c=m[a+1];b(c),m[a]=void 0,m[a+1]=void 0}h=0}var g,h=0,i=a,j="undefined"!=typeof window?window:{},k=j.MutationObserver||j.WebKitMutationObserver,l="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,m=new Array(1e3);return g="undefined"!=typeof process&&"[object process]"==={}.toString.call(process)?b():k?c():l?d():e(),{get default(){return i}}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Promise.js",[],function(){"use strict";function a(a){return a&&"object"==typeof a&&void 0!==a.status_}function b(a){return a}function c(a){throw a}function d(a){var d=void 0!==arguments[1]?arguments[1]:b,f=void 0!==arguments[2]?arguments[2]:c,g=e(a.constructor);switch(a.status_){case void 0:throw TypeError;case 0:a.onResolve_.push(d,g),a.onReject_.push(f,g);break;case 1:k(a.value_,[d,g]);break;case-1:k(a.value_,[f,g])}return g.promise}function e(a){if(this===t){var b=g(new t(r));return{promise:b,resolve:function(a){h(b,a)},reject:function(a){i(b,a)}}}var c={};return c.promise=new a(function(a,b){c.resolve=a,c.reject=b}),c}function f(a,b,c,d,e){return a.status_=b,a.value_=c,a.onResolve_=d,a.onReject_=e,a}function g(a){return f(a,0,void 0,[],[])}function h(a,b){j(a,1,b,a.onResolve_)}function i(a,b){j(a,-1,b,a.onReject_)}function j(a,b,c,d){0===a.status_&&(k(c,d),f(a,b,c))}function k(a,b){p(function(){for(var c=0;c<b.length;c+=2)l(a,b[c],b[c+1])})}function l(b,c,e){try{var f=c(b);if(f===e.promise)throw new TypeError;a(f)?d(f,e.resolve,e.reject):e.resolve(f)}catch(g){try{e.reject(g)}catch(g){}}}function m(a){return a&&("object"==typeof a||"function"==typeof a)}function n(b,c){if(!a(c)&&m(c)){var d;try{d=c.then}catch(f){var g=u.call(b,f);return c[v]=g,g}if("function"==typeof d){var h=c[v];if(h)return h;var i=e(b);c[v]=i.promise;try{d.call(c,i.resolve,i.reject)}catch(f){i.reject(f)}return i.promise}}return c}function o(a){a.Promise||(a.Promise=s)}var p=System.get("traceur-runtime@0.0.88/node_modules/rsvp/lib/rsvp/asap.js")["default"],q=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js").registerPolyfill,r={},s=function(){function j(a){if(a!==r){if("function"!=typeof a)throw new TypeError;var b=g(this);try{a(function(a){
h(b,a)},function(a){i(b,a)})}catch(c){i(b,c)}}}return $traceurRuntime.createClass(j,{"catch":function(a){return this.then(void 0,a)},then:function(e,f){"function"!=typeof e&&(e=b),"function"!=typeof f&&(f=c);var g=this,h=this.constructor;return d(this,function(b){return b=n(h,b),b===g?f(new TypeError):a(b)?b.then(e,f):e(b)},f)}},{resolve:function(b){return this===t?a(b)?b:f(new t(r),1,b):new this(function(a,c){a(b)})},reject:function(a){return this===t?f(new t(r),-1,a):new this(function(b,c){c(a)})},all:function(a){var b=e(this),c=[];try{var d=function(a){return function(d){c[a]=d,0===--f&&b.resolve(c)}},f=0,g=0,h=!0,i=!1,j=void 0;try{for(var k=void 0,l=a[$traceurRuntime.toProperty(Symbol.iterator)]();!(h=(k=l.next()).done);h=!0){var m=k.value,n=d(g);this.resolve(m).then(n,function(a){b.reject(a)}),++g,++f}}catch(o){i=!0,j=o}finally{try{h||null==l["return"]||l["return"]()}finally{if(i)throw j}}0===f&&b.resolve(c)}catch(p){b.reject(p)}return b.promise},race:function(a){var b=e(this);try{for(var c=0;c<a.length;c++)this.resolve(a[c]).then(function(a){b.resolve(a)},function(a){b.reject(a)})}catch(d){b.reject(d)}return b.promise}})}(),t=s,u=t.reject,v="@@thenable";return q(o),{get Promise(){return s},get polyfillPromise(){return o}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Promise.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/StringIterator.js",[],function(){"use strict";function a(a){var b=String(a),c=Object.create(i.prototype);return c[e(g)]=b,c[e(h)]=0,c}var b=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),c=b.createIteratorResultObject,d=b.isObject,e=$traceurRuntime.toProperty,f=Object.prototype.hasOwnProperty,g=Symbol("iteratedString"),h=Symbol("stringIteratorNextIndex"),i=function(){function a(){}var b;return $traceurRuntime.createClass(a,(b={},Object.defineProperty(b,"next",{value:function(){var a=this;if(!d(a)||!f.call(a,g))throw new TypeError("this must be a StringIterator object");var b=a[e(g)];if(void 0===b)return c(void 0,!0);var i=a[e(h)],j=b.length;if(i>=j)return a[e(g)]=void 0,c(void 0,!0);var k,l=b.charCodeAt(i);if(55296>l||l>56319||i+1===j)k=String.fromCharCode(l);else{var m=b.charCodeAt(i+1);k=56320>m||m>57343?String.fromCharCode(l):String.fromCharCode(l)+String.fromCharCode(m)}return a[e(h)]=i+k.length,c(k,!1)},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(b,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),b),{})}();return{get createStringIterator(){return a}}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/String.js",[],function(){"use strict";function a(a){var b=String(this);if(null==this||"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=(d.length,arguments.length>1?arguments[1]:void 0),f=e?Number(e):0;isNaN(f)&&(f=0);var g=Math.min(Math.max(f,0),c);return p.call(b,d,f)==g}function b(a){var b=String(this);if(null==this||"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=d.length,f=c;if(arguments.length>1){var g=arguments[1];void 0!==g&&(f=g?Number(g):0,isNaN(f)&&(f=0))}var h=Math.min(Math.max(f,0),c),i=h-e;return 0>i?!1:q.call(b,d,i)==i}function c(a){if(null==this)throw TypeError();var b=String(this);if(a&&"[object RegExp]"==o.call(a))throw TypeError();var c=b.length,d=String(a),e=d.length,f=arguments.length>1?arguments[1]:void 0,g=f?Number(f):0;g!=g&&(g=0);var h=Math.min(Math.max(g,0),c);return e+h>c?!1:-1!=p.call(b,d,g)}function d(a){if(null==this)throw TypeError();var b=String(this),c=a?Number(a):0;if(isNaN(c)&&(c=0),0>c||c==1/0)throw RangeError();if(0==c)return"";for(var d="";c--;)d+=b;return d}function e(a){if(null==this)throw TypeError();var b=String(this),c=b.length,d=a?Number(a):0;if(isNaN(d)&&(d=0),0>d||d>=c)return void 0;var e,f=b.charCodeAt(d);return f>=55296&&56319>=f&&c>d+1&&(e=b.charCodeAt(d+1),e>=56320&&57343>=e)?1024*(f-55296)+e-56320+65536:f}function f(a){var b=a.raw,c=b.length>>>0;if(0===c)return"";for(var d="",e=0;;){if(d+=b[e],e+1===c)return d;d+=arguments[++e]}}function g(a){var b,c,d=[],e=Math.floor,f=-1,g=arguments.length;if(!g)return"";for(;++f<g;){var h=Number(arguments[f]);if(!isFinite(h)||0>h||h>1114111||e(h)!=h)throw RangeError("Invalid code point: "+h);65535>=h?d.push(h):(h-=65536,b=(h>>10)+55296,c=h%1024+56320,d.push(b,c))}return String.fromCharCode.apply(null,d)}function h(){var a=$traceurRuntime.checkObjectCoercible(this),b=String(a);return j(b)}function i(i){var j=i.String;l(j.prototype,["codePointAt",e,"endsWith",b,"includes",c,"repeat",d,"startsWith",a]),l(j,["fromCodePoint",g,"raw",f]),m(j.prototype,h,Symbol)}var j=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/StringIterator.js").createStringIterator,k=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),l=k.maybeAddFunctions,m=k.maybeAddIterator,n=k.registerPolyfill,o=Object.prototype.toString,p=String.prototype.indexOf,q=String.prototype.lastIndexOf;return n(i),{get startsWith(){return a},get endsWith(){return b},get includes(){return c},get repeat(){return d},get codePointAt(){return e},get raw(){return f},get fromCodePoint(){return g},get stringPrototypeIterator(){return h},get polyfillString(){return i}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/String.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/ArrayIterator.js",[],function(){"use strict";function a(a,b){var c=f(a),d=new l;return d.iteratorObject_=c,d.arrayIteratorNextIndex_=0,d.arrayIterationKind_=b,d}function b(){return a(this,k)}function c(){return a(this,i)}function d(){return a(this,j)}var e=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),f=e.toObject,g=e.toUint32,h=e.createIteratorResultObject,i=1,j=2,k=3,l=function(){function a(){}var b;return $traceurRuntime.createClass(a,(b={},Object.defineProperty(b,"next",{value:function(){var a=f(this),b=a.iteratorObject_;if(!b)throw new TypeError("Object is not an ArrayIterator");var c=a.arrayIteratorNextIndex_,d=a.arrayIterationKind_,e=g(b.length);return c>=e?(a.arrayIteratorNextIndex_=1/0,h(void 0,!0)):(a.arrayIteratorNextIndex_=c+1,d==j?h(b[c],!1):d==k?h([c,b[c]],!1):h(c,!1))},configurable:!0,enumerable:!0,writable:!0}),Object.defineProperty(b,Symbol.iterator,{value:function(){return this},configurable:!0,enumerable:!0,writable:!0}),b),{})}();return{get entries(){return b},get keys(){return c},get values(){return d}}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Array.js",[],function(){"use strict";function a(a){var b,c,d=arguments[1],e=arguments[2],f=this,g=u(a),h=void 0!==d,i=0;if(h&&!n(d))throw TypeError();if(m(g)){b=o(f)?new f:[];var j=!0,k=!1,l=void 0;try{for(var p=void 0,q=g[$traceurRuntime.toProperty(Symbol.iterator)]();!(j=(p=q.next()).done);j=!0){var r=p.value;b[i]=h?d.call(e,r,i):r,i++}}catch(s){k=!0,l=s}finally{try{j||null==q["return"]||q["return"]()}finally{if(k)throw l}}return b.length=i,b}for(c=t(g.length),b=o(f)?new f(c):new Array(c);c>i;i++)b[i]=h?"undefined"==typeof e?d(g[i],i):d.call(e,g[i],i):g[i];return b.length=c,b}function b(){for(var a=[],b=0;b<arguments.length;b++)a[b]=arguments[b];for(var c=this,d=a.length,e=o(c)?new c(d):new Array(d),f=0;d>f;f++)e[f]=a[f];return e.length=d,e}function c(a){var b=void 0!==arguments[1]?arguments[1]:0,c=arguments[2],d=u(this),e=t(d.length),f=s(b),g=void 0!==c?s(c):e;for(f=0>f?Math.max(e+f,0):Math.min(f,e),g=0>g?Math.max(e+g,0):Math.min(g,e);g>f;)d[f]=a,f++;return d}function d(a){var b=arguments[1];return f(this,a,b)}function e(a){var b=arguments[1];return f(this,a,b,!0)}function f(a,b){var c=arguments[2],d=void 0!==arguments[3]?arguments[3]:!1,e=u(a),f=t(e.length);if(!n(b))throw TypeError();for(var g=0;f>g;g++){var h=e[g];if(b.call(c,h,g,e))return d?g:h}return d?-1:void 0}function g(f){var g=f,h=g.Array,l=g.Object,m=g.Symbol,n=k;m&&m.iterator&&h.prototype[m.iterator]&&(n=h.prototype[m.iterator]),p(h.prototype,["entries",i,"keys",j,"values",n,"fill",c,"find",d,"findIndex",e]),p(h,["from",a,"of",b]),q(h.prototype,n,m),q(l.getPrototypeOf([].values()),function(){return this},m)}var h=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/ArrayIterator.js"),i=h.entries,j=h.keys,k=h.values,l=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),m=l.checkIterable,n=l.isCallable,o=l.isConstructor,p=l.maybeAddFunctions,q=l.maybeAddIterator,r=l.registerPolyfill,s=l.toInteger,t=l.toLength,u=l.toObject;return r(g),{get from(){return a},get of(){return b},get fill(){return c},get find(){return d},get findIndex(){return e},get polyfillArray(){return g}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Array.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Object.js",[],function(){"use strict";function a(a,b){return a===b?0!==a||1/a===1/b:a!==a&&b!==b}function b(a){for(var b=1;b<arguments.length;b++){var c=arguments[b],d=null==c?[]:m(c),e=void 0,f=d.length;for(e=0;f>e;e++){var g=d[e];l(g)||(a[g]=c[g])}}return a}function c(a,b){var c,d,e=k(b),f=e.length;for(c=0;f>c;c++){var g=e[c];l(g)||(d=j(b,e[c]),i(a,e[c],d))}return a}function d(d){var e=d.Object;f(e,["assign",b,"is",a,"mixin",c])}var e=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),f=e.maybeAddFunctions,g=e.registerPolyfill,h=$traceurRuntime,i=h.defineProperty,j=h.getOwnPropertyDescriptor,k=h.getOwnPropertyNames,l=h.isPrivateName,m=h.keys;return g(d),{get is(){return a},get assign(){return b},get mixin(){return c},get polyfillObject(){return d}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Object.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Number.js",[],function(){"use strict";function a(a){return g(a)&&m(a)}function b(b){return a(b)&&k(b)===b}function c(a){return g(a)&&n(a)}function d(b){if(a(b)){var c=k(b);if(c===b)return l(c)<=o}return!1}function e(e){var f=e.Number;h(f,["MAX_SAFE_INTEGER",o,"MIN_SAFE_INTEGER",p,"EPSILON",q]),i(f,["isFinite",a,"isInteger",b,"isNaN",c,"isSafeInteger",d])}var f=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),g=f.isNumber,h=f.maybeAddConsts,i=f.maybeAddFunctions,j=f.registerPolyfill,k=f.toInteger,l=Math.abs,m=isFinite,n=isNaN,o=Math.pow(2,53)-1,p=-Math.pow(2,53)+1,q=Math.pow(2,-52);return j(e),{get MAX_SAFE_INTEGER(){return o},get MIN_SAFE_INTEGER(){return p},get EPSILON(){return q},get isFinite(){return a},get isInteger(){return b},get isNaN(){return c},get isSafeInteger(){return d},get polyfillNumber(){return e}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Number.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/fround.js",[],function(){"use strict";function a(a,b,c){function d(a){var b=k(a),c=a-b;return.5>c?b:c>.5?b+1:b%2?b+1:b}var e,f,g,h,o,p,q,r=(1<<b-1)-1;for(a!==a?(f=(1<<b)-1,g=n(2,c-1),e=0):a===1/0||a===-(1/0)?(f=(1<<b)-1,g=0,e=0>a?1:0):0===a?(f=0,g=0,e=1/a===-(1/0)?1:0):(e=0>a,a=j(a),a>=n(2,1-r)?(f=m(k(l(a)/i),1023),g=d(a/n(2,f)*n(2,c)),g/n(2,c)>=2&&(f+=1,g=1),f>r?(f=(1<<b)-1,g=0):(f+=r,g-=n(2,c))):(f=0,g=d(a/n(2,1-r-c)))),o=[],h=c;h;h-=1)o.push(g%2?1:0),g=k(g/2);for(h=b;h;h-=1)o.push(f%2?1:0),f=k(f/2);for(o.push(e?1:0),o.reverse(),p=o.join(""),q=[];p.length;)q.push(parseInt(p.substring(0,8),2)),p=p.substring(8);return q}function b(a,b,c){var d,e,f,g,h,i,j,k,l=[];for(d=a.length;d;d-=1)for(f=a[d-1],e=8;e;e-=1)l.push(f%2?1:0),f>>=1;return l.reverse(),g=l.join(""),h=(1<<b-1)-1,i=parseInt(g.substring(0,1),2)?-1:1,j=parseInt(g.substring(1,1+b),2),k=parseInt(g.substring(1+b),2),j===(1<<b)-1?0!==k?0/0:i*(1/0):j>0?i*n(2,j-h)*(1+k/n(2,c)):0!==k?i*n(2,-(h-1))*(k/n(2,c)):0>i?-0:0}function c(a){return b(a,8,23)}function d(b){return a(b,8,23)}function e(a){return 0===a||!f(a)||g(a)?a:c(d(Number(a)))}var f=isFinite,g=isNaN,h=Math,i=h.LN2,j=h.abs,k=h.floor,l=h.log,m=h.min,n=h.pow;return{get fround(){return e}}}),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/Math.js",[],function(){"use strict";function a(a){if(a=x(+a),0==a)return 32;var b=0;return 0===(4294901760&a)&&(a<<=16,b+=16),0===(4278190080&a)&&(a<<=8,b+=8),0===(4026531840&a)&&(a<<=4,b+=4),0===(3221225472&a)&&(a<<=2,b+=2),0===(2147483648&a)&&(a<<=1,b+=1),b}function b(a,b){a=x(+a),b=x(+b);var c=a>>>16&65535,d=65535&a,e=b>>>16&65535,f=65535&b;return d*f+(c*f+d*e<<16>>>0)|0}function c(a){return a=+a,a>0?1:0>a?-1:a}function d(a){return.4342944819032518*F(a)}function e(a){return 1.4426950408889634*F(a)}function f(a){if(a=+a,-1>a||z(a))return 0/0;if(0===a||a===1/0)return a;if(-1===a)return-(1/0);var b=0,c=50;if(0>a||a>1)return F(1+a);for(var d=1;c>d;d++)d%2===0?b-=G(a,d)/d:b+=G(a,d)/d;return b}function g(a){return a=+a,a===-(1/0)?-1:y(a)&&0!==a?D(a)-1:a}function h(a){return a=+a,0===a?1:z(a)?0/0:y(a)?(0>a&&(a=-a),a>21?D(a)/2:(D(a)+D(-a))/2):1/0}function i(a){return a=+a,y(a)&&0!==a?(D(a)-D(-a))/2:a}function j(a){if(a=+a,0===a)return a;if(!y(a))return c(a);var b=D(a),d=D(-a);return(b-d)/(b+d)}function k(a){return a=+a,1>a?0/0:y(a)?F(a+H(a+1)*H(a-1)):a}function l(a){return a=+a,0!==a&&y(a)?a>0?F(a+H(a*a+1)):-F(-a+H(a*a+1)):a}function m(a){return a=+a,-1===a?-(1/0):1===a?1/0:0===a?a:z(a)||-1>a||a>1?0/0:.5*F((1+a)/(1-a))}function n(a,b){for(var c=arguments.length,d=new Array(c),e=0,f=0;c>f;f++){var g=arguments[f];if(g=+g,g===1/0||g===-(1/0))return 1/0;g=B(g),g>e&&(e=g),d[f]=g}0===e&&(e=1);for(var h=0,i=0,f=0;c>f;f++){var g=d[f]/e,j=g*g-i,k=h+j;i=k-h-j,h=k}return H(h)*e}function o(a){return a=+a,a>0?E(a):0>a?C(a):a}function p(a){if(a=+a,0===a)return a;var b=0>a;b&&(a=-a);var c=G(a,1/3);return b?-c:c}function q(q){var s=q.Math;v(s,["acosh",k,"asinh",l,"atanh",m,"cbrt",p,"clz32",a,"cosh",h,"expm1",g,"fround",r,"hypot",n,"imul",b,"log10",d,"log1p",f,"log2",e,"sign",c,"sinh",i,"tanh",j,"trunc",o])}var r,s,t=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/fround.js").fround,u=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js"),v=u.maybeAddFunctions,w=u.registerPolyfill,x=u.toUint32,y=isFinite,z=isNaN,A=Math,B=A.abs,C=A.ceil,D=A.exp,E=A.floor,F=A.log,G=A.pow,H=A.sqrt;return"function"==typeof Float32Array?(s=new Float32Array(1),r=function(a){return s[0]=Number(a),s[0]}):r=t,w(q),{get clz32(){return a},get imul(){return b},get sign(){return c},get log10(){return d},get log2(){return e},get log1p(){return f},get expm1(){return g},get cosh(){return h},get sinh(){return i},get tanh(){return j},get acosh(){return k},get asinh(){return l},get atanh(){return m},get hypot(){return n},get trunc(){return o},get fround(){return r},get cbrt(){return p},get polyfillMath(){return q}}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/Math.js"),System.registerModule("traceur-runtime@0.0.88/src/runtime/polyfills/polyfills.js",[],function(){"use strict";var a=System.get("traceur-runtime@0.0.88/src/runtime/polyfills/utils.js").polyfillAll;a(Reflect.global);var b=$traceurRuntime.setupGlobals;return $traceurRuntime.setupGlobals=function(c){b(c),a(c)},{}}),System.get("traceur-runtime@0.0.88/src/runtime/polyfills/polyfills.js");
//# sourceMappingURL=traceur-runtime.min.map
/*
 *  es6-module-loader v0.16.6
 *  https://github.com/ModuleLoader/es6-module-loader
 *  Copyright (c) 2015 Guy Bedford, Luke Hoban, Addy Osmani; Licensed MIT
 */

!function(a){"object"==typeof exports?module.exports=a():"function"==typeof define&&define.amd?define(a):"undefined"!=typeof window?window.Promise=a():"undefined"!=typeof global?global.Promise=a():"undefined"!=typeof self&&(self.Promise=a())}(function(){var a;return function b(a,c,d){function e(g,h){if(!c[g]){if(!a[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);throw new Error("Cannot find module '"+g+"'")}var j=c[g]={exports:{}};a[g][0].call(j.exports,function(b){var c=a[g][1][b];return e(c?c:b)},j,j.exports,b,a,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b){var c=a("../lib/decorators/unhandledRejection"),d=c(a("../lib/Promise"));b.exports="undefined"!=typeof global?global.Promise=d:"undefined"!=typeof self?self.Promise=d:d},{"../lib/Promise":2,"../lib/decorators/unhandledRejection":4}],2:[function(b,c){!function(a){"use strict";a(function(a){var b=a("./makePromise"),c=a("./Scheduler"),d=a("./env").asap;return b({scheduler:new c(d)})})}("function"==typeof a&&a.amd?a:function(a){c.exports=a(b)})},{"./Scheduler":3,"./env":5,"./makePromise":7}],3:[function(b,c){!function(a){"use strict";a(function(){function a(a){this._async=a,this._running=!1,this._queue=this,this._queueLen=0,this._afterQueue={},this._afterQueueLen=0;var b=this;this.drain=function(){b._drain()}}return a.prototype.enqueue=function(a){this._queue[this._queueLen++]=a,this.run()},a.prototype.afterQueue=function(a){this._afterQueue[this._afterQueueLen++]=a,this.run()},a.prototype.run=function(){this._running||(this._running=!0,this._async(this.drain))},a.prototype._drain=function(){for(var a=0;a<this._queueLen;++a)this._queue[a].run(),this._queue[a]=void 0;for(this._queueLen=0,this._running=!1,a=0;a<this._afterQueueLen;++a)this._afterQueue[a].run(),this._afterQueue[a]=void 0;this._afterQueueLen=0},a})}("function"==typeof a&&a.amd?a:function(a){c.exports=a()})},{}],4:[function(b,c){!function(a){"use strict";a(function(a){function b(a){throw a}function c(){}var d=a("../env").setTimer,e=a("../format");return function(a){function f(a){a.handled||(n.push(a),k("Potentially unhandled rejection ["+a.id+"] "+e.formatError(a.value)))}function g(a){var b=n.indexOf(a);b>=0&&(n.splice(b,1),l("Handled previous rejection ["+a.id+"] "+e.formatObject(a.value)))}function h(a,b){m.push(a,b),null===o&&(o=d(i,0))}function i(){for(o=null;m.length>0;)m.shift()(m.shift())}var j,k=c,l=c;"undefined"!=typeof console&&(j=console,k="undefined"!=typeof j.error?function(a){j.error(a)}:function(a){j.log(a)},l="undefined"!=typeof j.info?function(a){j.info(a)}:function(a){j.log(a)}),a.onPotentiallyUnhandledRejection=function(a){h(f,a)},a.onPotentiallyUnhandledRejectionHandled=function(a){h(g,a)},a.onFatalRejection=function(a){h(b,a.value)};var m=[],n=[],o=null;return a}})}("function"==typeof a&&a.amd?a:function(a){c.exports=a(b)})},{"../env":5,"../format":6}],5:[function(b,c){!function(a){"use strict";a(function(a){function b(){return"undefined"!=typeof process&&null!==process&&"function"==typeof process.nextTick}function c(){return"function"==typeof MutationObserver&&MutationObserver||"function"==typeof WebKitMutationObserver&&WebKitMutationObserver}function d(a){function b(){var a=c;c=void 0,a()}var c,d=document.createTextNode(""),e=new a(b);e.observe(d,{characterData:!0});var f=0;return function(a){c=a,d.data=f^=1}}var e,f="undefined"!=typeof setTimeout&&setTimeout,g=function(a,b){return setTimeout(a,b)},h=function(a){return clearTimeout(a)},i=function(a){return f(a,0)};if(b())i=function(a){return process.nextTick(a)};else if(e=c())i=d(e);else if(!f){var j=a,k=j("vertx");g=function(a,b){return k.setTimer(b,a)},h=k.cancelTimer,i=k.runOnLoop||k.runOnContext}return{setTimer:g,clearTimer:h,asap:i}})}("function"==typeof a&&a.amd?a:function(a){c.exports=a(b)})},{}],6:[function(b,c){!function(a){"use strict";a(function(){function a(a){var c="object"==typeof a&&null!==a&&a.stack?a.stack:b(a);return a instanceof Error?c:c+" (WARNING: non-Error used)"}function b(a){var b=String(a);return"[object Object]"===b&&"undefined"!=typeof JSON&&(b=c(a,b)),b}function c(a,b){try{return JSON.stringify(a)}catch(c){return b}}return{formatError:a,formatObject:b,tryStringify:c}})}("function"==typeof a&&a.amd?a:function(a){c.exports=a()})},{}],7:[function(b,c){!function(a){"use strict";a(function(){return function(a){function b(a,b){this._handler=a===t?b:c(a)}function c(a){function b(a){e.resolve(a)}function c(a){e.reject(a)}function d(a){e.notify(a)}var e=new v;try{a(b,c,d)}catch(f){c(f)}return e}function d(a){return I(a)?a:new b(t,new w(q(a)))}function e(a){return new b(t,new w(new z(a)))}function f(){return _}function g(){return new b(t,new v)}function h(a,b){var c=new v(a.receiver,a.join().context);return new b(t,c)}function i(a){return k(S,null,a)}function j(a,b){return k(N,a,b)}function k(a,c,d){function e(b,e,g){g.resolved||l(d,f,b,a(c,e,b),g)}function f(a,b,c){k[a]=b,0===--j&&c.become(new y(k))}for(var g,h="function"==typeof c?e:f,i=new v,j=d.length>>>0,k=new Array(j),m=0;m<d.length&&!i.resolved;++m)g=d[m],void 0!==g||m in d?l(d,h,m,g,i):--j;return 0===j&&i.become(new y(k)),new b(t,i)}function l(a,b,c,d,e){if(J(d)){var f=r(d),g=f.state();0===g?f.fold(b,c,void 0,e):g>0?b(c,f.value,e):(e.become(f),m(a,c+1,f))}else b(c,d,e)}function m(a,b,c){for(var d=b;d<a.length;++d)n(q(a[d]),c)}function n(a,b){if(a!==b){var c=a.state();0===c?a.visit(a,void 0,a._unreport):0>c&&a._unreport()}}function o(a){return"object"!=typeof a||null===a?e(new TypeError("non-iterable passed to race()")):0===a.length?f():1===a.length?d(a[0]):p(a)}function p(a){var c,d,e,f=new v;for(c=0;c<a.length;++c)if(d=a[c],void 0!==d||c in a){if(e=q(d),0!==e.state()){f.become(e),m(a,c+1,e);break}e.visit(f,f.resolve,f.reject)}return new b(t,f)}function q(a){return I(a)?a._handler.join():J(a)?s(a):new y(a)}function r(a){return I(a)?a._handler.join():s(a)}function s(a){try{var b=a.then;return"function"==typeof b?new x(b,a):new y(a)}catch(c){return new z(c)}}function t(){}function u(){}function v(a,c){b.createContext(this,c),this.consumers=void 0,this.receiver=a,this.handler=void 0,this.resolved=!1}function w(a){this.handler=a}function x(a,b){v.call(this),V.enqueue(new F(a,b,this))}function y(a){b.createContext(this),this.value=a}function z(a){b.createContext(this),this.id=++Z,this.value=a,this.handled=!1,this.reported=!1,this._report()}function A(a,b){this.rejection=a,this.context=b}function B(a){this.rejection=a}function C(){return new z(new TypeError("Promise cycle"))}function D(a,b){this.continuation=a,this.handler=b}function E(a,b){this.handler=b,this.value=a}function F(a,b,c){this._then=a,this.thenable=b,this.resolver=c}function G(a,b,c,d,e){try{a.call(b,c,d,e)}catch(f){d(f)}}function H(a,b,c,d){this.f=a,this.z=b,this.c=c,this.to=d,this.resolver=Y,this.receiver=this}function I(a){return a instanceof b}function J(a){return("object"==typeof a||"function"==typeof a)&&null!==a}function K(a,c,d,e){return"function"!=typeof a?e.become(c):(b.enterContext(c),O(a,c.value,d,e),void b.exitContext())}function L(a,c,d,e,f){return"function"!=typeof a?f.become(d):(b.enterContext(d),P(a,c,d.value,e,f),void b.exitContext())}function M(a,c,d,e,f){return"function"!=typeof a?f.notify(c):(b.enterContext(d),Q(a,c,e,f),void b.exitContext())}function N(a,b,c){try{return a(b,c)}catch(d){return e(d)}}function O(a,b,c,d){try{d.become(q(a.call(c,b)))}catch(e){d.become(new z(e))}}function P(a,b,c,d,e){try{a.call(d,b,c,e)}catch(f){e.become(new z(f))}}function Q(a,b,c,d){try{d.notify(a.call(c,b))}catch(e){d.notify(e)}}function R(a,b){b.prototype=X(a.prototype),b.prototype.constructor=b}function S(a,b){return b}function T(){}function U(){return"undefined"!=typeof process&&null!==process&&"function"==typeof process.emit?function(a,b){return"unhandledRejection"===a?process.emit(a,b.value,b):process.emit(a,b)}:"undefined"!=typeof self&&"function"==typeof CustomEvent?function(a,b,c){var d=!1;try{var e=new c("unhandledRejection");d=e instanceof c}catch(f){}return d?function(a,d){var e=new c(a,{detail:{reason:d.value,key:d},bubbles:!1,cancelable:!0});return!b.dispatchEvent(e)}:a}(T,self,CustomEvent):T}var V=a.scheduler,W=U(),X=Object.create||function(a){function b(){}return b.prototype=a,new b};b.resolve=d,b.reject=e,b.never=f,b._defer=g,b._handler=q,b.prototype.then=function(a,b,c){var d=this._handler,e=d.join().state();if("function"!=typeof a&&e>0||"function"!=typeof b&&0>e)return new this.constructor(t,d);var f=this._beget(),g=f._handler;return d.chain(g,d.receiver,a,b,c),f},b.prototype["catch"]=function(a){return this.then(void 0,a)},b.prototype._beget=function(){return h(this._handler,this.constructor)},b.all=i,b.race=o,b._traverse=j,b._visitRemaining=m,t.prototype.when=t.prototype.become=t.prototype.notify=t.prototype.fail=t.prototype._unreport=t.prototype._report=T,t.prototype._state=0,t.prototype.state=function(){return this._state},t.prototype.join=function(){for(var a=this;void 0!==a.handler;)a=a.handler;return a},t.prototype.chain=function(a,b,c,d,e){this.when({resolver:a,receiver:b,fulfilled:c,rejected:d,progress:e})},t.prototype.visit=function(a,b,c,d){this.chain(Y,a,b,c,d)},t.prototype.fold=function(a,b,c,d){this.when(new H(a,b,c,d))},R(t,u),u.prototype.become=function(a){a.fail()};var Y=new u;R(t,v),v.prototype._state=0,v.prototype.resolve=function(a){this.become(q(a))},v.prototype.reject=function(a){this.resolved||this.become(new z(a))},v.prototype.join=function(){if(!this.resolved)return this;for(var a=this;void 0!==a.handler;)if(a=a.handler,a===this)return this.handler=C();return a},v.prototype.run=function(){var a=this.consumers,b=this.handler;this.handler=this.handler.join(),this.consumers=void 0;for(var c=0;c<a.length;++c)b.when(a[c])},v.prototype.become=function(a){this.resolved||(this.resolved=!0,this.handler=a,void 0!==this.consumers&&V.enqueue(this),void 0!==this.context&&a._report(this.context))},v.prototype.when=function(a){this.resolved?V.enqueue(new D(a,this.handler)):void 0===this.consumers?this.consumers=[a]:this.consumers.push(a)},v.prototype.notify=function(a){this.resolved||V.enqueue(new E(a,this))},v.prototype.fail=function(a){var b="undefined"==typeof a?this.context:a;this.resolved&&this.handler.join().fail(b)},v.prototype._report=function(a){this.resolved&&this.handler.join()._report(a)},v.prototype._unreport=function(){this.resolved&&this.handler.join()._unreport()},R(t,w),w.prototype.when=function(a){V.enqueue(new D(a,this))},w.prototype._report=function(a){this.join()._report(a)},w.prototype._unreport=function(){this.join()._unreport()},R(v,x),R(t,y),y.prototype._state=1,y.prototype.fold=function(a,b,c,d){L(a,b,this,c,d)},y.prototype.when=function(a){K(a.fulfilled,this,a.receiver,a.resolver)};var Z=0;R(t,z),z.prototype._state=-1,z.prototype.fold=function(a,b,c,d){d.become(this)},z.prototype.when=function(a){"function"==typeof a.rejected&&this._unreport(),K(a.rejected,this,a.receiver,a.resolver)},z.prototype._report=function(a){V.afterQueue(new A(this,a))},z.prototype._unreport=function(){this.handled||(this.handled=!0,V.afterQueue(new B(this)))},z.prototype.fail=function(a){this.reported=!0,W("unhandledRejection",this),b.onFatalRejection(this,void 0===a?this.context:a)},A.prototype.run=function(){this.rejection.handled||this.rejection.reported||(this.rejection.reported=!0,W("unhandledRejection",this.rejection)||b.onPotentiallyUnhandledRejection(this.rejection,this.context))},B.prototype.run=function(){this.rejection.reported&&(W("rejectionHandled",this.rejection)||b.onPotentiallyUnhandledRejectionHandled(this.rejection))},b.createContext=b.enterContext=b.exitContext=b.onPotentiallyUnhandledRejection=b.onPotentiallyUnhandledRejectionHandled=b.onFatalRejection=T;var $=new t,_=new b(t,$);return D.prototype.run=function(){this.handler.join().when(this.continuation)},E.prototype.run=function(){var a=this.handler.consumers;if(void 0!==a)for(var b,c=0;c<a.length;++c)b=a[c],M(b.progress,this.value,this.handler,b.receiver,b.resolver)},F.prototype.run=function(){function a(a){d.resolve(a)}function b(a){d.reject(a)}function c(a){d.notify(a)}var d=this.resolver;G(this._then,this.thenable,a,b,c)},H.prototype.fulfilled=function(a){this.f.call(this.c,this.z,a,this.to)},H.prototype.rejected=function(a){this.to.reject(a)},H.prototype.progress=function(a){this.to.notify(a)},b}})}("function"==typeof a&&a.amd?a:function(a){c.exports=a()})},{}]},{},[1])(1)}),function(__global){function __eval(__source,__global,__load){try{eval('(function() { var __moduleName = "'+(__load.name||"").replace('"','"')+'"; '+__source+" \n }).call(__global);")}catch(e){throw("SyntaxError"==e.name||"TypeError"==e.name)&&(e.message="Evaluating "+(__load.name||load.address)+"\n	"+e.message),e}}$__Object$getPrototypeOf=Object.getPrototypeOf||function(a){return a.__proto__};var $__Object$defineProperty;!function(){try{Object.defineProperty({},"a",{})&&($__Object$defineProperty=Object.defineProperty)}catch(a){$__Object$defineProperty=function(a,b,c){try{a[b]=c.value||c.get.call(a)}catch(d){}}}}(),$__Object$create=Object.create||function(a,b){function c(){}if(c.prototype=a,"object"==typeof b)for(prop in b)b.hasOwnProperty(prop)&&(c[prop]=b[prop]);return new c},function(){function a(a){return{status:"loading",name:a,linkSets:[],dependencies:[],metadata:{}}}function b(a,b,c){return new A(g({step:c.address?"fetch":"locate",loader:a,moduleName:b,moduleMetadata:c&&c.metadata||{},moduleSource:c.source,moduleAddress:c.address}))}function c(b,c,e,f){return new A(function(a){a(b.loaderObj.normalize(c,e,f))}).then(function(c){var e;if(b.modules[c])return e=a(c),e.status="linked",e.module=b.modules[c],e;for(var f=0,g=b.loads.length;g>f;f++)if(e=b.loads[f],e.name==c)return e;return e=a(c),b.loads.push(e),d(b,e),e})}function d(a,b){e(a,b,A.resolve().then(function(){return a.loaderObj.locate({name:b.name,metadata:b.metadata})}))}function e(a,b,c){f(a,b,c.then(function(c){return"loading"==b.status?(b.address=c,a.loaderObj.fetch({name:b.name,metadata:b.metadata,address:c})):void 0}))}function f(a,b,d){d.then(function(d){return"loading"==b.status?A.resolve(a.loaderObj.translate({name:b.name,metadata:b.metadata,address:b.address,source:d})).then(function(c){return b.source=c,a.loaderObj.instantiate({name:b.name,metadata:b.metadata,address:b.address,source:c})}).then(function(c){if(void 0===c)return b.address=b.address||"<Anonymous Module "+ ++D+">",b.isDeclarative=!0,a.loaderObj.transpile(b).then(function(a){var c=__global.System,d=c.register;c.register=function(a,c,d){"string"!=typeof a&&(d=c,c=a),b.declare=d,b.depsList=c},__eval(a,__global,b),c.register=d});if("object"!=typeof c)throw TypeError("Invalid instantiate return value");b.depsList=c.deps||[],b.execute=c.execute,b.isDeclarative=!1}).then(function(){b.dependencies=[];for(var d=b.depsList,e=[],f=0,g=d.length;g>f;f++)(function(d,f){e.push(c(a,d,b.name,b.address).then(function(a){if(b.dependencies[f]={key:d,value:a.name},"linked"!=a.status)for(var c=b.linkSets.concat([]),e=0,g=c.length;g>e;e++)i(c[e],a)}))})(d[f],f);return A.all(e)}).then(function(){b.status="loaded";for(var a=b.linkSets.concat([]),c=0,d=a.length;d>c;c++)k(a[c],b)}):void 0})["catch"](function(a){b.status="failed",b.exception=a;for(var c=b.linkSets.concat([]),d=0,e=c.length;e>d;d++)l(c[d],b,a)})}function g(b){return function(c){var g=b.loader,i=b.moduleName,j=b.step;if(g.modules[i])throw new TypeError('"'+i+'" already exists in the module table');for(var k,l=0,m=g.loads.length;m>l;l++)if(g.loads[l].name==i)return k=g.loads[l],"translate"!=j||k.source||(k.address=b.moduleAddress,f(g,k,A.resolve(b.moduleSource))),k.linkSets[0].done.then(function(){c(k)});var n=a(i);n.metadata=b.moduleMetadata;var o=h(g,n);g.loads.push(n),c(o.done),"locate"==j?d(g,n):"fetch"==j?e(g,n,A.resolve(b.moduleAddress)):(n.address=b.moduleAddress,f(g,n,A.resolve(b.moduleSource)))}}function h(a,b){var c={loader:a,loads:[],startingLoad:b,loadingCount:0};return c.done=new A(function(a,b){c.resolve=a,c.reject=b}),i(c,b),c}function i(a,b){for(var c=0,d=a.loads.length;d>c;c++)if(a.loads[c]==b)return;a.loads.push(b),b.linkSets.push(a),"loaded"!=b.status&&a.loadingCount++;for(var e=a.loader,c=0,d=b.dependencies.length;d>c;c++){var f=b.dependencies[c].value;if(!e.modules[f])for(var g=0,h=e.loads.length;h>g;g++)if(e.loads[g].name==f){i(a,e.loads[g]);break}}}function j(a){var b=!1;try{p(a,function(c,d){l(a,c,d),b=!0})}catch(c){l(a,null,c),b=!0}return b}function k(a,b){if(a.loadingCount--,!(a.loadingCount>0)){var c=a.startingLoad;if(a.loader.loaderObj.execute===!1){for(var d=[].concat(a.loads),e=0,f=d.length;f>e;e++){var b=d[e];b.module=b.isDeclarative?{name:b.name,module:E({}),evaluated:!0}:{module:E({})},b.status="linked",m(a.loader,b)}return a.resolve(c)}var g=j(a);g||a.resolve(c)}}function l(a,b,c){var d=a.loader;b&&a.loads[0].name!=b.name&&(c=w(c,'Error loading "'+b.name+'" from "'+a.loads[0].name+'" at '+(a.loads[0].address||"<unknown>")+"\n")),b&&(c=w(c,'Error loading "'+b.name+'" at '+(b.address||"<unknown>")+"\n"));for(var e=a.loads.concat([]),f=0,g=e.length;g>f;f++){var b=e[f];d.loaderObj.failed=d.loaderObj.failed||[],-1==B.call(d.loaderObj.failed,b)&&d.loaderObj.failed.push(b);var h=B.call(b.linkSets,a);if(b.linkSets.splice(h,1),0==b.linkSets.length){var i=B.call(a.loader.loads,b);-1!=i&&a.loader.loads.splice(i,1)}}a.reject(c)}function m(a,b){if(a.loaderObj.trace){a.loaderObj.loads||(a.loaderObj.loads={});var c={};b.dependencies.forEach(function(a){c[a.key]=a.value}),a.loaderObj.loads[b.name]={name:b.name,deps:b.dependencies.map(function(a){return a.key}),depMap:c,address:b.address,metadata:b.metadata,source:b.source,kind:b.isDeclarative?"declarative":"dynamic"}}b.name&&(a.modules[b.name]=b.module);var d=B.call(a.loads,b);-1!=d&&a.loads.splice(d,1);for(var e=0,f=b.linkSets.length;f>e;e++)d=B.call(b.linkSets[e].loads,b),-1!=d&&b.linkSets[e].loads.splice(d,1);b.linkSets.splice(0,b.linkSets.length)}function n(a,b,c){if(c[a.groupIndex]=c[a.groupIndex]||[],-1==B.call(c[a.groupIndex],a)){c[a.groupIndex].push(a);for(var d=0,e=b.length;e>d;d++)for(var f=b[d],g=0;g<a.dependencies.length;g++)if(f.name==a.dependencies[g].value){var h=a.groupIndex+(f.isDeclarative!=a.isDeclarative);if(void 0===f.groupIndex||f.groupIndex<h){if(void 0!==f.groupIndex&&(c[f.groupIndex].splice(B.call(c[f.groupIndex],f),1),0==c[f.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");f.groupIndex=h}n(f,b,c)}}}function o(a,b,c){try{var d=b.execute()}catch(e){return void c(b,e)}return d&&d instanceof y?d:void c(b,new TypeError("Execution must define a Module instance"))}function p(a,b){var c=a.loader;if(a.loads.length){var d=[],e=a.loads[0];e.groupIndex=0,n(e,a.loads,d);for(var f=e.isDeclarative==d.length%2,g=d.length-1;g>=0;g--){for(var h=d[g],i=0;i<h.length;i++){var j=h[i];if(f)r(j,a.loads,c);else{var k=o(a,j,b);if(!k)return;j.module={name:j.name,module:k},j.status="linked"}m(c,j)}f=!f}}}function q(a,b){var c=b.moduleRecords;return c[a]||(c[a]={name:a,dependencies:[],module:new y,importers:[]})}function r(a,b,c){if(!a.module){var d=a.module=q(a.name,c),e=a.module.module,f=a.declare.call(__global,function(a,b){d.locked=!0,e[a]=b;for(var c=0,f=d.importers.length;f>c;c++){var g=d.importers[c];if(!g.locked){var h=B.call(g.dependencies,d);g.setters[h](e)}}return d.locked=!1,b});d.setters=f.setters,d.execute=f.execute;for(var g=0,h=a.dependencies.length;h>g;g++){var i=a.dependencies[g].value,j=c.modules[i];if(!j)for(var k=0;k<b.length;k++)b[k].name==i&&(b[k].module?j=q(i,c):(r(b[k],b,c),j=b[k].module));j.importers?(d.dependencies.push(j),j.importers.push(d)):d.dependencies.push(null),d.setters[g]&&d.setters[g](j.module)}a.status="linked"}}function s(a,b){return u(b.module,[],a),b.module.module}function t(a){try{a.execute.call(__global)}catch(b){return b}}function u(a,b,c){var d=v(a,b,c);if(d)throw d}function v(a,b,c){if(!a.evaluated&&a.dependencies){b.push(a);for(var d,e=a.dependencies,f=0,g=e.length;g>f;f++){var h=e[f];if(h&&-1==B.call(b,h)&&(d=v(h,b,c)))return d=w(d,"Error evaluating "+h.name+"\n")}if(a.failed)return new Error("Module failed execution.");if(!a.evaluated)return a.evaluated=!0,d=t(a),d?a.failed=!0:Object.preventExtensions&&Object.preventExtensions(a.module),a.execute=void 0,d}}function w(a,b){return a instanceof Error?a.message=b+a.message:a=b+a,a}function x(a){if("object"!=typeof a)throw new TypeError("Options must be an object");a.normalize&&(this.normalize=a.normalize),a.locate&&(this.locate=a.locate),a.fetch&&(this.fetch=a.fetch),a.translate&&(this.translate=a.translate),a.instantiate&&(this.instantiate=a.instantiate),this._loader={loaderObj:this,loads:[],modules:{},importPromises:{},moduleRecords:{}},C(this,"global",{get:function(){return __global}})}function y(){}function z(a,b,c){var d=a._loader.importPromises;return d[b]=c.then(function(a){return d[b]=void 0,a},function(a){throw d[b]=void 0,a})}var A=__global.Promise||require("when/es6-shim/Promise");__global.console&&(console.assert=console.assert||function(){});var B=Array.prototype.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},C=$__Object$defineProperty,D=0;x.prototype={constructor:x,define:function(a,b,c){if(this._loader.importPromises[a])throw new TypeError("Module is already loading.");return z(this,a,new A(g({step:"translate",loader:this._loader,moduleName:a,moduleMetadata:c&&c.metadata||{},moduleSource:b,moduleAddress:c&&c.address})))},"delete":function(a){var b=this._loader;return delete b.importPromises[a],delete b.moduleRecords[a],b.modules[a]?delete b.modules[a]:!1},get:function(a){return this._loader.modules[a]?(u(this._loader.modules[a],[],this),this._loader.modules[a].module):void 0},has:function(a){return!!this._loader.modules[a]},"import":function(a,c){var d=this;return A.resolve(d.normalize(a,c&&c.name,c&&c.address)).then(function(a){var e=d._loader;return e.modules[a]?(u(e.modules[a],[],e._loader),e.modules[a].module):e.importPromises[a]||z(d,a,b(e,a,c||{}).then(function(b){return delete e.importPromises[a],s(e,b)}))})},load:function(a){return this._loader.modules[a]?(u(this._loader.modules[a],[],this._loader),A.resolve(this._loader.modules[a].module)):this._loader.importPromises[a]||z(this,a,b(this._loader,a,{}))},module:function(b,c){var d=a();d.address=c&&c.address;var e=h(this._loader,d),g=A.resolve(b),i=this._loader,j=e.done.then(function(){return s(i,d)});return f(i,d,g),j},newModule:function(a){if("object"!=typeof a)throw new TypeError("Expected object");var b,c=new y;if(Object.getOwnPropertyNames&&null!=a)b=Object.getOwnPropertyNames(a);else{b=[];for(var d in a)b.push(d)}for(var e=0;e<b.length;e++)(function(b){C(c,b,{configurable:!1,enumerable:!0,get:function(){return a[b]}})})(b[e]);return Object.preventExtensions&&Object.preventExtensions(c),c},set:function(a,b){if(!(b instanceof y))throw new TypeError("Loader.set("+a+", module) must be a module");this._loader.modules[a]={module:b}},normalize:function(a){return a},locate:function(a){return a.name},fetch:function(){throw new TypeError("Fetch not implemented")},translate:function(a){return a.source},instantiate:function(){}};var E=x.prototype.newModule;"object"==typeof exports&&(module.exports=x),__global.Reflect=__global.Reflect||{},__global.Reflect.Loader=__global.Reflect.Loader||x,__global.Reflect.global=__global.Reflect.global||__global,__global.LoaderPolyfill=x}(),function(a){function b(a,b){return a.newModule({"default":f[b],__useDefault:!0})}function c(a,b){var c=this.traceurOptions||{};c.modules="instantiate",c.script=!1,c.sourceMaps="inline",c.filename=a.address,c.inputSourceMap=a.metadata.sourceMap,c.moduleName=!1;var e=new b.Compiler(c),f=d(a.source,e,c.filename);return f+"\n//# sourceURL="+a.address+"!eval"}function d(a,b,c){try{return b.compile(a,c)}catch(d){throw d[0]}}function e(a,b){var c=this.babelOptions||{};c.modules="system",c.sourceMap="inline",c.filename=a.address,c.code=!0,c.ast=!1,c.blacklist||(c.blacklist=["react"]);var d=b.transform(a.source,c).code;return d+"\n//# sourceURL="+a.address+"!eval"}var f=__global;a.prototype.transpiler="traceur",a.prototype.transpile=function(a){var d=this;return d.transpilerHasRun||(f.traceur&&!d.has("traceur")&&d.set("traceur",b(d,"traceur")),f.babel&&!d.has("babel")&&d.set("babel",b(d,"babel")),d.transpilerHasRun=!0),d["import"](d.transpiler).then(function(b){return b.__useDefault&&(b=b["default"]),'var __moduleAddress = "'+a.address+'";'+(b.Compiler?c:e).call(d,a,b)})},a.prototype.instantiate=function(a){var c=this;return Promise.resolve(c.normalize(c.transpiler)).then(function(d){return a.name===d?{deps:[],execute:function(){var d=f.System,e=f.Reflect.Loader;return __eval("(function(require,exports,module){"+a.source+"})();",f,a),f.System=d,f.Reflect.Loader=e,b(c,a.name)}}:void 0})}}(__global.LoaderPolyfill),function(){function a(a){var b=String(a).replace(/^\s+|\s+$/g,"").match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/?#]*(?::[^:@\/?#]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);return b?{href:b[0]||"",protocol:b[1]||"",authority:b[2]||"",host:b[3]||"",hostname:b[4]||"",port:b[5]||"",pathname:b[6]||"",search:b[7]||"",hash:b[8]||""}:null}function b(a){var b=[];return a.replace(/^(\.\.?(\/|$))+/,"").replace(/\/(\.(\/|$))+/g,"/").replace(/\/\.\.$/,"/../").replace(/\/?[^\/]*/g,function(a){"/.."===a?b.pop():b.push(a)}),b.join("").replace(/^\//,"/"===a.charAt(0)?"/":"")}function c(c,d){return h&&(d=d.replace(/\\/g,"/")),d=a(d||""),c=a(c||""),d&&c?(d.protocol||c.protocol)+(d.protocol||d.authority?d.authority:c.authority)+b(d.protocol||d.authority||"/"===d.pathname.charAt(0)?d.pathname:d.pathname?(c.authority&&!c.pathname?"/":"")+c.pathname.slice(0,c.pathname.lastIndexOf("/")+1)+d.pathname:c.pathname)+(d.protocol||d.authority||d.pathname?d.search:d.search||c.search)+d.hash:null}function d(){document.removeEventListener("DOMContentLoaded",d,!1),window.removeEventListener("load",d,!1),e()}function e(){for(var a=document.getElementsByTagName("script"),b=0;b<a.length;b++){var c=a[b];if("module"==c.type){var d=c.innerHTML.substr(1);__global.System.module(d)["catch"](function(a){setTimeout(function(){throw a})})}}}var f,g="undefined"!=typeof window&&"undefined"!=typeof document,h="undefined"!=typeof process&&!!process.platform.match(/^win/),i=__global.Promise||require("when/es6-shim/Promise");if("undefined"!=typeof XMLHttpRequest)f=function(a,b,c){function d(){b(f.responseText)}function e(){c(f.statusText+": "+a||"XHR error")}var f=new XMLHttpRequest,g=!0,h=!1;if(!("withCredentials"in f)){var i=/^(\w+:)?\/\/([^\/]+)/.exec(a);i&&(g=i[2]===window.location.host,i[1]&&(g&=i[1]===window.location.protocol))}g||"undefined"==typeof XDomainRequest||(f=new XDomainRequest,f.onload=d,f.onerror=e,f.ontimeout=e,f.onprogress=function(){},f.timeout=0,h=!0),f.onreadystatechange=function(){4===f.readyState&&(200===f.status||0==f.status&&f.responseText?d():e())},f.open("GET",a,!0),h&&setTimeout(function(){f.send()},0),f.send(null)};else{if("undefined"==typeof require)throw new TypeError("No environment fetch API available.");var j;f=function(a,b,c){if("file:"!=a.substr(0,5))throw"Only file URLs of the form file: allowed running in Node.";return j=j||require("fs"),a=a.substr(5),h&&(a=a.replace(/\//g,"\\")),j.readFile(a,function(a,d){return a?c(a):void b(d+"")})}}var k=function(a){function b(b){if(a.call(this,b||{}),"undefined"!=typeof location&&location.href){var c=__global.location.href.split("#")[0].split("?")[0];this.baseURL=c.substring(0,c.lastIndexOf("/")+1)}else{if("undefined"==typeof process||!process.cwd)throw new TypeError("No environment baseURL");this.baseURL="file:"+process.cwd()+"/",h&&(this.baseURL=this.baseURL.replace(/\\/g,"/"))}this.paths={"*":"*.js"}}return b.__proto__=null!==a?a:Function.prototype,b.prototype=$__Object$create(null!==a?a.prototype:null),$__Object$defineProperty(b.prototype,"constructor",{value:b}),$__Object$defineProperty(b.prototype,"global",{get:function(){return __global},enumerable:!1}),$__Object$defineProperty(b.prototype,"strict",{get:function(){return!0},enumerable:!1}),$__Object$defineProperty(b.prototype,"normalize",{value:function(a,b){if("string"!=typeof a)throw new TypeError("Module name must be a string");var c=a.split("/");if(0==c.length)throw new TypeError("No module name provided");var d=0,e=!1,f=0;if("."==c[0]){if(d++,d==c.length)throw new TypeError('Illegal module name "'+a+'"');e=!0}else{for(;".."==c[d];)if(d++,d==c.length)throw new TypeError('Illegal module name "'+a+'"');d&&(e=!0),f=d}for(var g=d;g<c.length;g++){var h=c[g];if(""==h||"."==h||".."==h)throw new TypeError('Illegal module name "'+a+'"')}if(!e)return a;{var i=[],j=(b||"").split("/");j.length-1-f}return i=i.concat(j.splice(0,j.length-1-f)),i=i.concat(c.splice(d,c.length-d)),i.join("/")},enumerable:!1,writable:!0}),$__Object$defineProperty(b.prototype,"locate",{value:function(a){var b,d=a.name,e="";for(var f in this.paths){var h=f.split("*");if(h.length>2)throw new TypeError("Only one wildcard in a path is permitted");if(1==h.length){if(d==f&&f.length>e.length){e=f;break}}else d.substr(0,h[0].length)==h[0]&&d.substr(d.length-h[1].length)==h[1]&&(e=f,b=d.substr(h[0].length,d.length-h[1].length-h[0].length))}var i=this.paths[e];return b&&(i=i.replace("*",b)),g&&(i=i.replace(/#/g,"%23")),c(this.baseURL,i)},enumerable:!1,writable:!0}),$__Object$defineProperty(b.prototype,"fetch",{value:function(a){var b=this;return new i(function(d,e){f(c(b.baseURL,a.address),function(a){d(a)},e)})},enumerable:!1,writable:!0}),b}(__global.LoaderPolyfill),l=new k;if("object"==typeof exports&&(module.exports=l),__global.System=l,g&&document.getElementsByTagName){var m=document.getElementsByTagName("script");m=m[m.length-1],"complete"===document.readyState?setTimeout(e):document.addEventListener&&(document.addEventListener("DOMContentLoaded",d,!1),window.addEventListener("load",d,!1)),m.getAttribute("data-init")&&window[m.getAttribute("data-init")]()}}()}("undefined"!=typeof window?window:"undefined"!=typeof global?global:self);
//# sourceMappingURL=es6-module-loader.js.map
!function($__global,$__globalName){$__global.upgradeSystemLoader=function(){function e(e){var t=String(e).replace(/^\s+|\s+$/g,"").match(/^([^:\/?#]+:)?(\/\/(?:[^:@\/?#]*(?::[^:@\/?#]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);return t?{href:t[0]||"",protocol:t[1]||"",authority:t[2]||"",host:t[3]||"",hostname:t[4]||"",port:t[5]||"",pathname:t[6]||"",search:t[7]||"",hash:t[8]||""}:null}function t(t,a){function r(e){var t=[];return e.replace(/^(\.\.?(\/|$))+/,"").replace(/\/(\.(\/|$))+/g,"/").replace(/\/\.\.$/,"/../").replace(/\/?[^\/]*/g,function(e){"/.."===e?t.pop():t.push(e)}),t.join("").replace(/^\//,"/"===e.charAt(0)?"/":"")}return v&&(a=a.replace(/\\/g,"/")),a=e(a||""),t=e(t||""),a&&t?(a.protocol||t.protocol)+(a.protocol||a.authority?a.authority:t.authority)+r(a.protocol||a.authority||"/"===a.pathname.charAt(0)?a.pathname:a.pathname?(t.authority&&!t.pathname?"/":"")+t.pathname.slice(0,t.pathname.lastIndexOf("/")+1)+a.pathname:t.pathname)+(a.protocol||a.authority||a.pathname?a.search:a.search||t.search)+a.hash:null}function a(e){function r(e,t){t._extensions=[];for(var a=0,r=e.length;r>a;a++)e[a](t)}var n=e["import"];e["import"]=function(e,t){return n.call(this,e,t).then(function(e){return e.__useDefault?e["default"]:e})},e.set("@empty",e.newModule({})),"undefined"!=typeof require&&(e._nodeRequire=require),e.config=function(e){for(var t in e){var a=e[t];if("object"!=typeof a||a instanceof Array)this[t]=a;else{this[t]=this[t]||{};for(var r in a)this[t][r]=a[r]}}};var o;if("undefined"==typeof window&&"undefined"==typeof WorkerGlobalScope&&"undefined"!=typeof process)o="file:"+process.cwd()+"/",v&&(o=o.replace(/\\/g,"/"));else if("undefined"==typeof window)o=location.href;else if(o=document.baseURI,!o){var i=document.getElementsByTagName("base");o=i[0]&&i[0].href||window.location.href}var s,l=e.locate;e.locate=function(e){return this.baseURL!=s&&(s=t(o,this.baseURL),"/"!=s.substr(s.length-1,1)&&(s+="/"),this.baseURL=s),Promise.resolve(l.call(this,e))},e._extensions=e._extensions||[],e._extensions.push(a),e.clone=function(){var e=this,t=new LoaderPolyfill(g);return t.baseURL=e.baseURL,t.paths={"*":"*.js"},r(e._extensions,t),t}}function r(e){function t(e,t){var a=e.meta&&e.meta[t.name];if(a)for(var r in a)t.metadata[r]=t.metadata[r]||a[r]}var a=/^(\s*\/\*.*\*\/|\s*\/\/[^\n]*|\s*"[^"]+"\s*;?|\s*'[^']+'\s*;?)+/,n=/\/\*.*\*\/|\/\/[^\n]*|"[^"]+"\s*;?|'[^']+'\s*;?/g;e.meta={},e._extensions=e._extensions||[],e._extensions.push(r);var o=e.locate;e.locate=function(e){return t(this,e),o.call(this,e)};var i=e.translate;e.translate=function(e){var r=e.source.match(a);if(r)for(var o=r[0].match(n),s=0;s<o.length;s++){var l=o[s].length,u=o[s].substr(0,1);if(";"==o[s].substr(l-1,1)&&l--,'"'==u||"'"==u){var d=o[s].substr(1,o[s].length-3),c=d.substr(0,d.indexOf(" "));if(c){var f=d.substr(c.length+1,d.length-c.length-1);e.metadata[c]instanceof Array?e.metadata[c].push(f):e.metadata[c]||(e.metadata[c]=f)}}}return t(this,e),i.call(this,e)}}function n(e){function a(e){var a,r=e.source.lastIndexOf("\n");-1!=r&&"//# sourceMappingURL="==e.source.substr(r+1,21)&&(a=e.source.substr(r+22,e.source.length-r-22),"undefined"!=typeof t&&(a=t(e.address,a))),__eval(e.source,e.address,a)}function r(e){for(var t=[],a=0,r=e.length;r>a;a++)-1==h.call(t,e[a])&&t.push(e[a]);return t}function o(t,a,r,n){"string"!=typeof t&&(n=r,r=a,a=t,t=null),g=!0;var o;if(o="boolean"==typeof r?{declarative:!1,deps:a,execute:n,executingRequire:r}:{declarative:!0,deps:a,declare:r},t)o.name=t,t in e.defined||(e.defined[t]=o);else if(o.declarative){if(v)throw new TypeError("Multiple anonymous System.register calls in the same module file.");v=o}}function i(e){if(!e.register){e.register=o,e.defined||(e.defined={});var t=e.onScriptLoad;e.onScriptLoad=function(e){t(e),v&&(e.metadata.entry=v),g&&(e.metadata.format=e.metadata.format||"register",e.metadata.registered=!0)}}}function s(e,t,a){if(a[e.groupIndex]=a[e.groupIndex]||[],-1==h.call(a[e.groupIndex],e)){a[e.groupIndex].push(e);for(var r=0,n=e.normalizedDeps.length;n>r;r++){var o=e.normalizedDeps[r],i=t.defined[o];if(i&&!i.evaluated){var l=e.groupIndex+(i.declarative!=e.declarative);if(void 0===i.groupIndex||i.groupIndex<l){if(void 0!==i.groupIndex&&(a[i.groupIndex].splice(h.call(a[i.groupIndex],i),1),0==a[i.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");i.groupIndex=l}s(i,t,a)}}}}function l(e,t){var a=t.defined[e];if(!a.module){a.groupIndex=0;var r=[];s(a,t,r);for(var n=!!a.declarative==r.length%2,o=r.length-1;o>=0;o--){for(var i=r[o],l=0;l<i.length;l++){var u=i[l];n?d(u,t):f(u,t)}n=!n}}}function u(e){return b[e]||(b[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(e,t){if(!e.module){var a=e.module=u(e.name),r=e.module.exports,n=e.declare.call(t.global,function(e,t){a.locked=!0,r[e]=t;for(var n=0,o=a.importers.length;o>n;n++){var i=a.importers[n];if(!i.locked){var s=h.call(i.dependencies,a);i.setters[s](r)}}return a.locked=!1,t});if(a.setters=n.setters,a.execute=n.execute,!a.setters||!a.execute)throw new TypeError("Invalid System.register form for "+e.name);for(var o=0,i=e.normalizedDeps.length;i>o;o++){var s,l=e.normalizedDeps[o],c=t.defined[l],f=b[l];f?s=f.exports:c&&!c.declarative?s=c.module.exports&&c.module.exports.__esModule?c.module.exports:{"default":c.module.exports,__useDefault:!0}:c?(d(c,t),f=c.module,s=f.exports):s=t.get(l),f&&f.importers?(f.importers.push(a),a.dependencies.push(f)):a.dependencies.push(null),a.setters[o]&&a.setters[o](s)}}}function c(e,t){var a,r=t.defined[e];if(r)r.declarative?m(e,[],t):r.evaluated||f(r,t),a=r.module.exports;else if(a=t.get(e),!a)throw new Error("Unable to load dependency "+e+".");return(!r||r.declarative)&&a&&a.__useDefault?a["default"]:a}function f(e,t){if(!e.module){var a={},r=e.module={exports:a,id:e.name};if(!e.executingRequire)for(var n=0,o=e.normalizedDeps.length;o>n;n++){var i=e.normalizedDeps[n],s=t.defined[i];s&&f(s,t)}e.evaluated=!0;var l=e.execute.call(t.global,function(a){for(var r=0,n=e.deps.length;n>r;r++)if(e.deps[r]==a)return c(e.normalizedDeps[r],t);throw new TypeError("Module "+a+" not declared as a dependency.")},a,r);l&&(r.exports=l)}}function m(e,t,a){var r=a.defined[e];if(r&&!r.evaluated&&r.declarative){t.push(e);for(var n=0,o=r.normalizedDeps.length;o>n;n++){var i=r.normalizedDeps[n];-1==h.call(t,i)&&(a.defined[i]?m(i,t,a):a.get(i))}r.evaluated||(r.evaluated=!0,r.module.execute.call(a.global))}}"undefined"==typeof h&&(h=Array.prototype.indexOf),("undefined"==typeof __eval||"undefined"!=typeof document&&!document.addEventListener)&&(__eval=0||eval),e._extensions=e._extensions||[],e._extensions.push(n);e.__exec=a;var v,g;i(e);var b={},y=e["delete"];e["delete"]=function(e){return delete b[e],y.call(this,e)};var x=/System\.register/,_=e.fetch;e.fetch=function(e){var t=this;return i(t),t.defined[e.name]?(e.metadata.format="defined",""):(v=null,g=!1,_.call(t,e))};var w=e.translate;e.translate=function(e){return this.register=o,this.__exec=a,e.metadata.deps=e.metadata.deps||[],Promise.resolve(w.call(this,e)).then(function(t){return(e.metadata.init||e.metadata.exports)&&(e.metadata.format=e.metadata.format||"global"),("register"==e.metadata.format||!e.metadata.format&&e.source.match(x))&&(e.metadata.format="register"),t})};var z=e.instantiate;e.instantiate=function(e){var t,a=this;if(a.defined[e.name])t=a.defined[e.name],t.deps=t.deps.concat(e.metadata.deps);else if(e.metadata.entry)t=e.metadata.entry;else if(e.metadata.execute)t={declarative:!1,deps:e.metadata.deps||[],execute:e.metadata.execute,executingRequire:e.metadata.executingRequire};else if("register"==e.metadata.format){v=null,g=!1;var n=a.global.System;if(a.global.System=a,a.__exec(e),a.global.System=n,v?t=v:e.metadata.bundle=!0,!t&&p.defined[e.name]&&(t=p.defined[e.name]),!g&&!e.metadata.registered)throw new TypeError(e.name+" detected as System.register but didn't execute.")}if(!t&&"es6"!=e.metadata.format)return{deps:e.metadata.deps,execute:function(){return a.newModule({})}};if(!t)return z.call(this,e);a.defined[e.name]=t,t.deps=r(t.deps),t.name=e.name;for(var o=[],i=0,s=t.deps.length;s>i;i++)o.push(Promise.resolve(a.normalize(t.deps[i],e.name)));return Promise.all(o).then(function(r){return t.normalizedDeps=r,{deps:t.deps,execute:function(){l(e.name,a),m(e.name,[],a),a.defined[e.name]=void 0;var r=t.module.exports;return(!r||!t.declarative&&r.__esModule!==!0)&&(r={"default":r,__useDefault:!0}),a.newModule(r)}}})}}function o(e){function t(e,t,r,n){e.meta=e.meta||{};var o=e.meta[t]=e.meta[t]||{};if(o.format=o.format||"global",!e.paths[t]){var i=a(r,n);i&&(e.paths[t]=i)}}function a(e,t){if(d){var a=t?"/package.json":"";try{var r=d(e+a);return"file:"+r.substr(0,r.length-a.length)+(t?"/*.js":"")}catch(n){}}}e._extensions.push(o);var r,n,i=/(^\s*|[}\);\n]\s*)(import\s+(['"]|(\*\s+as\s+)?[^"'\(\)\n;]+\s+from\s+['"]|\{)|export\s+\*\s+from\s+["']|export\s+(\{|default|function|class|var|const|let|async\s+function))/,s=/\$traceurRuntime\s*\./,l=/babelHelpers\s*\./,u=!0,d="undefined"!=typeof process&&"undefined"!=typeof require&&require.resolve,c=e.locate;e.locate=function(e){var a=this;return u&&("traceur"==a.transpiler?(t(a,"traceur","traceur/bin/traceur.js"),a.meta.traceur.exports="traceur",t(a,"traceur-runtime","traceur/bin/traceur-runtime.js")):"babel"==a.transpiler&&(t(a,"babel","babel-core/browser.js"),t(a,"babel/external-helpers","babel-core/external-helpers.js"),t(a,"babel-runtime/*","babel-runtime",!0)),u=!1),c.call(a,e)};var f=e.translate;e.translate=function(e){var t=this;return f.call(t,e).then(function(a){if("es6"==e.metadata.format||!e.metadata.format&&a.match(i))return e.metadata.format="es6",a;if("register"==e.metadata.format){if(!t.global.$traceurRuntime&&e.source.match(s))return t["import"]("traceur-runtime").then(function(){return a});if(!t.global.babelHelpers&&e.source.match(l))return t["import"]("babel/external-helpers").then(function(){return a})}return"traceur"==t.transpiler?Promise.all([r||(r=t.normalize(t.transpiler)),n||(n=t.normalize(t.transpiler+"-runtime"))]).then(function(t){return e.name==t[0]||e.name==t[1]?"(function() { var curSystem = System; "+a+"\nSystem = curSystem; })();":a}):a})}}function i(e){function t(e,t){for(var a=e.split(".");a.length;)t=t[a.shift()];return t}function a(t){if(Object.keys)Object.keys(e.global).forEach(t);else for(var a in e.global)s.call(e.global,a)&&t(a)}function r(t){a(function(a){if(-1==h.call(o,a)){try{var r=e.global[a]}catch(n){o.push(a)}t(a,r)}})}function n(e){if(!e.has("@@global-helpers")){var a,n={};e.set("@@global-helpers",e.newModule({prepareGlobal:function(t,o){for(var i=0;i<o.length;i++){var s=n[o[i]];if(s)for(var l in s)e.global[l]=s[l]}a={},r(function(e,t){a[e]=t})},retrieveGlobal:function(o,i,s){var l,u,d={};if(s)l=s.call(e.global);else if(i){var c=i.split(".")[0];l=t(i,e.global),d[c]=e.global[c]}else r(function(e,t){a[e]!==t&&"undefined"!=typeof t&&(d[e]=t,"undefined"!=typeof l?u||l===t||(u=!0):l=t)});return n[o]=d,u?d:l}}))}}e._extensions.push(i);var o=["sessionStorage","localStorage","clipboardData","frames","external"],s=Object.prototype.hasOwnProperty;n(e);var l=e.instantiate;e.instantiate=function(e){var t=this;n(t);var a=e.metadata.exports;return e.metadata.format||(e.metadata.format="global"),"global"==e.metadata.format&&(e.metadata.execute=function(r,n,o){t.get("@@global-helpers").prepareGlobal(o.id,e.metadata.deps),a&&(e.source+=$__globalName+'["'+a+'"] = '+a+";");var i=t.global.define,r=t.global.require;return t.global.define=void 0,t.global.module=void 0,t.global.exports=void 0,t.__exec(e),t.global.require=r,t.global.define=i,t.get("@@global-helpers").retrieveGlobal(o.id,a,e.metadata.init)}),l.call(t,e)}}function s(e){function t(e){r.lastIndex=0;var t=[];e.length/e.split("\n").length<200&&(e=e.replace(n,""));for(var a;a=r.exec(e);)t.push(a[1].substr(1,a[1].length-2));return t}e._extensions.push(s);var a=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.]|module\.)exports\s*(\[['"]|\.)|(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])module\.exports\s*[=,]/,r=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF."'])require\s*\(\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')\s*\)/g,n=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm;if("undefined"!=typeof location&&location.origin)var o=location.protocol+"//"+location.hostname+(location.port?":"+location.port:"");var i=e.instantiate;e.instantiate=function(n){return n.metadata.format||(a.lastIndex=0,r.lastIndex=0,(r.exec(n.source)||a.exec(n.source))&&(n.metadata.format="cjs")),"cjs"==n.metadata.format&&(n.metadata.deps=n.metadata.deps?n.metadata.deps.concat(t(n.source)):t(n.source),n.metadata.executingRequire=!0,n.metadata.execute=function(t,a,r){var i=(n.address||"").split("/");i.pop(),i=i.join("/");var s=n.address;o&&s.substr(0,o.length)===o?(s=s.substr(o.length),i=i.substr(o.length)):"file:"==s.substr(0,5)&&(s=s.substr(5),i=i.substr(5)),p._nodeRequire&&(i=i.substr(5));var l=(e.global._g={global:e.global,exports:a,module:r,require:t,__filename:s,__dirname:i},"(function(global, exports, module, require, __filename, __dirname) { "+n.source+"\n}).call(_g.exports, _g.global, _g.exports, _g.module, _g.require, _g.__filename, _g.__dirname);"),u=e.global.define;e.global.define=void 0,e.__exec({name:n.name,address:n.address,source:l}),e.global.define=u,e.global._g=void 0}),i.call(this,n)}}function l(e){function t(e,t){e=e.replace(c,"");var a=e.match(v),r=(a[1].split(",")[t]||"require").replace(g,""),n=b[r]||(b[r]=new RegExp(f+r+m,"g"));n.lastIndex=0;for(var o,i=[];o=n.exec(e);)i.push(o[2]||o[3]);return i}function a(e,t,r,n){var o=this;if("object"==typeof e&&!(e instanceof Array))return a.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if(!(e instanceof Array)){if("string"==typeof e){var i=o.get(e);return i.__useDefault?i["default"]:i}throw new TypeError("Invalid require")}for(var s=[],l=0;l<e.length;l++)s.push(o["import"](e[l],n));Promise.all(s).then(function(e){t&&t.apply(null,e)},r)}function r(e,t,r){return function(n,o,i){if("string"==typeof n){if("function"!=typeof o)return t(n);n=[n]}return a.call(r,n,o,i,{name:e})}}function n(e){function a(a,n,o){"string"!=typeof a&&(o=n,n=a,a=null),n instanceof Array||(o=n,n=["require","exports","module"]),"function"!=typeof o&&(o=function(e){return function(){return e}}(o)),void 0===n[n.length-1]&&n.pop();var s,l,u;if(-1!=(s=h.call(n,"require"))){n.splice(s,1);var d=o.toString();n=n.concat(t(d,s))}-1!=(l=h.call(n,"exports"))&&n.splice(l,1),-1!=(u=h.call(n,"module"))&&n.splice(u,1);var c={deps:n,execute:function(t,a,d){for(var c=[],f=0;f<n.length;f++)c.push(t(n[f]));d.uri=e.baseURL+d.id,d.config=function(){},-1!=u&&c.splice(u,0,d),-1!=l&&c.splice(l,0,a),-1!=s&&c.splice(s,0,r(d.id,t,e));var m=i.require;i.require=p.amdRequire;var h=o.apply(i,c);return i.require=m,"undefined"==typeof h&&d&&(h=d.exports),"undefined"!=typeof h?h:void 0}};if(a)y=0!=n.length||y||x?null:c,x=!0,e.register(a,c.deps,!1,c.execute);else{if(y)throw new TypeError("Multiple defines for anonymous module");y=c}}var n=e.onScriptLoad;e.onScriptLoad=function(e){n(e),(y||x)&&(e.metadata.format="defined",e.metadata.registered=!0),y&&(e.metadata.deps=e.metadata.deps?e.metadata.deps.concat(y.deps):y.deps,e.metadata.execute=y.execute)},a.amd={},e.amdDefine=a}function o(e){e.amdDefine||n(e),y=null,x=null;var t=e.global;_=t.module,w=t.exports,z=t.define,t.module=void 0,t.exports=void 0,t.define&&t.define===e.amdDefine||(t.define=e.amdDefine)}function s(e){var t=e.global;t.define=z,t.module=_,t.exports=w}var u="undefined"!=typeof module&&module.exports;e._extensions.push(l);var d=/(?:^\uFEFF?|[^$_a-zA-Z\xA0-\uFFFF.])define\s*\(\s*("[^"]+"\s*,\s*|'[^']+'\s*,\s*)?\s*(\[(\s*(("[^"]+"|'[^']+')\s*,|\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*(\s*("[^"]+"|'[^']+')\s*,?)?(\s*(\/\/.*\r?\n|\/\*(.|\s)*?\*\/))*\s*\]|function\s*|{|[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*\))/,c=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,f="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",m="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",v=/\(([^\)]*)\)/,g=/^\s+|\s+$/g,b={};e.amdRequire=function(){return a.apply(this,arguments)};var y,x,_,w,z;if(n(e),e.scriptLoader){var S=e.fetch;e.fetch=function(e){return o(this),S.call(this,e)}}var $=e.instantiate;e.instantiate=function(e){var t=this;if("amd"==e.metadata.format||!e.metadata.format&&e.source.match(d)){if(e.metadata.format="amd",t.execute!==!1&&(o(t),t.__exec(e),s(t),!y&&!x&&!u))throw new TypeError("AMD module "+e.name+" did not define");y&&(e.metadata.deps=e.metadata.deps?e.metadata.deps.concat(y.deps):y.deps,e.metadata.execute=y.execute)}return $.call(t,e)}}function u(e){function t(e,t){return e.length<t.length?!1:e.substr(0,t.length)!=t?!1:e[t.length]&&"/"!=e[t.length]?!1:!0}function a(e){for(var t=1,a=0,r=e.length;r>a;a++)"/"===e[a]&&t++;return t}function r(e,t,a){return a+e.substr(t)}function n(e,n,o){var i,s,l,u,d=0,c=0;if(n)for(var f in o.map){var m=o.map[f];if("object"==typeof m&&t(n,f)&&(l=a(f),!(c>=l)))for(var p in m)t(e,p)&&(u=a(p),d>=u||(i=p,d=u,s=f,c=l))}if(i)return r(e,i.length,o.map[s][i]);for(var f in o.map){var m=o.map[f];if("string"==typeof m&&t(e,f)){var u=a(f);d>=u||(i=f,d=u)}}return i?r(e,i.length,o.map[i]):e}e.map=e.map||{},e._extensions.push(u);var o=e.normalize;e.normalize=function(e,t,a){var r=this;r.map||(r.map={});var i=!1;return"/"==e.substr(e.length-1,1)&&(i=!0,e+="#"),Promise.resolve(o.call(r,e,t,a)).then(function(e){if(e=n(e,t,r),i){var a=e.split("/");a.pop();var o=a.pop();a.push(o),a.push(o),e=a.join("/")}return e})}}function d(e){"undefined"==typeof h&&(h=Array.prototype.indexOf),e._extensions.push(d);var t=e.normalize;e.normalize=function(e,a,r){var n,o=this;return a&&-1!=(n=a.indexOf("!"))&&(a=a.substr(0,n)),Promise.resolve(t.call(o,e,a,r)).then(function(e){var t=e.lastIndexOf("!");if(-1!=t){var n=e.substr(0,t),i=e.substr(t+1)||n.substr(n.lastIndexOf(".")+1);return new Promise(function(e){e(o.normalize(i,a,r))}).then(function(e){return i=e,o.normalize(n,a,r)}).then(function(e){return e+"!"+i})}return e})};var a=e.locate;e.locate=function(e){var t=this,r=e.name;if(this.defined&&this.defined[r])return a.call(this,e);var n=r.lastIndexOf("!");if(-1!=n){var o=r.substr(n+1);e.name=r.substr(0,n);var i=t.pluginLoader||t;return i["import"](o).then(function(){var a=i.get(o);return a=a["default"]||a,a.build===!1&&t.pluginLoader&&(e.metadata.build=!1),e.metadata.plugin=a,e.metadata.pluginName=o,e.metadata.pluginArgument=e.name,a.locate?a.locate.call(t,e):Promise.resolve(t.locate(e)).then(function(e){return e.replace(/\.js$/,"")})})}return a.call(this,e)};var r=e.fetch;e.fetch=function(e){var t=this;return e.metadata.build===!1&&t.pluginLoader?"":e.metadata.plugin&&e.metadata.plugin.fetch&&!e.metadata.pluginFetchCalled?(e.metadata.pluginFetchCalled=!0,e.metadata.plugin.fetch.call(t,e,r)):r.call(t,e)};var n=e.translate;e.translate=function(e){var t=this;return e.metadata.plugin&&e.metadata.plugin.translate?Promise.resolve(e.metadata.plugin.translate.call(t,e)).then(function(a){return"string"==typeof a&&(e.source=a),n.call(t,e)}):n.call(t,e)};var o=e.instantiate;e.instantiate=function(e){var t=this;return e.metadata.plugin&&e.metadata.plugin.instantiate?Promise.resolve(e.metadata.plugin.instantiate.call(t,e)).then(function(a){return e.metadata.format="defined",e.metadata.execute=function(){return a},o.call(t,e)}):e.metadata.plugin&&e.metadata.plugin.build===!1?(e.metadata.format="defined",e.metadata.deps.push(e.metadata.pluginName),e.metadata.execute=function(){return t.newModule({})},o.call(t,e)):o.call(t,e)}}function c(e){function t(e,t){return Promise.resolve(e.normalize(t)).then(function(r){return-1==h.call(a,r)&&(a.push(r),e.bundles[r]=e.bundles[r]||e.bundles[t],e.meta=e.meta||{},e.meta[r]=e.meta[r]||{},e.meta[r].bundle=!0),e.load(r)}).then(function(){return""})}"undefined"==typeof h&&(h=Array.prototype.indexOf),e._extensions.push(c),e.bundles=e.bundles||{};var a=[],r=e.fetch;e.fetch=function(e){var n=this;if(n.trace)return r.call(this,e);n.bundles||(n.bundles={});for(var o=0;o<a.length;o++)if(-1!=h.call(n.bundles[a[o]],e.name))return t(n,a[o]);for(var i in n.bundles)if(-1!=h.call(n.bundles[i],e.name))return t(n,i);return r.call(this,e)}}function f(e){function t(e){return parseInt(e,10)}function a(e){var a=e.match(s);return a?{major:t(a[1]),minor:t(a[2]),patch:t(a[3]),pre:a[4]&&a[4].split(".")}:{tag:e}}function r(e,a){if(e.tag&&a.tag)return 0;if(e.tag)return-1;if(a.tag)return 1;for(var r=0;r<u.length;r++){var n=u[r],o=e[n],i=a[n];if(o!=i)return isNaN(o)?-1:isNaN(i)?1:o>i?1:-1}if(!e.pre&&!a.pre)return 0;if(!e.pre)return 1;if(!a.pre)return-1;for(var r=0,s=Math.min(e.pre.length,a.pre.length);s>r;r++)if(e.pre[r]!=a.pre[r]){var d=e.pre[r].match(l),c=a.pre[r].match(l);return d&&!c?-1:c&&!d?1:d&&c?t(e.pre[r])>t(a.pre[r])?1:-1:e.pre[r]>a.pre[r]?1:-1}return e.pre.length==a.pre.length?0:e.pre.length>a.pre.length?1:-1}function n(e,t){var a=e.version;return a.tag?a.tag==t.tag:1==r(a,t)?!1:isNaN(t.minor)||isNaN(t.patch)?!1:t.pre?a.major!=t.major||a.minor!=t.minor||a.patch!=t.patch?!1:e.semver||e.fuzzy||a.pre.join(".")==t.pre.join("."):e.semver?0==a.major&&isNaN(a.minor)?t.major<1:a.major>=1?a.major==t.major:a.minor>=1?a.minor==t.minor:(a.patch||0)==t.patch:e.fuzzy?t.major==a.major&&t.minor<(a.minor||0)+1:!a.pre&&a.major==t.major&&a.minor==t.minor&&a.patch==t.patch}function o(e){var t={};((t.semver="^"==e.substr(0,1))||(t.fuzzy="~"==e.substr(0,1)))&&(e=e.substr(1));var r=t.version=a(e);return r.tag?t:(t.fuzzy||t.semver||!isNaN(r.minor)&&!isNaN(r.patch)||(t.fuzzy=!0),t.fuzzy&&isNaN(r.minor)&&(t.semver=!0,t.fuzzy=!1),t.semver&&!isNaN(r.minor)&&isNaN(r.patch)&&(t.semver=!1,t.fuzzy=!0),t)}function i(e,t){return r(a(e),a(t))}"undefined"==typeof h&&(h=Array.prototype.indexOf),e._extensions.push(f);var s=/^(\d+)(?:\.(\d+)(?:\.(\d+)(?:-([\da-z-]+(?:\.[\da-z-]+)*)(?:\+([\da-z-]+(?:\.[\da-z-]+)*))?)?)?)?$/i,l=/^\d+$/,u=["major","minor","patch"];e.versions=e.versions||{};var d=e.normalize;e.normalize=function(e,t,r){this.versions||(this.versions={});var s,l,u=this.versions,c=-1!=e.indexOf("!")?0:e.lastIndexOf("@");if(c>0){var f=e.substr(c+1,e.length-c-1).split("/");s=f[0],l=f.length,e=e.substr(0,c)+e.substr(c+s.length+1,e.length-c-s.length-1)}return Promise.resolve(d.call(this,e,t,r)).then(function(e){var t=-1!=e.indexOf("!")?0:e.indexOf("@");if(s&&(-1==t||0==t)){var r=e.split("/");r[r.length-l]+="@"+s,e=r.join("/"),t=e.indexOf("@")}var d,c;if(-1==t||0==t){for(var f in u)if(c=u[f],e.substr(0,f.length)==f&&(d=e.substr(f.length,1),!d||"/"==d))return f+"@"+("string"==typeof c?c:c[c.length-1])+e.substr(f.length);return e}var m=e.substr(0,t),p=e.substr(t+1).split("/")[0],h=p.length,v=o(e.substr(t+1).split("/")[0]);c=u[e.substr(0,t)]||[],"string"==typeof c&&(c=[c]);for(var g=c.length-1;g>=0;g--)if(n(v,a(c[g])))return m+"@"+c[g]+e.substr(t+h+1);var b;return v.semver?b=0!=v.version.major||isNaN(v.version.minor)?v.version.major:"0."+v.version.minor:v.fuzzy?b=v.version.major+"."+v.version.minor:(b=p,c.push(p),c.sort(i),u[m]=1==c.length?c[0]:c),m+"@"+b+e.substr(t+h+1)})}}function m(e){e.depCache=e.depCache||{},e._extensions.push(m);var t=e.locate;e.locate=function(e){var a=this;a.depCache||(a.depCache={});var r=a.depCache[e.name];if(r)for(var n=0;n<r.length;n++)a.load(r[n]);return t.call(a,e)}}$__global.upgradeSystemLoader=void 0;var p,h=Array.prototype.indexOf||function(e){for(var t=0,a=this.length;a>t;t++)if(this[t]===e)return t;return-1},v="undefined"!=typeof process&&!!process.platform.match(/^win/);!function(){var e=$__global.System;p=$__global.System=new LoaderPolyfill(e),p.baseURL=e.baseURL,p.paths={"*":"*.js"},p.originalSystem=e}(),p.noConflict=function(){$__global.SystemJS=p,$__global.System=p.originalSystem};var g=$__global.System.originalSystem;a(p),r(p),n(p),o(p),i(p),s(p),l(p),u(p),d(p),c(p),f(p),m(p)};var $__curScript,__eval;!function(){var doEval;if(__eval=function(e,t,a){e+="\n//# sourceURL="+t+(a?"\n//# sourceMappingURL="+a:"");try{doEval(e)}catch(r){var n="Error evaluating "+t+"\n";throw r instanceof Error?r.message=n+r.message:r=n+r,r}},"undefined"!=typeof document){var head,scripts=document.getElementsByTagName("script");if($__curScript=scripts[scripts.length-1],doEval=function(e){head||(head=document.head||document.body||document.documentElement);var t=document.createElement("script");t.text=e;var a,r=window.onerror;if(window.onerror=function(e){a=e},head.appendChild(t),head.removeChild(t),window.onerror=r,a)throw a},$__global.System&&$__global.LoaderPolyfill)$__global.upgradeSystemLoader();else{var curPath=$__curScript.src,basePath=curPath.substr(0,curPath.lastIndexOf("/")+1);document.write('<script type="text/javascript" src="'+basePath+'es6-module-loader.js" data-init="upgradeSystemLoader"></script>')}}else if("undefined"!=typeof importScripts)if(doEval=function(source){try{eval(source)}catch(e){throw e}},$__global.System&&$__global.LoaderPolyfill)$__global.upgradeSystemLoader();else{var basePath="";try{throw new Error("Get worker base path via error stack")}catch(e){e.stack.replace(/(?:at|@).*(http.+):[\d]+:[\d]+/,function(e,t){basePath=t.replace(/\/[^\/]*$/,"/")})}importScripts(basePath+"es6-module-loader.js"),$__global.upgradeSystemLoader()}else{var es6ModuleLoader=require("es6-module-loader");$__global.System=es6ModuleLoader.System,$__global.Loader=es6ModuleLoader.Loader,$__global.upgradeSystemLoader(),module.exports=$__global.System;var vm=require("vm");doEval=function(e){vm.runInThisContext(e)}}}()}("undefined"!=typeof window?window:"undefined"!=typeof global?global:self,"undefined"!=typeof window?"window":"undefined"!=typeof global?"global":"self");
//# sourceMappingURL=system.js.map
/**
 @license
Copyright 2014-2015 Google, Inc. http://angularjs.org

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

 */

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

var core = require('../core');
var microtask = require('../microtask');
var browserPatch = require('../patch/browser');
var es6Promise = require('es6-promise');

if (global.Zone) {
  console.warn('Zone already exported on window the object!');
}

global.Zone = microtask.addMicrotaskSupport(core.Zone);
global.zone = new global.Zone();

// Monkey path he Promise implementation to add support for microtasks
global.Promise = es6Promise.Promise;

browserPatch.apply();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../core":2,"../microtask":3,"../patch/browser":4,"es6-promise":15}],2:[function(require,module,exports){
(function (global){
'use strict';

function Zone(parentZone, data) {
  var zone = (arguments.length) ? Object.create(parentZone) : this;

  zone.parent = parentZone || null;

  Object.keys(data || {}).forEach(function(property) {

    var _property = property.substr(1);

    // augment the new zone with a hook decorates the parent's hook
    if (property[0] === '$') {
      zone[_property] = data[property](parentZone[_property] || function () {});

    // augment the new zone with a hook that runs after the parent's hook
    } else if (property[0] === '+') {
      if (parentZone[_property]) {
        zone[_property] = function () {
          var result = parentZone[_property].apply(this, arguments);
          data[property].apply(this, arguments);
          return result;
        };
      } else {
        zone[_property] = data[property];
      }

    // augment the new zone with a hook that runs before the parent's hook
    } else if (property[0] === '-') {
      if (parentZone[_property]) {
        zone[_property] = function () {
          data[property].apply(this, arguments);
          return parentZone[_property].apply(this, arguments);
        };
      } else {
        zone[_property] = data[property];
      }

    // set the new zone's hook (replacing the parent zone's)
    } else {
      zone[property] = (typeof data[property] === 'object') ?
                        JSON.parse(JSON.stringify(data[property])) :
                        data[property];
    }
  });

  zone.$id = Zone.nextId++;

  return zone;
}

Zone.prototype = {
  constructor: Zone,

  fork: function (locals) {
    this.onZoneCreated();
    return new Zone(this, locals);
  },

  bind: function (fn, skipEnqueue) {
    if (typeof fn !== 'function') {
      throw new Error('Expecting function got: ' + fn);
    }
    skipEnqueue || this.enqueueTask(fn);
    var zone = this.isRootZone() ? this : this.fork();
    return function zoneBoundFn() {
      return zone.run(fn, this, arguments);
    };
  },

  bindOnce: function (fn) {
    var boundZone = this;
    return this.bind(function () {
      var result = fn.apply(this, arguments);
      boundZone.dequeueTask(fn);
      return result;
    });
  },

  isRootZone: function() {
    return this.parent === null;
  },

  run: function run (fn, applyTo, applyWith) {
    applyWith = applyWith || [];

    var oldZone = global.zone;

    // MAKE THIS ZONE THE CURRENT ZONE
    global.zone = this;

    try {
      this.beforeTask();
      return fn.apply(applyTo, applyWith);
    } catch (e) {
      if (this.onError) {
        this.onError(e);
      } else {
        throw e;
      }
    } finally {
      this.afterTask();
      // REVERT THE CURRENT ZONE BACK TO THE ORIGINAL ZONE
      global.zone = oldZone;
    }
  },

  // onError is used to override error handling.
  // When a custom error handler is provided, it should most probably rethrow the exception
  // not to break the expected control flow:
  //
  // `promise.then(fnThatThrows).catch(fn);`
  //
  // When this code is executed in a zone with a custom onError handler that doesn't rethrow, the
  // `.catch()` branch will not be taken as the `fnThatThrows` exception will be swallowed by the
  // handler.
  onError: null,
  beforeTask: function () {},
  onZoneCreated: function () {},
  afterTask: function () {},
  enqueueTask: function () {},
  dequeueTask: function () {}
};

// Root zone ID === 1
Zone.nextId = 1;

Zone.bindPromiseFn = require('./patch/promise').bindPromiseFn;

module.exports = {
  Zone: Zone
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./patch/promise":10}],3:[function(require,module,exports){
(function (global){
'use strict';

var es6Promise = require('es6-promise').Promise;

// es6-promise asap should schedule microtasks via zone.scheduleMicrotask so that any
// user defined hooks are triggered
es6Promise._setAsap(function(fn, arg) {
  global.zone.scheduleMicrotask(function() {
    fn(arg);
  });
});

// The default implementation of scheduleMicrotask use the original es6-promise implementation
// to schedule a microtask
function scheduleMicrotask(fn) {
  es6Promise._asap(this.bind(fn));
}

function addMicrotaskSupport(zoneClass) {
  zoneClass.prototype.scheduleMicrotask = scheduleMicrotask;
  return zoneClass;
}

module.exports = {
  addMicrotaskSupport: addMicrotaskSupport
};

// TODO(vicb): Create a benchmark for the different methods & the usage of the queue
// see https://github.com/angular/zone.js/issues/97

var hasNativePromise = typeof Promise !== "undefined" &&
                       Promise.toString().indexOf("[native code]") !== -1;

var isFirefox = global.navigator &&
                global.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

// TODO(vicb): remove '!isFirefox' when the bug gets fixed:
// https://bugzilla.mozilla.org/show_bug.cgi?id=1162013
if (hasNativePromise && !isFirefox) {
  // When available use a native Promise to schedule microtasks.
  // When not available, es6-promise fallback will be used
  var resolvedPromise = Promise.resolve();
  es6Promise._setScheduler(function(fn) {
    resolvedPromise.then(fn);
  });
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"es6-promise":15}],4:[function(require,module,exports){
(function (global){
'use strict';

var fnPatch = require('./functions');
var promisePatch = require('./promise');
var mutationObserverPatch = require('./mutation-observer');
var definePropertyPatch = require('./define-property');
var registerElementPatch = require('./register-element');
var webSocketPatch = require('./websocket');
var eventTargetPatch = require('./event-target');
var propertyDescriptorPatch = require('./property-descriptor');
var geolocationPatch = require('./geolocation');

function apply() {
  fnPatch.patchSetClearFunction(global, [
    'timeout',
    'interval',
    'immediate'
  ]);

  fnPatch.patchSetFunction(global, [
    'requestAnimationFrame',
    'mozRequestAnimationFrame',
    'webkitRequestAnimationFrame'
  ]);

  fnPatch.patchFunction(global, [
    'alert',
    'prompt'
  ]);

  eventTargetPatch.apply();

  propertyDescriptorPatch.apply();

  promisePatch.apply();

  mutationObserverPatch.patchClass('MutationObserver');
  mutationObserverPatch.patchClass('WebKitMutationObserver');

  definePropertyPatch.apply();

  registerElementPatch.apply();

  geolocationPatch.apply();
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./define-property":5,"./event-target":6,"./functions":7,"./geolocation":8,"./mutation-observer":9,"./promise":10,"./property-descriptor":11,"./register-element":12,"./websocket":13}],5:[function(require,module,exports){
'use strict';

// might need similar for object.freeze
// i regret nothing

var _defineProperty = Object.defineProperty;
var _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var _create = Object.create;

function apply() {
  Object.defineProperty = function (obj, prop, desc) {
    if (isUnconfigurable(obj, prop)) {
      throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
    }
    if (prop !== 'prototype') {
      desc = rewriteDescriptor(obj, prop, desc);
    }
    return _defineProperty(obj, prop, desc);
  };

  Object.defineProperties = function (obj, props) {
    Object.keys(props).forEach(function (prop) {
      Object.defineProperty(obj, prop, props[prop]);
    });
    return obj;
  };

  Object.create = function (obj, proto) {
    if (typeof proto === 'object') {
      Object.keys(proto).forEach(function (prop) {
        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
      });
    }
    return _create(obj, proto);
  };

  Object.getOwnPropertyDescriptor = function (obj, prop) {
    var desc = _getOwnPropertyDescriptor(obj, prop);
    if (isUnconfigurable(obj, prop)) {
      desc.configurable = false;
    }
    return desc;
  };
};

function _redefineProperty(obj, prop, desc) {
  desc = rewriteDescriptor(obj, prop, desc);
  return _defineProperty(obj, prop, desc);
};

function isUnconfigurable (obj, prop) {
  return obj && obj.__unconfigurables && obj.__unconfigurables[prop];
}

function rewriteDescriptor (obj, prop, desc) {
  desc.configurable = true;
  if (!desc.configurable) {
    if (!obj.__unconfigurables) {
      _defineProperty(obj, '__unconfigurables', { writable: true, value: {} });
    }
    obj.__unconfigurables[prop] = true;
  }
  return desc;
}

module.exports = {
  apply: apply,
  _redefineProperty: _redefineProperty
};



},{}],6:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function apply() {
  // patched properties depend on addEventListener, so this needs to come first
  if (global.EventTarget) {
    utils.patchEventTargetMethods(global.EventTarget.prototype);

  // Note: EventTarget is not available in all browsers,
  // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
  } else {
    var apis = [ 'ApplicationCache',
      'EventSource',
      'FileReader',
      'InputMethodContext',
      'MediaController',
      'MessagePort',
      'Node',
      'Performance',
      'SVGElementInstance',
      'SharedWorker',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebKitNamedFlow',
      'Window',
      'Worker',
      'WorkerGlobalScope',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload'
    ];

    apis.forEach(function(thing) {
      global[thing] && utils.patchEventTargetMethods(global[thing].prototype);
    });
  }
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],7:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function patchSetClearFunction(obj, fnNames) {
  fnNames.map(function (name) {
    return name[0].toUpperCase() + name.substr(1);
  }).forEach(function (name) {
    var setName = 'set' + name;
    var delegate = obj[setName];

    if (delegate) {
      var clearName = 'clear' + name;
      var ids = {};

      var bindArgs = setName === 'setInterval' ? utils.bindArguments : utils.bindArgumentsOnce;

      global.zone[setName] = function (fn) {
        var id, fnRef = fn;
        arguments[0] = function () {
          delete ids[id];
          return fnRef.apply(this, arguments);
        };
        var args = bindArgs(arguments);
        id = delegate.apply(obj, args);
        ids[id] = true;
        return id;
      };

      obj[setName] = function () {
        return global.zone[setName].apply(this, arguments);
      };

      var clearDelegate = obj[clearName];

      global.zone[clearName] = function (id) {
        if (ids[id]) {
          delete ids[id];
          global.zone.dequeueTask();
        }
        return clearDelegate.apply(this, arguments);
      };

      obj[clearName] = function () {
        return global.zone[clearName].apply(this, arguments);
      };
    }
  });
};

function patchSetFunction(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];

    if (delegate) {
      global.zone[name] = function (fn) {
        var fnRef = fn;
        arguments[0] = function () {
          return fnRef.apply(this, arguments);
        };
        var args = utils.bindArgumentsOnce(arguments);
        return delegate.apply(obj, args);
      };

      obj[name] = function () {
        return zone[name].apply(this, arguments);
      };
    }
  });
};

function patchFunction(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];
    global.zone[name] = function () {
      return delegate.apply(obj, arguments);
    };

    obj[name] = function () {
      return global.zone[name].apply(this, arguments);
    };
  });
};


module.exports = {
  patchSetClearFunction: patchSetClearFunction,
  patchSetFunction: patchSetFunction,
  patchFunction: patchFunction
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],8:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

function apply() {
  if (global.navigator && global.navigator.geolocation) {
    utils.patchPrototype(global.navigator.geolocation, [
      'getCurrentPosition',
      'watchPosition'
    ]);
  }
}

module.exports = {
  apply: apply
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],9:[function(require,module,exports){
(function (global){
'use strict';

// wrap some native API on `window`
function patchClass(className) {
  var OriginalClass = global[className];
  if (!OriginalClass) return;

  global[className] = function (fn) {
    this._o = new OriginalClass(global.zone.bind(fn, true));
    // Remember where the class was instantiate to execute the enqueueTask and dequeueTask hooks
    this._creationZone = global.zone;
  };

  var instance = new OriginalClass(function () {});

  global[className].prototype.disconnect = function () {
    var result = this._o.disconnect.apply(this._o, arguments);
    if (this._active) {
      this._creationZone.dequeueTask();
      this._active = false;
    }
    return result;
  };

  global[className].prototype.observe = function () {
    if (!this._active) {
      this._creationZone.enqueueTask();
      this._active = true;
    }
    return this._o.observe.apply(this._o, arguments);
  };

  var prop;
  for (prop in instance) {
    (function (prop) {
      if (typeof global[className].prototype !== undefined) {
        return;
      }
      if (typeof instance[prop] === 'function') {
        global[className].prototype[prop] = function () {
          return this._o[prop].apply(this._o, arguments);
        };
      } else {
        Object.defineProperty(global[className].prototype, prop, {
          set: function (fn) {
            if (typeof fn === 'function') {
              this._o[prop] = global.zone.bind(fn);
            } else {
              this._o[prop] = fn;
            }
          },
          get: function () {
            return this._o[prop];
          }
        });
      }
    }(prop));
  }
};

module.exports = {
  patchClass: patchClass
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

/*
 * Patches a function that returns a Promise-like instance.
 *
 * This function must be used when either:
 * - Native Promises are not available,
 * - The function returns a Promise-like object.
 *
 * This is required because zones rely on a Promise monkey patch that could not be applied when
 * Promise is not natively available or when the returned object is not an instance of Promise.
 *
 * Note that calling `bindPromiseFn` on a function that returns a native Promise will also work
 * with minimal overhead.
 *
 * ```
 * var boundFunction = bindPromiseFn(FunctionReturningAPromise);
 *
 * boundFunction.then(successHandler, errorHandler);
 * ```
 */
var bindPromiseFn;

if (global.Promise) {
  bindPromiseFn = function (delegate) {
    return function() {
      var delegatePromise = delegate.apply(this, arguments);

      // if the delegate returned an instance of Promise, forward it.
      if (delegatePromise instanceof Promise) {
        return delegatePromise;
      }

      // Otherwise wrap the Promise-like in a global Promise
      return new Promise(function(resolve, reject) {
        delegatePromise.then(resolve, reject);
      });
    };
  };
} else {
  bindPromiseFn = function (delegate) {
    return function () {
      return _patchThenable(delegate.apply(this, arguments));
    };
  };
}


function _patchPromiseFnsOnObject(objectPath, fnNames) {
  var obj = global;

  var exists = objectPath.every(function (segment) {
    obj = obj[segment];
    return obj;
  });

  if (!exists) {
    return;
  }

  fnNames.forEach(function (name) {
    var fn = obj[name];
    if (fn) {
      obj[name] = bindPromiseFn(fn);
    }
  });
}

function _patchThenable(thenable) {
  var then = thenable.then;
  thenable.then = function () {
    var args = utils.bindArguments(arguments);
    var nextThenable = then.apply(thenable, args);
    return _patchThenable(nextThenable);
  };

  var ocatch = thenable.catch;
  thenable.catch = function () {
    var args = utils.bindArguments(arguments);
    var nextThenable = ocatch.apply(thenable, args);
    return _patchThenable(nextThenable);
  };

  return thenable;
}


function apply() {
  // Patch .then() and .catch() on native Promises to execute callbacks in the zone where
  // those functions are called.
  if (global.Promise) {
    utils.patchPrototype(Promise.prototype, [
      'then',
      'catch'
    ]);

    // Patch browser APIs that return a Promise
    var patchFns = [
      // fetch
      [[], ['fetch']],
      [['Response', 'prototype'], ['arrayBuffer', 'blob', 'json', 'text']]
    ];

    patchFns.forEach(function(objPathAndFns) {
      _patchPromiseFnsOnObject(objPathAndFns[0], objPathAndFns[1]);
    });
  }
}

module.exports = {
  apply: apply,
  bindPromiseFn: bindPromiseFn
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],11:[function(require,module,exports){
(function (global){
'use strict';

var webSocketPatch = require('./websocket');
var utils = require('../utils');

var eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');

function apply() {
  if (canPatchViaPropertyDescriptor()) {
    // for browsers that we can patch the descriptor:  Chrome & Firefox
    var onEventNames = eventNames.map(function (property) {
      return 'on' + property;
    });
    utils.patchProperties(HTMLElement.prototype, onEventNames);
    utils.patchProperties(XMLHttpRequest.prototype);
    if (typeof WebSocket !== 'undefined') {
      utils.patchProperties(WebSocket.prototype);
    }
  } else {
    // Safari
    patchViaCapturingAllTheEvents();
    utils.patchClass('XMLHttpRequest');
    webSocketPatch.apply();
  }
}

function canPatchViaPropertyDescriptor() {
  if (!Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
    // IDL interface attributes are not configurable
    var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
    if (desc && !desc.configurable) return false;
  }

  Object.defineProperty(HTMLElement.prototype, 'onclick', {
    get: function () {
      return true;
    }
  });
  var elt = document.createElement('div');
  var result = !!elt.onclick;
  Object.defineProperty(HTMLElement.prototype, 'onclick', {});
  return result;
};

// Whenever any event fires, we check the event target and all parents
// for `onwhatever` properties and replace them with zone-bound functions
// - Chrome (for now)
function patchViaCapturingAllTheEvents() {
  eventNames.forEach(function (property) {
    var onproperty = 'on' + property;
    document.addEventListener(property, function (event) {
      var elt = event.target, bound;
      while (elt) {
        if (elt[onproperty] && !elt[onproperty]._unbound) {
          bound = global.zone.bind(elt[onproperty]);
          bound._unbound = elt[onproperty];
          elt[onproperty] = bound;
        }
        elt = elt.parentElement;
      }
    }, true);
  });
};

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14,"./websocket":13}],12:[function(require,module,exports){
(function (global){
'use strict';

var _redefineProperty = require('./define-property')._redefineProperty;

function apply() {
  if (!('registerElement' in global.document)) {
    return;
  }

  var _registerElement = document.registerElement;
  var callbacks = [
    'createdCallback',
    'attachedCallback',
    'detachedCallback',
    'attributeChangedCallback'
  ];

  document.registerElement = function (name, opts) {
    if (opts && opts.prototype) {
      callbacks.forEach(function (callback) {
        if (opts.prototype.hasOwnProperty(callback)) {
          var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
          if (descriptor.value) {
            descriptor.value = global.zone.bind(descriptor.value);
            _redefineProperty(opts.prototype, callback, descriptor);
          } else {
            opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
          }
        } else if (opts.prototype[callback]) {
          opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
        }
      });
    }

    return _registerElement.apply(document, [name, opts]);
  };
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./define-property":5}],13:[function(require,module,exports){
(function (global){
'use strict';

var utils = require('../utils');

// we have to patch the instance since the proto is non-configurable
function apply() {
  var WS = global.WebSocket;
  utils.patchEventTargetMethods(WS.prototype);
  global.WebSocket = function(a, b) {
    var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
    var proxySocket;

    // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
    var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
    if (onmessageDesc && onmessageDesc.configurable === false) {
      proxySocket = Object.create(socket);
      ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {
        proxySocket[propName] = function() {
          return socket[propName].apply(socket, arguments);
        };
      });
    } else {
      // we can patch the real socket
      proxySocket = socket;
    }

    utils.patchProperties(proxySocket, ['onclose', 'onerror', 'onmessage', 'onopen']);

    return proxySocket;
  };
}

module.exports = {
  apply: apply
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils":14}],14:[function(require,module,exports){
(function (global){
'use strict';

function bindArguments(args) {
  for (var i = args.length - 1; i >= 0; i--) {
    if (typeof args[i] === 'function') {
      args[i] = global.zone.bind(args[i]);
    }
  }
  return args;
};

function bindArgumentsOnce(args) {
  for (var i = args.length - 1; i >= 0; i--) {
    if (typeof args[i] === 'function') {
      args[i] = global.zone.bindOnce(args[i]);
    }
  }
  return args;
};

function patchPrototype(obj, fnNames) {
  fnNames.forEach(function (name) {
    var delegate = obj[name];
    if (delegate) {
      obj[name] = function () {
        return delegate.apply(this, bindArguments(arguments));
      };
    }
  });
};

function patchProperty(obj, prop) {
  var desc = Object.getOwnPropertyDescriptor(obj, prop) || {
    enumerable: true,
    configurable: true
  };

  // A property descriptor cannot have getter/setter and be writable
  // deleting the writable and value properties avoids this error:
  //
  // TypeError: property descriptors must not specify a value or be writable when a
  // getter or setter has been specified
  delete desc.writable;
  delete desc.value;

  // substr(2) cuz 'onclick' -> 'click', etc
  var eventName = prop.substr(2);
  var _prop = '_' + prop;

  desc.set = function (fn) {
    if (this[_prop]) {
      this.removeEventListener(eventName, this[_prop]);
    }

    if (typeof fn === 'function') {
      this[_prop] = fn;
      this.addEventListener(eventName, fn, false);
    } else {
      this[_prop] = null;
    }
  };

  desc.get = function () {
    return this[_prop];
  };

  Object.defineProperty(obj, prop, desc);
};

function patchProperties(obj, properties) {

  (properties || (function () {
      var props = [];
      for (var prop in obj) {
        props.push(prop);
      }
      return props;
    }()).
    filter(function (propertyName) {
      return propertyName.substr(0,2) === 'on';
    })).
    forEach(function (eventName) {
      patchProperty(obj, eventName);
    });
};

function patchEventTargetMethods(obj) {
  var addDelegate = obj.addEventListener;
  obj.addEventListener = function (eventName, fn) {
    fn._bound = fn._bound || {};
    arguments[1] = fn._bound[eventName] = zone.bind(fn);
    return addDelegate.apply(this, arguments);
  };

  var removeDelegate = obj.removeEventListener;
  obj.removeEventListener = function (eventName, fn) {
    if(arguments[1]._bound && arguments[1]._bound[eventName]) {
      var _bound = arguments[1]._bound;
      arguments[1] = _bound[eventName];
      delete _bound[eventName];
    }
    var result = removeDelegate.apply(this, arguments);
    global.zone.dequeueTask(fn);
    return result;
  };
};

// wrap some native API on `window`
function patchClass(className) {
  var OriginalClass = global[className];
  if (!OriginalClass) return;

  global[className] = function () {
    var a = bindArguments(arguments);
    switch (a.length) {
      case 0: this._o = new OriginalClass(); break;
      case 1: this._o = new OriginalClass(a[0]); break;
      case 2: this._o = new OriginalClass(a[0], a[1]); break;
      case 3: this._o = new OriginalClass(a[0], a[1], a[2]); break;
      case 4: this._o = new OriginalClass(a[0], a[1], a[2], a[3]); break;
      default: throw new Error('what are you even doing?');
    }
  };

  var instance = new OriginalClass();

  var prop;
  for (prop in instance) {
    (function (prop) {
      if (typeof instance[prop] === 'function') {
        global[className].prototype[prop] = function () {
          return this._o[prop].apply(this._o, arguments);
        };
      } else {
        Object.defineProperty(global[className].prototype, prop, {
          set: function (fn) {
            if (typeof fn === 'function') {
              this._o[prop] = global.zone.bind(fn);
            } else {
              this._o[prop] = fn;
            }
          },
          get: function () {
            return this._o[prop];
          }
        });
      }
    }(prop));
  }

  for (prop in OriginalClass) {
    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
      global[className][prop] = OriginalClass[prop];
    }
  }
};

module.exports = {
  bindArguments: bindArguments,
  bindArgumentsOnce: bindArgumentsOnce,
  patchPrototype: patchPrototype,
  patchProperty: patchProperty,
  patchProperties: patchProperties,
  patchEventTargetMethods: patchEventTargetMethods,
  patchClass: patchClass
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],15:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.3.0
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFullfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,{},typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
'use strict';

if (!global.Zone) {
  throw new Error('zone.js should be installed before loading the long stack trace zone');
}

global.Zone.longStackTraceZone = require('../zones/long-stack-trace.js');

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../zones/long-stack-trace.js":2}],2:[function(require,module,exports){
(function (global){
/*
 * Wrapped stacktrace
 *
 * We need this because in some implementations, constructing a trace is slow
 * and so we want to defer accessing the trace for as long as possible
 */

'use strict';

function _Stacktrace(e) {
  this._e = e;
};

_Stacktrace.prototype.get = function () {
  if (global.zone.stackFramesFilter && this._e.stack) {
    return this._e.stack
      .split('\n')
      .filter(global.zone.stackFramesFilter)
      .join('\n');
  }

  return this._e.stack;
}

function _getStacktraceWithUncaughtError () {
  return new _Stacktrace(new Error());
}

function _getStacktraceWithCaughtError () {
  try {
    throw new Error();
  } catch (e) {
    return new _Stacktrace(e);
  }
}

// Some implementations of exception handling don't create a stack trace if the exception
// isn't thrown, however it's faster not to actually throw the exception.
var stack = _getStacktraceWithUncaughtError();

var _getStacktrace = stack && stack._e.stack
  ? _getStacktraceWithUncaughtError
  : _getStacktraceWithCaughtError;

module.exports = {
  getLongStacktrace: function (exception) {
    var traces = [];
    var currentZone = this;
    if (exception) {
      if (currentZone.stackFramesFilter && exception.stack) {
        traces.push(exception.stack.split('\n')
              .filter(currentZone.stackFramesFilter)
              .join('\n'));
      } else {
        traces.push(exception.stack);
      }
    }
    var now = Date.now();

    while (currentZone && currentZone.constructedAtException) {
      traces.push(
          '--- ' + (Date(currentZone.constructedAtTime)).toString() +
          ' - ' + (now - currentZone.constructedAtTime) + 'ms ago',
          currentZone.constructedAtException.get());
      currentZone = currentZone.parent;
    }

    return traces.join('\n');
  },

  stackFramesFilter: function (line) {
    return /zone(-microtask)?(\.min)?\.js/.test(line);
  },

  onError: function (exception) {
    var reporter = this.reporter || console.log.bind(console);
    reporter(exception.toString());
    reporter(this.getLongStacktrace(exception));
  },

  '$fork': function (parentFork) {
    return function() {
      var newZone = parentFork.apply(this, arguments);
      newZone.constructedAtException = _getStacktrace();
      newZone.constructedAtTime = Date.now();
      return newZone;
    }
  }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);

/**
 @license
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


 */

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

See the License for the specific language governing permissions and
limitations under the License.
***************************************************************************** */
"use strict";
var Reflect;
(function (Reflect) {
    // Load global or shim versions of Map, Set, and WeakMap
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    // [[Metadata]] internal slot
    var __Metadata__ = new _WeakMap();
    /**
      * Applies a set of decorators to a property of a target object.
      * @param decorators An array of decorators.
      * @param target The target object.
      * @param targetKey (Optional) The property key to decorate.
      * @param targetDescriptor (Optional) The property descriptor for the target key
      * @remarks Decorators are applied in reverse order.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     C = Reflect.decorate(decoratorsArray, C);
      *
      *     // property (on constructor)
      *     Reflect.decorate(decoratorsArray, C, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.decorate(decoratorsArray, C.prototype, "property");
      *
      *     // method (on constructor)
      *     Object.defineProperty(C, "staticMethod",
      *         Reflect.decorate(decoratorsArray, C, "staticMethod",
      *             Object.getOwnPropertyDescriptor(C, "staticMethod")));
      *
      *     // method (on prototype)
      *     Object.defineProperty(C.prototype, "method",
      *         Reflect.decorate(decoratorsArray, C.prototype, "method",
      *             Object.getOwnPropertyDescriptor(C.prototype, "method")));
      *
      */
    function decorate(decorators, target, targetKey, targetDescriptor) {
        if (!IsUndefined(targetDescriptor)) {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsObject(target)) {
                throw new TypeError();
            }
            else if (IsUndefined(targetKey)) {
                throw new TypeError();
            }
            else if (!IsObject(targetDescriptor)) {
                throw new TypeError();
            }
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
        }
        else if (!IsUndefined(targetKey)) {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsObject(target)) {
                throw new TypeError();
            }
            targetKey = ToPropertyKey(targetKey);
            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
        }
        else {
            if (!IsArray(decorators)) {
                throw new TypeError();
            }
            else if (!IsConstructor(target)) {
                throw new TypeError();
            }
            return DecorateConstructor(decorators, target);
        }
    }
    Reflect.decorate = decorate;
    /**
      * A default metadata decorator factory that can be used on a class, class member, or parameter.
      * @param metadataKey The key for the metadata entry.
      * @param metadataValue The value for the metadata entry.
      * @returns A decorator function.
      * @remarks
      * If `metadataKey` is already defined for the target and target key, the
      * metadataValue for that key will be overwritten.
      * @example
      *
      *     // constructor
      *     @Reflect.metadata(key, value)
      *     class C {
      *     }
      *
      *     // property (on constructor, TypeScript only)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         static staticProperty;
      *     }
      *
      *     // property (on prototype, TypeScript only)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         property;
      *     }
      *
      *     // method (on constructor)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         static staticMethod() { }
      *     }
      *
      *     // method (on prototype)
      *     class C {
      *         @Reflect.metadata(key, value)
      *         method() { }
      *     }
      *
      */
    function metadata(metadataKey, metadataValue) {
        function decorator(target, targetKey) {
            if (!IsUndefined(targetKey)) {
                if (!IsObject(target)) {
                    throw new TypeError();
                }
                targetKey = ToPropertyKey(targetKey);
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
            }
            else {
                if (!IsConstructor(target)) {
                    throw new TypeError();
                }
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);
            }
        }
        return decorator;
    }
    Reflect.metadata = metadata;
    /**
      * Define a unique metadata entry on the target.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param metadataValue A value that contains attached metadata.
      * @param target The target object on which to define metadata.
      * @param targetKey (Optional) The property key for the target.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     Reflect.defineMetadata("custom:annotation", options, C);
      *
      *     // property (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, C, "staticProperty");
      *
      *     // property (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "property");
      *
      *     // method (on constructor)
      *     Reflect.defineMetadata("custom:annotation", options, C, "staticMethod");
      *
      *     // method (on prototype)
      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "method");
      *
      *     // decorator factory as metadata-producing annotation.
      *     function MyAnnotation(options): Decorator {
      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
      *     }
      *
      */
    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
    }
    Reflect.defineMetadata = defineMetadata;
    /**
      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function hasMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryHasMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasMetadata = hasMetadata;
    /**
      * Gets a value indicating whether the target object has the provided metadata key defined.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.hasOwnMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function hasOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.hasOwnMetadata = hasOwnMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function getMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryGetMetadata(metadataKey, target, targetKey);
    }
    Reflect.getMetadata = getMetadata;
    /**
      * Gets the metadata value for the provided metadata key on the target object.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function getOwnMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
    }
    Reflect.getOwnMetadata = getOwnMetadata;
    /**
      * Gets the metadata keys defined on the target object or its prototype chain.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getMetadataKeys(C);
      *
      *     // property (on constructor)
      *     result = Reflect.getMetadataKeys(C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getMetadataKeys(C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getMetadataKeys(C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getMetadataKeys(C.prototype, "method");
      *
      */
    function getMetadataKeys(target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryMetadataKeys(target, targetKey);
    }
    Reflect.getMetadataKeys = getMetadataKeys;
    /**
      * Gets the unique metadata keys defined on the target object.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns An array of unique metadata keys.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.getOwnMetadataKeys(C);
      *
      *     // property (on constructor)
      *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");
      *
      */
    function getOwnMetadataKeys(target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        return OrdinaryOwnMetadataKeys(target, targetKey);
    }
    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
    /**
      * Deletes the metadata entry from the target object with the provided key.
      * @param metadataKey A key used to store and retrieve metadata.
      * @param target The target object on which the metadata is defined.
      * @param targetKey (Optional) The property key for the target.
      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
      * @example
      *
      *     class C {
      *         // property declarations are not part of ES6, though they are valid in TypeScript:
      *         // static staticProperty;
      *         // property;
      *
      *         constructor(p) { }
      *         static staticMethod(p) { }
      *         method(p) { }
      *     }
      *
      *     // constructor
      *     result = Reflect.deleteMetadata("custom:annotation", C);
      *
      *     // property (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");
      *
      *     // property (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");
      *
      *     // method (on constructor)
      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");
      *
      *     // method (on prototype)
      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");
      *
      */
    function deleteMetadata(metadataKey, target, targetKey) {
        if (!IsObject(target)) {
            throw new TypeError();
        }
        else if (!IsUndefined(targetKey)) {
            targetKey = ToPropertyKey(targetKey);
        }
        // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
        if (IsUndefined(metadataMap)) {
            return false;
        }
        if (!metadataMap.delete(metadataKey)) {
            return false;
        }
        if (metadataMap.size > 0) {
            return true;
        }
        var targetMetadata = __Metadata__.get(target);
        targetMetadata.delete(targetKey);
        if (targetMetadata.size > 0) {
            return true;
        }
        __Metadata__.delete(target);
        return true;
    }
    Reflect.deleteMetadata = deleteMetadata;
    function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated)) {
                if (!IsConstructor(decorated)) {
                    throw new TypeError();
                }
                target = decorated;
            }
        }
        return target;
    }
    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated)) {
                if (!IsObject(decorated)) {
                    throw new TypeError();
                }
                descriptor = decorated;
            }
        }
        return descriptor;
    }
    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
        for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            decorator(target, propertyKey);
        }
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#getorcreatemetadatamap--o-p-create-
    function GetOrCreateMetadataMap(target, targetKey, create) {
        var targetMetadata = __Metadata__.get(target);
        if (!targetMetadata) {
            if (!create) {
                return undefined;
            }
            targetMetadata = new _Map();
            __Metadata__.set(target, targetMetadata);
        }
        var keyMetadata = targetMetadata.get(targetKey);
        if (!keyMetadata) {
            if (!create) {
                return undefined;
            }
            keyMetadata = new _Map();
            targetMetadata.set(targetKey, keyMetadata);
        }
        return keyMetadata;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
    function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) {
            return true;
        }
        var parent = GetPrototypeOf(O);
        if (parent !== null) {
            return OrdinaryHasMetadata(MetadataKey, parent, P);
        }
        return false;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (metadataMap === undefined) {
            return false;
        }
        return Boolean(metadataMap.has(MetadataKey));
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-
    function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) {
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        var parent = GetPrototypeOf(O);
        if (parent !== null) {
            return OrdinaryGetMetadata(MetadataKey, parent, P);
        }
        return undefined;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, false);
        if (metadataMap === undefined) {
            return undefined;
        }
        return metadataMap.get(MetadataKey);
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, true);
        metadataMap.set(MetadataKey, MetadataValue);
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarymetadatakeys--o-p-
    function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = GetPrototypeOf(O);
        if (parent === null) {
            return ownKeys;
        }
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0) {
            return ownKeys;
        }
        if (ownKeys.length <= 0) {
            return parentKeys;
        }
        var set = new _Set();
        var keys = [];
        for (var _i = 0; _i < ownKeys.length; _i++) {
            var key = ownKeys[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        for (var _a = 0; _a < parentKeys.length; _a++) {
            var key = parentKeys[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
                set.add(key);
                keys.push(key);
            }
        }
        return keys;
    }
    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryownmetadatakeys--o-p-
    function OrdinaryOwnMetadataKeys(target, targetKey) {
        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
        var keys = [];
        if (metadataMap) {
            metadataMap.forEach(function (_, key) { return keys.push(key); });
        }
        return keys;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type
    function IsUndefined(x) {
        return x === undefined;
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
    function IsArray(x) {
        return Array.isArray(x);
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type
    function IsObject(x) {
        return typeof x === "object" ? x !== null : typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
    function IsConstructor(x) {
        return typeof x === "function";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type
    function IsSymbol(x) {
        return typeof x === "symbol";
    }
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
    function ToPropertyKey(value) {
        if (IsSymbol(value)) {
            return value;
        }
        return String(value);
    }
    function GetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== "function" || O === functionPrototype) {
            return proto;
        }
        // TypeScript doesn't set __proto__ in ES5, as it's non-standard. 
        // Try to determine the superclass constructor. Compatible implementations
        // must either set __proto__ on a subclass constructor to the superclass constructor,
        // or ensure each class has a valid `constructor` property on its prototype that
        // points back to the constructor.
        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
        // This is the case when in ES6 or when using __proto__ in a compatible browser.
        if (proto !== functionPrototype) {
            return proto;
        }
        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
        var prototype = O.prototype;
        var prototypeProto = Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype) {
            return proto;
        }
        // if the constructor was not a function, then we cannot determine the heritage.
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== "function") {
            return proto;
        }
        // if we have some kind of self-reference, then we cannot determine the heritage.
        if (constructor === O) {
            return proto;
        }
        // we have a pretty good guess at the heritage.
        return constructor;
    }
    // naive Map shim
    function CreateMapPolyfill() {
        var cacheSentinel = {};
        function Map() {
            this._keys = [];
            this._values = [];
            this._cache = cacheSentinel;
        }
        Map.prototype = {
            get size() {
                return this._keys.length;
            },
            has: function (key) {
                if (key === this._cache) {
                    return true;
                }
                if (this._find(key) >= 0) {
                    this._cache = key;
                    return true;
                }
                return false;
            },
            get: function (key) {
                var index = this._find(key);
                if (index >= 0) {
                    this._cache = key;
                    return this._values[index];
                }
                return undefined;
            },
            set: function (key, value) {
                this.delete(key);
                this._keys.push(key);
                this._values.push(value);
                this._cache = key;
                return this;
            },
            delete: function (key) {
                var index = this._find(key);
                if (index >= 0) {
                    this._keys.splice(index, 1);
                    this._values.splice(index, 1);
                    this._cache = cacheSentinel;
                    return true;
                }
                return false;
            },
            clear: function () {
                this._keys.length = 0;
                this._values.length = 0;
                this._cache = cacheSentinel;
            },
            forEach: function (callback, thisArg) {
                var size = this.size;
                for (var i = 0; i < size; ++i) {
                    var key = this._keys[i];
                    var value = this._values[i];
                    this._cache = key;
                    callback.call(this, value, key, this);
                }
            },
            _find: function (key) {
                var keys = this._keys;
                var size = keys.length;
                for (var i = 0; i < size; ++i) {
                    if (keys[i] === key) {
                        return i;
                    }
                }
                return -1;
            }
        };
        return Map;
    }
    // naive Set shim
    function CreateSetPolyfill() {
        var cacheSentinel = {};
        function Set() {
            this._map = new _Map();
        }
        Set.prototype = {
            get size() {
                return this._map.length;
            },
            has: function (value) {
                return this._map.has(value);
            },
            add: function (value) {
                this._map.set(value, value);
                return this;
            },
            delete: function (value) {
                return this._map.delete(value);
            },
            clear: function () {
                this._map.clear();
            },
            forEach: function (callback, thisArg) {
                this._map.forEach(callback, thisArg);
            }
        };
        return Set;
    }
    // naive WeakMap shim
    function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var isNode = typeof global !== "undefined" &&
            typeof module === "object" &&
            typeof module.exports === "object" &&
            typeof require === "function";
        var nodeCrypto = isNode && require("crypto");
        var hasOwn = Object.prototype.hasOwnProperty;
        var keys = {};
        var rootKey = CreateUniqueKey();
        function WeakMap() {
            this._key = CreateUniqueKey();
        }
        WeakMap.prototype = {
            has: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table) {
                    return this._key in table;
                }
                return false;
            },
            get: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table) {
                    return table[this._key];
                }
                return undefined;
            },
            set: function (target, value) {
                var table = GetOrCreateWeakMapTable(target, true);
                table[this._key] = value;
                return this;
            },
            delete: function (target) {
                var table = GetOrCreateWeakMapTable(target, false);
                if (table && this._key in table) {
                    return delete table[this._key];
                }
                return false;
            },
            clear: function () {
                // NOTE: not a real clear, just makes the previous data unreachable
                this._key = CreateUniqueKey();
            }
        };
        function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i) {
                buffer[i] = Math.random() * 255 | 0;
            }
        }
        function GenRandomBytes(size) {
            if (nodeCrypto) {
                var data = nodeCrypto.randomBytes(size);
                return data;
            }
            else if (typeof Uint8Array === "function") {
                var data = new Uint8Array(size);
                if (typeof crypto !== "undefined") {
                    crypto.getRandomValues(data);
                }
                else if (typeof msCrypto !== "undefined") {
                    msCrypto.getRandomValues(data);
                }
                else {
                    FillRandomBytes(data, size);
                }
                return data;
            }
            else {
                var data = new Array(size);
                FillRandomBytes(data, size);
                return data;
            }
        }
        function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            // mark as random - RFC 4122  4.4
            data[6] = data[6] & 0x4f | 0x40;
            data[8] = data[8] & 0xbf | 0x80;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
                var byte = data[offset];
                if (offset === 4 || offset === 6 || offset === 8) {
                    result += "-";
                }
                if (byte < 16) {
                    result += "0";
                }
                result += byte.toString(16).toLowerCase();
            }
            return result;
        }
        function CreateUniqueKey() {
            var key;
            do {
                key = "@@WeakMap@@" + CreateUUID();
            } while (hasOwn.call(keys, key));
            keys[key] = true;
            return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
                if (!create) {
                    return undefined;
                }
                Object.defineProperty(target, rootKey, { value: Object.create(null) });
            }
            return target[rootKey];
        }
        return WeakMap;
    }
    // hook global Reflect
    (function (__global) {
        if (typeof __global.Reflect !== "undefined") {
            if (__global.Reflect !== Reflect) {
                for (var p in Reflect) {
                    __global.Reflect[p] = Reflect[p];
                }
            }
        }
        else {
            __global.Reflect = Reflect;
        }
    })(typeof window !== "undefined" ? window :
        typeof WorkerGlobalScope !== "undefined" ? self :
            typeof global !== "undefined" ? global :
                Function("return this;")());
})(Reflect || (Reflect = {}));
//# sourceMappingURLDisabled=Reflect.js.map
/**
 @license

                                 Apache License
                           Version 2.0, January 2011
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */

"format register";
/**
 @license
Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.
Microsoft Open Technologies would like to thank its contributors, a list
of whom are at http://rx.codeplex.com/wikipage?title=Contributors.

Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License. You may
obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions
and limitations under the License.

 */
System.register("rx", [], true, function(require, exports, module) {
  var global = System.global,
      __define = global.define;
  global.define = undefined;
  ;
  (function(undefined) {
    var objectTypes = {
      'boolean': false,
      'function': true,
      'object': true,
      'number': false,
      'string': false,
      'undefined': false
    };
    var root = (objectTypes[typeof window] && window) || this,
        freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports,
        freeModule = objectTypes[typeof module] && module && !module.nodeType && module,
        moduleExports = freeModule && freeModule.exports === freeExports && freeExports,
        freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
      root = freeGlobal;
    }
    var Rx = {
      internals: {},
      config: {Promise: root.Promise},
      helpers: {}
    };
    var noop = Rx.helpers.noop = function() {},
        notDefined = Rx.helpers.notDefined = function(x) {
          return typeof x === 'undefined';
        },
        isScheduler = Rx.helpers.isScheduler = function(x) {
          return x instanceof Rx.Scheduler;
        },
        identity = Rx.helpers.identity = function(x) {
          return x;
        },
        pluck = Rx.helpers.pluck = function(property) {
          return function(x) {
            return x[property];
          };
        },
        just = Rx.helpers.just = function(value) {
          return function() {
            return value;
          };
        },
        defaultNow = Rx.helpers.defaultNow = Date.now,
        defaultComparer = Rx.helpers.defaultComparer = function(x, y) {
          return isEqual(x, y);
        },
        defaultSubComparer = Rx.helpers.defaultSubComparer = function(x, y) {
          return x > y ? 1 : (x < y ? -1 : 0);
        },
        defaultKeySerializer = Rx.helpers.defaultKeySerializer = function(x) {
          return x.toString();
        },
        defaultError = Rx.helpers.defaultError = function(err) {
          throw err;
        },
        isPromise = Rx.helpers.isPromise = function(p) {
          return !!p && typeof p.then === 'function';
        },
        asArray = Rx.helpers.asArray = function() {
          return Array.prototype.slice.call(arguments);
        },
        not = Rx.helpers.not = function(a) {
          return !a;
        },
        isFunction = Rx.helpers.isFunction = (function() {
          var isFn = function(value) {
            return typeof value == 'function' || false;
          };
          if (isFn(/x/)) {
            isFn = function(value) {
              return typeof value == 'function' && toString.call(value) == '[object Function]';
            };
          }
          return isFn;
        }());
    function cloneArray(arr) {
      for (var a = [],
          i = 0,
          len = arr.length; i < len; i++) {
        a.push(arr[i]);
      }
      return a;
    }
    Rx.config.longStackSupport = false;
    var hasStacks = false;
    try {
      throw new Error();
    } catch (e) {
      hasStacks = !!e.stack;
    }
    var rStartingLine = captureLine(),
        rFileName;
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error, observable) {
      if (hasStacks && observable.stack && typeof error === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
        var stacks = [];
        for (var o = observable; !!o; o = o.source) {
          if (o.stack) {
            stacks.unshift(o.stack);
          }
        }
        stacks.unshift(error.stack);
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
      }
    }
    function filterStackString(stackString) {
      var lines = stackString.split("\n"),
          desiredLines = [];
      for (var i = 0,
          len = lines.length; i < len; i++) {
        var line = lines[i];
        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
          desiredLines.push(line);
        }
      }
      return desiredLines.join("\n");
    }
    function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
      if (!fileNameAndLineNumber) {
        return false;
      }
      var fileName = fileNameAndLineNumber[0],
          lineNumber = fileNameAndLineNumber[1];
      return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
    }
    function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function captureLine() {
      if (!hasStacks) {
        return ;
      }
      try {
        throw new Error();
      } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
          return ;
        }
        rFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
      }
    }
    function getFileNameAndLineNumber(stackLine) {
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
      }
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
      }
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
      }
    }
    var EmptyError = Rx.EmptyError = function() {
      this.message = 'Sequence contains no elements.';
      Error.call(this);
    };
    EmptyError.prototype = Error.prototype;
    var ObjectDisposedError = Rx.ObjectDisposedError = function() {
      this.message = 'Object has been disposed';
      Error.call(this);
    };
    ObjectDisposedError.prototype = Error.prototype;
    var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function() {
      this.message = 'Argument out of range';
      Error.call(this);
    };
    ArgumentOutOfRangeError.prototype = Error.prototype;
    var NotSupportedError = Rx.NotSupportedError = function(message) {
      this.message = message || 'This operation is not supported';
      Error.call(this);
    };
    NotSupportedError.prototype = Error.prototype;
    var NotImplementedError = Rx.NotImplementedError = function(message) {
      this.message = message || 'This operation is not implemented';
      Error.call(this);
    };
    NotImplementedError.prototype = Error.prototype;
    var notImplemented = Rx.helpers.notImplemented = function() {
      throw new NotImplementedError();
    };
    var notSupported = Rx.helpers.notSupported = function() {
      throw new NotSupportedError();
    };
    var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
      $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
      done: true,
      value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function(o) {
      return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function(o) {
      return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var bindCallback = Rx.internals.bindCallback = function(func, thisArg, argCount) {
      if (typeof thisArg === 'undefined') {
        return func;
      }
      switch (argCount) {
        case 0:
          return function() {
            return func.call(thisArg);
          };
        case 1:
          return function(arg) {
            return func.call(thisArg, arg);
          };
        case 2:
          return function(value, index) {
            return func.call(thisArg, value, index);
          };
        case 3:
          return function(value, index, collection) {
            return func.call(thisArg, value, index, collection);
          };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    };
    var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
        dontEnumsLength = dontEnums.length;
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        errorClass = '[object Error]',
        funcClass = '[object Function]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';
    var toString = Object.prototype.toString,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        supportsArgsClass = toString.call(arguments) == argsClass,
        supportNodeClass,
        errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype,
        propertyIsEnumerable = objectProto.propertyIsEnumerable;
    try {
      supportNodeClass = !(toString.call(document) == objectClass && !({'toString': 0} + ''));
    } catch (e) {
      supportNodeClass = true;
    }
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
      'constructor': true,
      'toLocaleString': true,
      'toString': true,
      'valueOf': true
    };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
      'constructor': true,
      'toString': true,
      'valueOf': true
    };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
      'constructor': true,
      'toString': true
    };
    nonEnumProps[objectClass] = {'constructor': true};
    var support = {};
    (function() {
      var ctor = function() {
        this.x = 1;
      },
          props = [];
      ctor.prototype = {
        'valueOf': 1,
        'y': 1
      };
      for (var key in new ctor) {
        props.push(key);
      }
      for (key in arguments) {}
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
      support.nonEnumArgs = key != 0;
      support.nonEnumShadows = !/valueOf/.test(props);
    }(1));
    var isObject = Rx.internals.isObject = function(value) {
      var type = typeof value;
      return value && (type == 'function' || type == 'object') || false;
    };
    function keysIn(object) {
      var result = [];
      if (!isObject(object)) {
        return result;
      }
      if (support.nonEnumArgs && object.length && isArguments(object)) {
        object = slice.call(object);
      }
      var skipProto = support.enumPrototypes && typeof object == 'function',
          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
      for (var key in object) {
        if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
          result.push(key);
        }
      }
      if (support.nonEnumShadows && object !== objectProto) {
        var ctor = object.constructor,
            index = -1,
            length = dontEnumsLength;
        if (object === (ctor && ctor.prototype)) {
          var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object),
              nonEnum = nonEnumProps[className];
        }
        while (++index < length) {
          key = dontEnums[index];
          if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
            result.push(key);
          }
        }
      }
      return result;
    }
    function internalFor(object, callback, keysFunc) {
      var index = -1,
          props = keysFunc(object),
          length = props.length;
      while (++index < length) {
        var key = props[index];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }
    function internalForIn(object, callback) {
      return internalFor(object, callback, keysIn);
    }
    function isNode(value) {
      return typeof value.toString != 'function' && typeof(value + '') == 'string';
    }
    var isArguments = function(value) {
      return (value && typeof value == 'object') ? toString.call(value) == argsClass : false;
    };
    if (!supportsArgsClass) {
      isArguments = function(value) {
        return (value && typeof value == 'object') ? hasOwnProperty.call(value, 'callee') : false;
      };
    }
    var isEqual = Rx.internals.isEqual = function(x, y) {
      return deepEquals(x, y, [], []);
    };
    function deepEquals(a, b, stackA, stackB) {
      if (a === b) {
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;
      if (a === a && (a == null || b == null || (type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object'))) {
        return false;
      }
      var className = toString.call(a),
          otherClass = toString.call(b);
      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          return +a == +b;
        case numberClass:
          return (a != +a) ? b != +b : (a == 0 ? (1 / a == 1 / b) : a == +b);
        case regexpClass:
        case stringClass:
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
          return false;
        }
        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
        if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      var initedStack = !stackA;
      stackA || (stackA = []);
      stackB || (stackB = []);
      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      var result = true;
      stackA.push(a);
      stackB.push(b);
      if (isArr) {
        length = a.length;
        size = b.length;
        result = size == length;
        if (result) {
          while (size--) {
            var index = length,
                value = b[size];
            if (!(result = deepEquals(a[size], value, stackA, stackB))) {
              break;
            }
          }
        }
      } else {
        internalForIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            size++;
            return (result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB));
          }
        });
        if (result) {
          internalForIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();
      return result;
    }
    var hasProp = {}.hasOwnProperty,
        slice = Array.prototype.slice;
    var inherits = this.inherits = Rx.internals.inherits = function(child, parent) {
      function __() {
        this.constructor = child;
      }
      __.prototype = parent.prototype;
      child.prototype = new __();
    };
    var addProperties = Rx.internals.addProperties = function(obj) {
      for (var sources = [],
          i = 1,
          len = arguments.length; i < len; i++) {
        sources.push(arguments[i]);
      }
      for (var idx = 0,
          ln = sources.length; idx < ln; idx++) {
        var source = sources[idx];
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    };
    var addRef = Rx.internals.addRef = function(xs, r) {
      return new AnonymousObservable(function(observer) {
        return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
      });
    };
    function arrayInitialize(count, factory) {
      var a = new Array(count);
      for (var i = 0; i < count; i++) {
        a[i] = factory();
      }
      return a;
    }
    var errorObj = {e: {}};
    var tryCatchTarget;
    function tryCatcher() {
      try {
        return tryCatchTarget.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      if (!isFunction(fn)) {
        throw new TypeError('fn must be a function');
      }
      tryCatchTarget = fn;
      return tryCatcher;
    }
    function thrower(e) {
      throw e;
    }
    function IndexedItem(id, value) {
      this.id = id;
      this.value = value;
    }
    IndexedItem.prototype.compareTo = function(other) {
      var c = this.value.compareTo(other.value);
      c === 0 && (c = this.id - other.id);
      return c;
    };
    var PriorityQueue = Rx.internals.PriorityQueue = function(capacity) {
      this.items = new Array(capacity);
      this.length = 0;
    };
    var priorityProto = PriorityQueue.prototype;
    priorityProto.isHigherPriority = function(left, right) {
      return this.items[left].compareTo(this.items[right]) < 0;
    };
    priorityProto.percolate = function(index) {
      if (index >= this.length || index < 0) {
        return ;
      }
      var parent = index - 1 >> 1;
      if (parent < 0 || parent === index) {
        return ;
      }
      if (this.isHigherPriority(index, parent)) {
        var temp = this.items[index];
        this.items[index] = this.items[parent];
        this.items[parent] = temp;
        this.percolate(parent);
      }
    };
    priorityProto.heapify = function(index) {
      +index || (index = 0);
      if (index >= this.length || index < 0) {
        return ;
      }
      var left = 2 * index + 1,
          right = 2 * index + 2,
          first = index;
      if (left < this.length && this.isHigherPriority(left, first)) {
        first = left;
      }
      if (right < this.length && this.isHigherPriority(right, first)) {
        first = right;
      }
      if (first !== index) {
        var temp = this.items[index];
        this.items[index] = this.items[first];
        this.items[first] = temp;
        this.heapify(first);
      }
    };
    priorityProto.peek = function() {
      return this.items[0].value;
    };
    priorityProto.removeAt = function(index) {
      this.items[index] = this.items[--this.length];
      this.items[this.length] = undefined;
      this.heapify();
    };
    priorityProto.dequeue = function() {
      var result = this.peek();
      this.removeAt(0);
      return result;
    };
    priorityProto.enqueue = function(item) {
      var index = this.length++;
      this.items[index] = new IndexedItem(PriorityQueue.count++, item);
      this.percolate(index);
    };
    priorityProto.remove = function(item) {
      for (var i = 0; i < this.length; i++) {
        if (this.items[i].value === item) {
          this.removeAt(i);
          return true;
        }
      }
      return false;
    };
    PriorityQueue.count = 0;
    var CompositeDisposable = Rx.CompositeDisposable = function() {
      var args = [],
          i,
          len;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
        len = args.length;
      } else {
        len = arguments.length;
        args = new Array(len);
        for (i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      for (i = 0; i < len; i++) {
        if (!isDisposable(args[i])) {
          throw new TypeError('Not a disposable');
        }
      }
      this.disposables = args;
      this.isDisposed = false;
      this.length = args.length;
    };
    var CompositeDisposablePrototype = CompositeDisposable.prototype;
    CompositeDisposablePrototype.add = function(item) {
      if (this.isDisposed) {
        item.dispose();
      } else {
        this.disposables.push(item);
        this.length++;
      }
    };
    CompositeDisposablePrototype.remove = function(item) {
      var shouldDispose = false;
      if (!this.isDisposed) {
        var idx = this.disposables.indexOf(item);
        if (idx !== -1) {
          shouldDispose = true;
          this.disposables.splice(idx, 1);
          this.length--;
          item.dispose();
        }
      }
      return shouldDispose;
    };
    CompositeDisposablePrototype.dispose = function() {
      if (!this.isDisposed) {
        this.isDisposed = true;
        var len = this.disposables.length,
            currentDisposables = new Array(len);
        for (var i = 0; i < len; i++) {
          currentDisposables[i] = this.disposables[i];
        }
        this.disposables = [];
        this.length = 0;
        for (i = 0; i < len; i++) {
          currentDisposables[i].dispose();
        }
      }
    };
    var Disposable = Rx.Disposable = function(action) {
      this.isDisposed = false;
      this.action = action || noop;
    };
    Disposable.prototype.dispose = function() {
      if (!this.isDisposed) {
        this.action();
        this.isDisposed = true;
      }
    };
    var disposableCreate = Disposable.create = function(action) {
      return new Disposable(action);
    };
    var disposableEmpty = Disposable.empty = {dispose: noop};
    var isDisposable = Disposable.isDisposable = function(d) {
      return d && isFunction(d.dispose);
    };
    var checkDisposed = Disposable.checkDisposed = function(disposable) {
      if (disposable.isDisposed) {
        throw new ObjectDisposedError();
      }
    };
    var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = (function() {
      function BooleanDisposable() {
        this.isDisposed = false;
        this.current = null;
      }
      var booleanDisposablePrototype = BooleanDisposable.prototype;
      booleanDisposablePrototype.getDisposable = function() {
        return this.current;
      };
      booleanDisposablePrototype.setDisposable = function(value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
          var old = this.current;
          this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
      };
      booleanDisposablePrototype.dispose = function() {
        if (!this.isDisposed) {
          this.isDisposed = true;
          var old = this.current;
          this.current = null;
        }
        old && old.dispose();
      };
      return BooleanDisposable;
    }());
    var SerialDisposable = Rx.SerialDisposable = SingleAssignmentDisposable;
    var RefCountDisposable = Rx.RefCountDisposable = (function() {
      function InnerDisposable(disposable) {
        this.disposable = disposable;
        this.disposable.count++;
        this.isInnerDisposed = false;
      }
      InnerDisposable.prototype.dispose = function() {
        if (!this.disposable.isDisposed && !this.isInnerDisposed) {
          this.isInnerDisposed = true;
          this.disposable.count--;
          if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
            this.disposable.isDisposed = true;
            this.disposable.underlyingDisposable.dispose();
          }
        }
      };
      function RefCountDisposable(disposable) {
        this.underlyingDisposable = disposable;
        this.isDisposed = false;
        this.isPrimaryDisposed = false;
        this.count = 0;
      }
      RefCountDisposable.prototype.dispose = function() {
        if (!this.isDisposed && !this.isPrimaryDisposed) {
          this.isPrimaryDisposed = true;
          if (this.count === 0) {
            this.isDisposed = true;
            this.underlyingDisposable.dispose();
          }
        }
      };
      RefCountDisposable.prototype.getDisposable = function() {
        return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
      };
      return RefCountDisposable;
    })();
    function ScheduledDisposable(scheduler, disposable) {
      this.scheduler = scheduler;
      this.disposable = disposable;
      this.isDisposed = false;
    }
    function scheduleItem(s, self) {
      if (!self.isDisposed) {
        self.isDisposed = true;
        self.disposable.dispose();
      }
    }
    ScheduledDisposable.prototype.dispose = function() {
      this.scheduler.scheduleWithState(this, scheduleItem);
    };
    var ScheduledItem = Rx.internals.ScheduledItem = function(scheduler, state, action, dueTime, comparer) {
      this.scheduler = scheduler;
      this.state = state;
      this.action = action;
      this.dueTime = dueTime;
      this.comparer = comparer || defaultSubComparer;
      this.disposable = new SingleAssignmentDisposable();
    };
    ScheduledItem.prototype.invoke = function() {
      this.disposable.setDisposable(this.invokeCore());
    };
    ScheduledItem.prototype.compareTo = function(other) {
      return this.comparer(this.dueTime, other.dueTime);
    };
    ScheduledItem.prototype.isCancelled = function() {
      return this.disposable.isDisposed;
    };
    ScheduledItem.prototype.invokeCore = function() {
      return this.action(this.scheduler, this.state);
    };
    var Scheduler = Rx.Scheduler = (function() {
      function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
        this.now = now;
        this._schedule = schedule;
        this._scheduleRelative = scheduleRelative;
        this._scheduleAbsolute = scheduleAbsolute;
      }
      function invokeAction(scheduler, action) {
        action();
        return disposableEmpty;
      }
      var schedulerProto = Scheduler.prototype;
      schedulerProto.schedule = function(action) {
        return this._schedule(action, invokeAction);
      };
      schedulerProto.scheduleWithState = function(state, action) {
        return this._schedule(state, action);
      };
      schedulerProto.scheduleWithRelative = function(dueTime, action) {
        return this._scheduleRelative(action, dueTime, invokeAction);
      };
      schedulerProto.scheduleWithRelativeAndState = function(state, dueTime, action) {
        return this._scheduleRelative(state, dueTime, action);
      };
      schedulerProto.scheduleWithAbsolute = function(dueTime, action) {
        return this._scheduleAbsolute(action, dueTime, invokeAction);
      };
      schedulerProto.scheduleWithAbsoluteAndState = function(state, dueTime, action) {
        return this._scheduleAbsolute(state, dueTime, action);
      };
      Scheduler.now = defaultNow;
      Scheduler.normalize = function(timeSpan) {
        timeSpan < 0 && (timeSpan = 0);
        return timeSpan;
      };
      return Scheduler;
    }());
    var normalizeTime = Scheduler.normalize;
    (function(schedulerProto) {
      function invokeRecImmediate(scheduler, pair) {
        var state = pair[0],
            action = pair[1],
            group = new CompositeDisposable();
        function recursiveAction(state1) {
          action(state1, function(state2) {
            var isAdded = false,
                isDone = false,
                d = scheduler.scheduleWithState(state2, function(scheduler1, state3) {
                  if (isAdded) {
                    group.remove(d);
                  } else {
                    isDone = true;
                  }
                  recursiveAction(state3);
                  return disposableEmpty;
                });
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
          });
        }
        recursiveAction(state);
        return group;
      }
      function invokeRecDate(scheduler, pair, method) {
        var state = pair[0],
            action = pair[1],
            group = new CompositeDisposable();
        function recursiveAction(state1) {
          action(state1, function(state2, dueTime1) {
            var isAdded = false,
                isDone = false,
                d = scheduler[method](state2, dueTime1, function(scheduler1, state3) {
                  if (isAdded) {
                    group.remove(d);
                  } else {
                    isDone = true;
                  }
                  recursiveAction(state3);
                  return disposableEmpty;
                });
            if (!isDone) {
              group.add(d);
              isAdded = true;
            }
          });
        }
        ;
        recursiveAction(state);
        return group;
      }
      function scheduleInnerRecursive(action, self) {
        action(function(dt) {
          self(action, dt);
        });
      }
      schedulerProto.scheduleRecursive = function(action) {
        return this.scheduleRecursiveWithState(action, function(_action, self) {
          _action(function() {
            self(_action);
          });
        });
      };
      schedulerProto.scheduleRecursiveWithState = function(state, action) {
        return this.scheduleWithState([state, action], invokeRecImmediate);
      };
      schedulerProto.scheduleRecursiveWithRelative = function(dueTime, action) {
        return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
      };
      schedulerProto.scheduleRecursiveWithRelativeAndState = function(state, dueTime, action) {
        return this._scheduleRelative([state, action], dueTime, function(s, p) {
          return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
        });
      };
      schedulerProto.scheduleRecursiveWithAbsolute = function(dueTime, action) {
        return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
      };
      schedulerProto.scheduleRecursiveWithAbsoluteAndState = function(state, dueTime, action) {
        return this._scheduleAbsolute([state, action], dueTime, function(s, p) {
          return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
        });
      };
    }(Scheduler.prototype));
    (function(schedulerProto) {
      Scheduler.prototype.schedulePeriodic = function(period, action) {
        return this.schedulePeriodicWithState(null, period, action);
      };
      Scheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
        if (typeof root.setInterval === 'undefined') {
          throw new NotSupportedError();
        }
        period = normalizeTime(period);
        var s = state,
            id = root.setInterval(function() {
              s = action(s);
            }, period);
        return disposableCreate(function() {
          root.clearInterval(id);
        });
      };
    }(Scheduler.prototype));
    (function(schedulerProto) {
      schedulerProto.catchError = schedulerProto['catch'] = function(handler) {
        return new CatchScheduler(this, handler);
      };
    }(Scheduler.prototype));
    var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function() {
      function tick(command, recurse) {
        recurse(0, this._period);
        try {
          this._state = this._action(this._state);
        } catch (e) {
          this._cancel.dispose();
          throw e;
        }
      }
      function SchedulePeriodicRecursive(scheduler, state, period, action) {
        this._scheduler = scheduler;
        this._state = state;
        this._period = period;
        this._action = action;
      }
      SchedulePeriodicRecursive.prototype.start = function() {
        var d = new SingleAssignmentDisposable();
        this._cancel = d;
        d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
        return d;
      };
      return SchedulePeriodicRecursive;
    }());
    var immediateScheduler = Scheduler.immediate = (function() {
      function scheduleNow(state, action) {
        return action(this, state);
      }
      return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
    }());
    var currentThreadScheduler = Scheduler.currentThread = (function() {
      var queue;
      function runTrampoline() {
        while (queue.length > 0) {
          var item = queue.dequeue();
          !item.isCancelled() && item.invoke();
        }
      }
      function scheduleNow(state, action) {
        var si = new ScheduledItem(this, state, action, this.now());
        if (!queue) {
          queue = new PriorityQueue(4);
          queue.enqueue(si);
          var result = tryCatch(runTrampoline)();
          queue = null;
          if (result === errorObj) {
            return thrower(result.e);
          }
        } else {
          queue.enqueue(si);
        }
        return si.disposable;
      }
      var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
      currentScheduler.scheduleRequired = function() {
        return !queue;
      };
      return currentScheduler;
    }());
    var scheduleMethod,
        clearMethod;
    var localTimer = (function() {
      var localSetTimeout,
          localClearTimeout = noop;
      if (!!root.WScript) {
        localSetTimeout = function(fn, time) {
          root.WScript.Sleep(time);
          fn();
        };
      } else if (!!root.setTimeout) {
        localSetTimeout = root.setTimeout;
        localClearTimeout = root.clearTimeout;
      } else {
        throw new NotSupportedError();
      }
      return {
        setTimeout: localSetTimeout,
        clearTimeout: localClearTimeout
      };
    }());
    var localSetTimeout = localTimer.setTimeout,
        localClearTimeout = localTimer.clearTimeout;
    (function() {
      var nextHandle = 1,
          tasksByHandle = {},
          currentlyRunning = false;
      clearMethod = function(handle) {
        delete tasksByHandle[handle];
      };
      function runTask(handle) {
        if (currentlyRunning) {
          localSetTimeout(function() {
            runTask(handle);
          }, 0);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunning = true;
            var result = tryCatch(task)();
            clearMethod(handle);
            currentlyRunning = false;
            if (result === errorObj) {
              return thrower(result.e);
            }
          }
        }
      }
      var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
      var setImmediate = typeof(setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
      function postMessageSupported() {
        if (!root.postMessage || root.importScripts) {
          return false;
        }
        var isAsync = false,
            oldHandler = root.onmessage;
        root.onmessage = function() {
          isAsync = true;
        };
        root.postMessage('', '*');
        root.onmessage = oldHandler;
        return isAsync;
      }
      if (isFunction(setImmediate)) {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          setImmediate(function() {
            runTask(id);
          });
          return id;
        };
      } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          process.nextTick(function() {
            runTask(id);
          });
          return id;
        };
      } else if (postMessageSupported()) {
        var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
        function onGlobalPostMessage(event) {
          if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
            runTask(event.data.substring(MSG_PREFIX.length));
          }
        }
        if (root.addEventListener) {
          root.addEventListener('message', onGlobalPostMessage, false);
        } else {
          root.attachEvent('onmessage', onGlobalPostMessage, false);
        }
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          root.postMessage(MSG_PREFIX + currentId, '*');
          return id;
        };
      } else if (!!root.MessageChannel) {
        var channel = new root.MessageChannel();
        channel.port1.onmessage = function(e) {
          runTask(e.data);
        };
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          channel.port2.postMessage(id);
          return id;
        };
      } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
        scheduleMethod = function(action) {
          var scriptElement = root.document.createElement('script');
          var id = nextHandle++;
          tasksByHandle[id] = action;
          scriptElement.onreadystatechange = function() {
            runTask(id);
            scriptElement.onreadystatechange = null;
            scriptElement.parentNode.removeChild(scriptElement);
            scriptElement = null;
          };
          root.document.documentElement.appendChild(scriptElement);
          return id;
        };
      } else {
        scheduleMethod = function(action) {
          var id = nextHandle++;
          tasksByHandle[id] = action;
          localSetTimeout(function() {
            runTask(id);
          }, 0);
          return id;
        };
      }
    }());
    var timeoutScheduler = Scheduler.timeout = Scheduler.default = (function() {
      function scheduleNow(state, action) {
        var scheduler = this,
            disposable = new SingleAssignmentDisposable();
        var id = scheduleMethod(function() {
          if (!disposable.isDisposed) {
            disposable.setDisposable(action(scheduler, state));
          }
        });
        return new CompositeDisposable(disposable, disposableCreate(function() {
          clearMethod(id);
        }));
      }
      function scheduleRelative(state, dueTime, action) {
        var scheduler = this,
            dt = Scheduler.normalize(dueTime);
        if (dt === 0) {
          return scheduler.scheduleWithState(state, action);
        }
        var disposable = new SingleAssignmentDisposable();
        var id = localSetTimeout(function() {
          if (!disposable.isDisposed) {
            disposable.setDisposable(action(scheduler, state));
          }
        }, dt);
        return new CompositeDisposable(disposable, disposableCreate(function() {
          localClearTimeout(id);
        }));
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
      }
      return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
    })();
    var CatchScheduler = (function(__super__) {
      function scheduleNow(state, action) {
        return this._scheduler.scheduleWithState(state, this._wrap(action));
      }
      function scheduleRelative(state, dueTime, action) {
        return this._scheduler.scheduleWithRelativeAndState(state, dueTime, this._wrap(action));
      }
      function scheduleAbsolute(state, dueTime, action) {
        return this._scheduler.scheduleWithAbsoluteAndState(state, dueTime, this._wrap(action));
      }
      inherits(CatchScheduler, __super__);
      function CatchScheduler(scheduler, handler) {
        this._scheduler = scheduler;
        this._handler = handler;
        this._recursiveOriginal = null;
        this._recursiveWrapper = null;
        __super__.call(this, this._scheduler.now.bind(this._scheduler), scheduleNow, scheduleRelative, scheduleAbsolute);
      }
      CatchScheduler.prototype._clone = function(scheduler) {
        return new CatchScheduler(scheduler, this._handler);
      };
      CatchScheduler.prototype._wrap = function(action) {
        var parent = this;
        return function(self, state) {
          try {
            return action(parent._getRecursiveWrapper(self), state);
          } catch (e) {
            if (!parent._handler(e)) {
              throw e;
            }
            return disposableEmpty;
          }
        };
      };
      CatchScheduler.prototype._getRecursiveWrapper = function(scheduler) {
        if (this._recursiveOriginal !== scheduler) {
          this._recursiveOriginal = scheduler;
          var wrapper = this._clone(scheduler);
          wrapper._recursiveOriginal = scheduler;
          wrapper._recursiveWrapper = wrapper;
          this._recursiveWrapper = wrapper;
        }
        return this._recursiveWrapper;
      };
      CatchScheduler.prototype.schedulePeriodicWithState = function(state, period, action) {
        var self = this,
            failed = false,
            d = new SingleAssignmentDisposable();
        d.setDisposable(this._scheduler.schedulePeriodicWithState(state, period, function(state1) {
          if (failed) {
            return null;
          }
          try {
            return action(state1);
          } catch (e) {
            failed = true;
            if (!self._handler(e)) {
              throw e;
            }
            d.dispose();
            return null;
          }
        }));
        return d;
      };
      return CatchScheduler;
    }(Scheduler));
    var Notification = Rx.Notification = (function() {
      function Notification(kind, value, exception, accept, acceptObservable, toString) {
        this.kind = kind;
        this.value = value;
        this.exception = exception;
        this._accept = accept;
        this._acceptObservable = acceptObservable;
        this.toString = toString;
      }
      Notification.prototype.accept = function(observerOrOnNext, onError, onCompleted) {
        return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
      };
      Notification.prototype.toObservable = function(scheduler) {
        var self = this;
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new AnonymousObservable(function(observer) {
          return scheduler.scheduleWithState(self, function(_, notification) {
            notification._acceptObservable(observer);
            notification.kind === 'N' && observer.onCompleted();
          });
        });
      };
      return Notification;
    })();
    var notificationCreateOnNext = Notification.createOnNext = (function() {
      function _accept(onNext) {
        return onNext(this.value);
      }
      function _acceptObservable(observer) {
        return observer.onNext(this.value);
      }
      function toString() {
        return 'OnNext(' + this.value + ')';
      }
      return function(value) {
        return new Notification('N', value, null, _accept, _acceptObservable, toString);
      };
    }());
    var notificationCreateOnError = Notification.createOnError = (function() {
      function _accept(onNext, onError) {
        return onError(this.exception);
      }
      function _acceptObservable(observer) {
        return observer.onError(this.exception);
      }
      function toString() {
        return 'OnError(' + this.exception + ')';
      }
      return function(e) {
        return new Notification('E', null, e, _accept, _acceptObservable, toString);
      };
    }());
    var notificationCreateOnCompleted = Notification.createOnCompleted = (function() {
      function _accept(onNext, onError, onCompleted) {
        return onCompleted();
      }
      function _acceptObservable(observer) {
        return observer.onCompleted();
      }
      function toString() {
        return 'OnCompleted()';
      }
      return function() {
        return new Notification('C', null, null, _accept, _acceptObservable, toString);
      };
    }());
    var Enumerator = Rx.internals.Enumerator = function(next) {
      this._next = next;
    };
    Enumerator.prototype.next = function() {
      return this._next();
    };
    Enumerator.prototype[$iterator$] = function() {
      return this;
    };
    var Enumerable = Rx.internals.Enumerable = function(iterator) {
      this._iterator = iterator;
    };
    Enumerable.prototype[$iterator$] = function() {
      return this._iterator();
    };
    Enumerable.prototype.concat = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var e = sources[$iterator$]();
        var isDisposed,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursive(function(self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return o.onError(ex);
          }
          if (currentItem.done) {
            return o.onCompleted();
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, function(err) {
            o.onError(err);
          }, self));
        });
        return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    Enumerable.prototype.catchError = function() {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var e = sources[$iterator$]();
        var isDisposed,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function(lastException, self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return observer.onError(ex);
          }
          if (currentItem.done) {
            if (lastException !== null) {
              o.onError(lastException);
            } else {
              o.onCompleted();
            }
            return ;
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, self, function() {
            o.onCompleted();
          }));
        });
        return new CompositeDisposable(subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    Enumerable.prototype.catchErrorWhen = function(notificationHandler) {
      var sources = this;
      return new AnonymousObservable(function(o) {
        var exceptions = new Subject(),
            notifier = new Subject(),
            handled = notificationHandler(exceptions),
            notificationDisposable = handled.subscribe(notifier);
        var e = sources[$iterator$]();
        var isDisposed,
            lastException,
            subscription = new SerialDisposable();
        var cancelable = immediateScheduler.scheduleRecursive(function(self) {
          if (isDisposed) {
            return ;
          }
          try {
            var currentItem = e.next();
          } catch (ex) {
            return o.onError(ex);
          }
          if (currentItem.done) {
            if (lastException) {
              o.onError(lastException);
            } else {
              o.onCompleted();
            }
            return ;
          }
          var currentValue = currentItem.value;
          isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
          var outer = new SingleAssignmentDisposable();
          var inner = new SingleAssignmentDisposable();
          subscription.setDisposable(new CompositeDisposable(inner, outer));
          outer.setDisposable(currentValue.subscribe(function(x) {
            o.onNext(x);
          }, function(exn) {
            inner.setDisposable(notifier.subscribe(self, function(ex) {
              o.onError(ex);
            }, function() {
              o.onCompleted();
            }));
            exceptions.onNext(exn);
          }, function() {
            o.onCompleted();
          }));
        });
        return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function() {
          isDisposed = true;
        }));
      });
    };
    var enumerableRepeat = Enumerable.repeat = function(value, repeatCount) {
      if (repeatCount == null) {
        repeatCount = -1;
      }
      return new Enumerable(function() {
        var left = repeatCount;
        return new Enumerator(function() {
          if (left === 0) {
            return doneEnumerator;
          }
          if (left > 0) {
            left--;
          }
          return {
            done: false,
            value: value
          };
        });
      });
    };
    var enumerableOf = Enumerable.of = function(source, selector, thisArg) {
      if (selector) {
        var selectorFn = bindCallback(selector, thisArg, 3);
      }
      return new Enumerable(function() {
        var index = -1;
        return new Enumerator(function() {
          return ++index < source.length ? {
            done: false,
            value: !selector ? source[index] : selectorFn(source[index], index, source)
          } : doneEnumerator;
        });
      });
    };
    var Observer = Rx.Observer = function() {};
    Observer.prototype.toNotifier = function() {
      var observer = this;
      return function(n) {
        return n.accept(observer);
      };
    };
    Observer.prototype.asObserver = function() {
      return new AnonymousObserver(this.onNext.bind(this), this.onError.bind(this), this.onCompleted.bind(this));
    };
    Observer.prototype.checked = function() {
      return new CheckedObserver(this);
    };
    var observerCreate = Observer.create = function(onNext, onError, onCompleted) {
      onNext || (onNext = noop);
      onError || (onError = defaultError);
      onCompleted || (onCompleted = noop);
      return new AnonymousObserver(onNext, onError, onCompleted);
    };
    Observer.fromNotifier = function(handler, thisArg) {
      return new AnonymousObserver(function(x) {
        return handler.call(thisArg, notificationCreateOnNext(x));
      }, function(e) {
        return handler.call(thisArg, notificationCreateOnError(e));
      }, function() {
        return handler.call(thisArg, notificationCreateOnCompleted());
      });
    };
    Observer.prototype.notifyOn = function(scheduler) {
      return new ObserveOnObserver(scheduler, this);
    };
    Observer.prototype.makeSafe = function(disposable) {
      return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);
    };
    var AbstractObserver = Rx.internals.AbstractObserver = (function(__super__) {
      inherits(AbstractObserver, __super__);
      function AbstractObserver() {
        this.isStopped = false;
        __super__.call(this);
      }
      AbstractObserver.prototype.next = notImplemented;
      AbstractObserver.prototype.error = notImplemented;
      AbstractObserver.prototype.completed = notImplemented;
      AbstractObserver.prototype.onNext = function(value) {
        if (!this.isStopped) {
          this.next(value);
        }
      };
      AbstractObserver.prototype.onError = function(error) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.error(error);
        }
      };
      AbstractObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.completed();
        }
      };
      AbstractObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      AbstractObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.error(e);
          return true;
        }
        return false;
      };
      return AbstractObserver;
    }(Observer));
    var AnonymousObserver = Rx.AnonymousObserver = (function(__super__) {
      inherits(AnonymousObserver, __super__);
      function AnonymousObserver(onNext, onError, onCompleted) {
        __super__.call(this);
        this._onNext = onNext;
        this._onError = onError;
        this._onCompleted = onCompleted;
      }
      AnonymousObserver.prototype.next = function(value) {
        this._onNext(value);
      };
      AnonymousObserver.prototype.error = function(error) {
        this._onError(error);
      };
      AnonymousObserver.prototype.completed = function() {
        this._onCompleted();
      };
      return AnonymousObserver;
    }(AbstractObserver));
    var CheckedObserver = (function(__super__) {
      inherits(CheckedObserver, __super__);
      function CheckedObserver(observer) {
        __super__.call(this);
        this._observer = observer;
        this._state = 0;
      }
      var CheckedObserverPrototype = CheckedObserver.prototype;
      CheckedObserverPrototype.onNext = function(value) {
        this.checkAccess();
        var res = tryCatch(this._observer.onNext).call(this._observer, value);
        this._state = 0;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.onError = function(err) {
        this.checkAccess();
        var res = tryCatch(this._observer.onError).call(this._observer, err);
        this._state = 2;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.onCompleted = function() {
        this.checkAccess();
        var res = tryCatch(this._observer.onCompleted).call(this._observer);
        this._state = 2;
        res === errorObj && thrower(res.e);
      };
      CheckedObserverPrototype.checkAccess = function() {
        if (this._state === 1) {
          throw new Error('Re-entrancy detected');
        }
        if (this._state === 2) {
          throw new Error('Observer completed');
        }
        if (this._state === 0) {
          this._state = 1;
        }
      };
      return CheckedObserver;
    }(Observer));
    var ScheduledObserver = Rx.internals.ScheduledObserver = (function(__super__) {
      inherits(ScheduledObserver, __super__);
      function ScheduledObserver(scheduler, observer) {
        __super__.call(this);
        this.scheduler = scheduler;
        this.observer = observer;
        this.isAcquired = false;
        this.hasFaulted = false;
        this.queue = [];
        this.disposable = new SerialDisposable();
      }
      ScheduledObserver.prototype.next = function(value) {
        var self = this;
        this.queue.push(function() {
          self.observer.onNext(value);
        });
      };
      ScheduledObserver.prototype.error = function(e) {
        var self = this;
        this.queue.push(function() {
          self.observer.onError(e);
        });
      };
      ScheduledObserver.prototype.completed = function() {
        var self = this;
        this.queue.push(function() {
          self.observer.onCompleted();
        });
      };
      ScheduledObserver.prototype.ensureActive = function() {
        var isOwner = false,
            parent = this;
        if (!this.hasFaulted && this.queue.length > 0) {
          isOwner = !this.isAcquired;
          this.isAcquired = true;
        }
        if (isOwner) {
          this.disposable.setDisposable(this.scheduler.scheduleRecursive(function(self) {
            var work;
            if (parent.queue.length > 0) {
              work = parent.queue.shift();
            } else {
              parent.isAcquired = false;
              return ;
            }
            try {
              work();
            } catch (ex) {
              parent.queue = [];
              parent.hasFaulted = true;
              throw ex;
            }
            self();
          }));
        }
      };
      ScheduledObserver.prototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this.disposable.dispose();
      };
      return ScheduledObserver;
    }(AbstractObserver));
    var ObserveOnObserver = (function(__super__) {
      inherits(ObserveOnObserver, __super__);
      function ObserveOnObserver(scheduler, observer, cancel) {
        __super__.call(this, scheduler, observer);
        this._cancel = cancel;
      }
      ObserveOnObserver.prototype.next = function(value) {
        __super__.prototype.next.call(this, value);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.error = function(e) {
        __super__.prototype.error.call(this, e);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.completed = function() {
        __super__.prototype.completed.call(this);
        this.ensureActive();
      };
      ObserveOnObserver.prototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this._cancel && this._cancel.dispose();
        this._cancel = null;
      };
      return ObserveOnObserver;
    })(ScheduledObserver);
    var observableProto;
    var Observable = Rx.Observable = (function() {
      function Observable(subscribe) {
        if (Rx.config.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e) {
            this.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          }
          var self = this;
          this._subscribe = function(observer) {
            var oldOnError = observer.onError.bind(observer);
            observer.onError = function(err) {
              makeStackTraceLong(err, self);
              oldOnError(err);
            };
            return subscribe.call(self, observer);
          };
        } else {
          this._subscribe = subscribe;
        }
      }
      observableProto = Observable.prototype;
      observableProto.subscribe = observableProto.forEach = function(observerOrOnNext, onError, onCompleted) {
        return this._subscribe(typeof observerOrOnNext === 'object' ? observerOrOnNext : observerCreate(observerOrOnNext, onError, onCompleted));
      };
      observableProto.subscribeOnNext = function(onNext, thisArg) {
        return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) {
          onNext.call(thisArg, x);
        } : onNext));
      };
      observableProto.subscribeOnError = function(onError, thisArg) {
        return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) {
          onError.call(thisArg, e);
        } : onError));
      };
      observableProto.subscribeOnCompleted = function(onCompleted, thisArg) {
        return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() {
          onCompleted.call(thisArg);
        } : onCompleted));
      };
      return Observable;
    })();
    var ObservableBase = Rx.ObservableBase = (function(__super__) {
      inherits(ObservableBase, __super__);
      function fixSubscriber(subscriber) {
        return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
      }
      function setDisposable(s, state) {
        var ado = state[0],
            self = state[1];
        var sub = tryCatch(self.subscribeCore).call(self, ado);
        if (sub === errorObj) {
          if (!ado.fail(errorObj.e)) {
            return thrower(errorObj.e);
          }
        }
        ado.setDisposable(fixSubscriber(sub));
      }
      function subscribe(observer) {
        var ado = new AutoDetachObserver(observer),
            state = [ado, this];
        if (currentThreadScheduler.scheduleRequired()) {
          currentThreadScheduler.scheduleWithState(state, setDisposable);
        } else {
          setDisposable(null, state);
        }
        return ado;
      }
      function ObservableBase() {
        __super__.call(this, subscribe);
      }
      ObservableBase.prototype.subscribeCore = notImplemented;
      return ObservableBase;
    }(Observable));
    observableProto.observeOn = function(scheduler) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        return source.subscribe(new ObserveOnObserver(scheduler, observer));
      }, source);
    };
    observableProto.subscribeOn = function(scheduler) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var m = new SingleAssignmentDisposable(),
            d = new SerialDisposable();
        d.setDisposable(m);
        m.setDisposable(scheduler.schedule(function() {
          d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(observer)));
        }));
        return d;
      }, source);
    };
    var observableFromPromise = Observable.fromPromise = function(promise) {
      return observableDefer(function() {
        var subject = new Rx.AsyncSubject();
        promise.then(function(value) {
          subject.onNext(value);
          subject.onCompleted();
        }, subject.onError.bind(subject));
        return subject;
      });
    };
    observableProto.toPromise = function(promiseCtor) {
      promiseCtor || (promiseCtor = Rx.config.Promise);
      if (!promiseCtor) {
        throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
      }
      var source = this;
      return new promiseCtor(function(resolve, reject) {
        var value,
            hasValue = false;
        source.subscribe(function(v) {
          value = v;
          hasValue = true;
        }, reject, function() {
          hasValue && resolve(value);
        });
      });
    };
    var ToArrayObservable = (function(__super__) {
      inherits(ToArrayObservable, __super__);
      function ToArrayObservable(source) {
        this.source = source;
        __super__.call(this);
      }
      ToArrayObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new ToArrayObserver(observer));
      };
      return ToArrayObservable;
    }(ObservableBase));
    function ToArrayObserver(observer) {
      this.observer = observer;
      this.a = [];
      this.isStopped = false;
    }
    ToArrayObserver.prototype.onNext = function(x) {
      if (!this.isStopped) {
        this.a.push(x);
      }
    };
    ToArrayObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    ToArrayObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onNext(this.a);
        this.observer.onCompleted();
      }
    };
    ToArrayObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    ToArrayObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.toArray = function() {
      return new ToArrayObservable(this);
    };
    Observable.create = Observable.createWithDisposable = function(subscribe, parent) {
      return new AnonymousObservable(subscribe, parent);
    };
    var observableDefer = Observable.defer = function(observableFactory) {
      return new AnonymousObservable(function(observer) {
        var result;
        try {
          result = observableFactory();
        } catch (e) {
          return observableThrow(e).subscribe(observer);
        }
        isPromise(result) && (result = observableFromPromise(result));
        return result.subscribe(observer);
      });
    };
    var observableEmpty = Observable.empty = function(scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(observer) {
        return scheduler.scheduleWithState(null, function() {
          observer.onCompleted();
        });
      });
    };
    var FromObservable = (function(__super__) {
      inherits(FromObservable, __super__);
      function FromObservable(iterable, mapper, scheduler) {
        this.iterable = iterable;
        this.mapper = mapper;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      FromObservable.prototype.subscribeCore = function(observer) {
        var sink = new FromSink(observer, this);
        return sink.run();
      };
      return FromObservable;
    }(ObservableBase));
    var FromSink = (function() {
      function FromSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      FromSink.prototype.run = function() {
        var list = Object(this.parent.iterable),
            it = getIterable(list),
            observer = this.observer,
            mapper = this.parent.mapper;
        function loopRecursive(i, recurse) {
          try {
            var next = it.next();
          } catch (e) {
            return observer.onError(e);
          }
          if (next.done) {
            return observer.onCompleted();
          }
          var result = next.value;
          if (mapper) {
            try {
              result = mapper(result, i);
            } catch (e) {
              return observer.onError(e);
            }
          }
          observer.onNext(result);
          recurse(i + 1);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      return FromSink;
    }());
    var maxSafeInteger = Math.pow(2, 53) - 1;
    function StringIterable(str) {
      this._s = s;
    }
    StringIterable.prototype[$iterator$] = function() {
      return new StringIterator(this._s);
    };
    function StringIterator(str) {
      this._s = s;
      this._l = s.length;
      this._i = 0;
    }
    StringIterator.prototype[$iterator$] = function() {
      return this;
    };
    StringIterator.prototype.next = function() {
      return this._i < this._l ? {
        done: false,
        value: this._s.charAt(this._i++)
      } : doneEnumerator;
    };
    function ArrayIterable(a) {
      this._a = a;
    }
    ArrayIterable.prototype[$iterator$] = function() {
      return new ArrayIterator(this._a);
    };
    function ArrayIterator(a) {
      this._a = a;
      this._l = toLength(a);
      this._i = 0;
    }
    ArrayIterator.prototype[$iterator$] = function() {
      return this;
    };
    ArrayIterator.prototype.next = function() {
      return this._i < this._l ? {
        done: false,
        value: this._a[this._i++]
      } : doneEnumerator;
    };
    function numberIsFinite(value) {
      return typeof value === 'number' && root.isFinite(value);
    }
    function isNan(n) {
      return n !== n;
    }
    function getIterable(o) {
      var i = o[$iterator$],
          it;
      if (!i && typeof o === 'string') {
        it = new StringIterable(o);
        return it[$iterator$]();
      }
      if (!i && o.length !== undefined) {
        it = new ArrayIterable(o);
        return it[$iterator$]();
      }
      if (!i) {
        throw new TypeError('Object is not iterable');
      }
      return o[$iterator$]();
    }
    function sign(value) {
      var number = +value;
      if (number === 0) {
        return number;
      }
      if (isNaN(number)) {
        return number;
      }
      return number < 0 ? -1 : 1;
    }
    function toLength(o) {
      var len = +o.length;
      if (isNaN(len)) {
        return 0;
      }
      if (len === 0 || !numberIsFinite(len)) {
        return len;
      }
      len = sign(len) * Math.floor(Math.abs(len));
      if (len <= 0) {
        return 0;
      }
      if (len > maxSafeInteger) {
        return maxSafeInteger;
      }
      return len;
    }
    var observableFrom = Observable.from = function(iterable, mapFn, thisArg, scheduler) {
      if (iterable == null) {
        throw new Error('iterable cannot be null.');
      }
      if (mapFn && !isFunction(mapFn)) {
        throw new Error('mapFn when provided must be a function');
      }
      if (mapFn) {
        var mapper = bindCallback(mapFn, thisArg, 2);
      }
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromObservable(iterable, mapper, scheduler);
    };
    var FromArrayObservable = (function(__super__) {
      inherits(FromArrayObservable, __super__);
      function FromArrayObservable(args, scheduler) {
        this.args = args;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      FromArrayObservable.prototype.subscribeCore = function(observer) {
        var sink = new FromArraySink(observer, this);
        return sink.run();
      };
      return FromArrayObservable;
    }(ObservableBase));
    function FromArraySink(observer, parent) {
      this.observer = observer;
      this.parent = parent;
    }
    FromArraySink.prototype.run = function() {
      var observer = this.observer,
          args = this.parent.args,
          len = args.length;
      function loopRecursive(i, recurse) {
        if (i < len) {
          observer.onNext(args[i]);
          recurse(i + 1);
        } else {
          observer.onCompleted();
        }
      }
      return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
    };
    var observableFromArray = Observable.fromArray = function(array, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromArrayObservable(array, scheduler);
    };
    Observable.generate = function(initialState, condition, iterate, resultSelector, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new AnonymousObservable(function(o) {
        var first = true;
        return scheduler.scheduleRecursiveWithState(initialState, function(state, self) {
          var hasResult,
              result;
          try {
            if (first) {
              first = false;
            } else {
              state = iterate(state);
            }
            hasResult = condition(state);
            hasResult && (result = resultSelector(state));
          } catch (e) {
            return o.onError(e);
          }
          if (hasResult) {
            o.onNext(result);
            self(state);
          } else {
            o.onCompleted();
          }
        });
      });
    };
    var observableNever = Observable.never = function() {
      return new AnonymousObservable(function() {
        return disposableEmpty;
      });
    };
    function observableOf(scheduler, array) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new FromArrayObservable(array, scheduler);
    }
    Observable.of = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      return new FromArrayObservable(args, currentThreadScheduler);
    };
    Observable.ofWithScheduler = function(scheduler) {
      var len = arguments.length,
          args = new Array(len - 1);
      for (var i = 1; i < len; i++) {
        args[i - 1] = arguments[i];
      }
      return new FromArrayObservable(args, scheduler);
    };
    Observable.pairs = function(obj, scheduler) {
      scheduler || (scheduler = Rx.Scheduler.currentThread);
      return new AnonymousObservable(function(observer) {
        var keys = Object.keys(obj),
            len = keys.length;
        return scheduler.scheduleRecursiveWithState(0, function(idx, self) {
          if (idx < len) {
            var key = keys[idx];
            observer.onNext([key, obj[key]]);
            self(idx + 1);
          } else {
            observer.onCompleted();
          }
        });
      });
    };
    var RangeObservable = (function(__super__) {
      inherits(RangeObservable, __super__);
      function RangeObservable(start, count, scheduler) {
        this.start = start;
        this.count = count;
        this.scheduler = scheduler;
        __super__.call(this);
      }
      RangeObservable.prototype.subscribeCore = function(observer) {
        var sink = new RangeSink(observer, this);
        return sink.run();
      };
      return RangeObservable;
    }(ObservableBase));
    var RangeSink = (function() {
      function RangeSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
      }
      RangeSink.prototype.run = function() {
        var start = this.parent.start,
            count = this.parent.count,
            observer = this.observer;
        function loopRecursive(i, recurse) {
          if (i < count) {
            observer.onNext(start + i);
            recurse(i + 1);
          } else {
            observer.onCompleted();
          }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
      };
      return RangeSink;
    }());
    Observable.range = function(start, count, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return new RangeObservable(start, count, scheduler);
    };
    Observable.repeat = function(value, repeatCount, scheduler) {
      isScheduler(scheduler) || (scheduler = currentThreadScheduler);
      return observableReturn(value, scheduler).repeat(repeatCount == null ? -1 : repeatCount);
    };
    var observableReturn = Observable['return'] = Observable.just = Observable.returnValue = function(value, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(o) {
        return scheduler.scheduleWithState(value, function(_, v) {
          o.onNext(v);
          o.onCompleted();
        });
      });
    };
    var observableThrow = Observable['throw'] = Observable.throwError = function(error, scheduler) {
      isScheduler(scheduler) || (scheduler = immediateScheduler);
      return new AnonymousObservable(function(observer) {
        return scheduler.schedule(function() {
          observer.onError(error);
        });
      });
    };
    Observable.throwException = function() {
      return Observable.throwError.apply(null, arguments);
    };
    Observable.using = function(resourceFactory, observableFactory) {
      return new AnonymousObservable(function(observer) {
        var disposable = disposableEmpty,
            resource,
            source;
        try {
          resource = resourceFactory();
          resource && (disposable = resource);
          source = observableFactory(resource);
        } catch (exception) {
          return new CompositeDisposable(observableThrow(exception).subscribe(observer), disposable);
        }
        return new CompositeDisposable(source.subscribe(observer), disposable);
      });
    };
    observableProto.amb = function(rightSource) {
      var leftSource = this;
      return new AnonymousObservable(function(observer) {
        var choice,
            leftChoice = 'L',
            rightChoice = 'R',
            leftSubscription = new SingleAssignmentDisposable(),
            rightSubscription = new SingleAssignmentDisposable();
        isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));
        function choiceL() {
          if (!choice) {
            choice = leftChoice;
            rightSubscription.dispose();
          }
        }
        function choiceR() {
          if (!choice) {
            choice = rightChoice;
            leftSubscription.dispose();
          }
        }
        leftSubscription.setDisposable(leftSource.subscribe(function(left) {
          choiceL();
          if (choice === leftChoice) {
            observer.onNext(left);
          }
        }, function(err) {
          choiceL();
          if (choice === leftChoice) {
            observer.onError(err);
          }
        }, function() {
          choiceL();
          if (choice === leftChoice) {
            observer.onCompleted();
          }
        }));
        rightSubscription.setDisposable(rightSource.subscribe(function(right) {
          choiceR();
          if (choice === rightChoice) {
            observer.onNext(right);
          }
        }, function(err) {
          choiceR();
          if (choice === rightChoice) {
            observer.onError(err);
          }
        }, function() {
          choiceR();
          if (choice === rightChoice) {
            observer.onCompleted();
          }
        }));
        return new CompositeDisposable(leftSubscription, rightSubscription);
      });
    };
    Observable.amb = function() {
      var acc = observableNever(),
          items = [];
      if (Array.isArray(arguments[0])) {
        items = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          items.push(arguments[i]);
        }
      }
      function func(previous, current) {
        return previous.amb(current);
      }
      for (var i = 0,
          len = items.length; i < len; i++) {
        acc = func(acc, items[i]);
      }
      return acc;
    };
    function observableCatchHandler(source, handler) {
      return new AnonymousObservable(function(o) {
        var d1 = new SingleAssignmentDisposable(),
            subscription = new SerialDisposable();
        subscription.setDisposable(d1);
        d1.setDisposable(source.subscribe(function(x) {
          o.onNext(x);
        }, function(e) {
          try {
            var result = handler(e);
          } catch (ex) {
            return o.onError(ex);
          }
          isPromise(result) && (result = observableFromPromise(result));
          var d = new SingleAssignmentDisposable();
          subscription.setDisposable(d);
          d.setDisposable(result.subscribe(o));
        }, function(x) {
          o.onCompleted(x);
        }));
        return subscription;
      }, source);
    }
    observableProto['catch'] = observableProto.catchError = observableProto.catchException = function(handlerOrSecond) {
      return typeof handlerOrSecond === 'function' ? observableCatchHandler(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);
    };
    var observableCatch = Observable.catchError = Observable['catch'] = Observable.catchException = function() {
      var items = [];
      if (Array.isArray(arguments[0])) {
        items = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          items.push(arguments[i]);
        }
      }
      return enumerableOf(items).catchError();
    };
    observableProto.combineLatest = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      if (Array.isArray(args[0])) {
        args[0].unshift(this);
      } else {
        args.unshift(this);
      }
      return combineLatest.apply(this, args);
    };
    var combineLatest = Observable.combineLatest = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var resultSelector = args.pop();
      Array.isArray(args[0]) && (args = args[0]);
      return new AnonymousObservable(function(o) {
        var n = args.length,
            falseFactory = function() {
              return false;
            },
            hasValue = arrayInitialize(n, falseFactory),
            hasValueAll = false,
            isDone = arrayInitialize(n, falseFactory),
            values = new Array(n);
        function next(i) {
          hasValue[i] = true;
          if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
            try {
              var res = resultSelector.apply(null, values);
            } catch (e) {
              return o.onError(e);
            }
            o.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            o.onCompleted();
          }
        }
        function done(i) {
          isDone[i] = true;
          isDone.every(identity) && o.onCompleted();
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var source = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(source) && (source = observableFromPromise(source));
            sad.setDisposable(source.subscribe(function(x) {
              values[i] = x;
              next(i);
            }, function(e) {
              o.onError(e);
            }, function() {
              done(i);
            }));
            subscriptions[i] = sad;
          }(idx));
        }
        return new CompositeDisposable(subscriptions);
      }, this);
    };
    observableProto.concat = function() {
      for (var args = [],
          i = 0,
          len = arguments.length; i < len; i++) {
        args.push(arguments[i]);
      }
      args.unshift(this);
      return observableConcat.apply(null, args);
    };
    var observableConcat = Observable.concat = function() {
      var args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        args = new Array(arguments.length);
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      return enumerableOf(args).concat();
    };
    observableProto.concatAll = observableProto.concatObservable = function() {
      return this.merge(1);
    };
    var MergeObservable = (function(__super__) {
      inherits(MergeObservable, __super__);
      function MergeObservable(source, maxConcurrent) {
        this.source = source;
        this.maxConcurrent = maxConcurrent;
        __super__.call(this);
      }
      MergeObservable.prototype.subscribeCore = function(observer) {
        var g = new CompositeDisposable();
        g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
        return g;
      };
      return MergeObservable;
    }(ObservableBase));
    var MergeObserver = (function() {
      function MergeObserver(o, max, g) {
        this.o = o;
        this.max = max;
        this.g = g;
        this.done = false;
        this.q = [];
        this.activeCount = 0;
        this.isStopped = false;
      }
      MergeObserver.prototype.handleSubscribe = function(xs) {
        var sad = new SingleAssignmentDisposable();
        this.g.add(sad);
        isPromise(xs) && (xs = observableFromPromise(xs));
        sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
      };
      MergeObserver.prototype.onNext = function(innerSource) {
        if (this.isStopped) {
          return ;
        }
        if (this.activeCount < this.max) {
          this.activeCount++;
          this.handleSubscribe(innerSource);
        } else {
          this.q.push(innerSource);
        }
      };
      MergeObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      MergeObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.done = true;
          this.activeCount === 0 && this.o.onCompleted();
        }
      };
      MergeObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      MergeObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      function InnerObserver(parent, sad) {
        this.parent = parent;
        this.sad = sad;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (!this.isStopped) {
          this.parent.o.onNext(x);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          var parent = this.parent;
          parent.g.remove(this.sad);
          if (parent.q.length > 0) {
            parent.handleSubscribe(parent.q.shift());
          } else {
            parent.activeCount--;
            parent.done && parent.activeCount === 0 && parent.o.onCompleted();
          }
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
          return true;
        }
        return false;
      };
      return MergeObserver;
    }());
    observableProto.merge = function(maxConcurrentOrOther) {
      return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
    };
    var observableMerge = Observable.merge = function() {
      var scheduler,
          sources = [],
          i,
          len = arguments.length;
      if (!arguments[0]) {
        scheduler = immediateScheduler;
        for (i = 1; i < len; i++) {
          sources.push(arguments[i]);
        }
      } else if (isScheduler(arguments[0])) {
        scheduler = arguments[0];
        for (i = 1; i < len; i++) {
          sources.push(arguments[i]);
        }
      } else {
        scheduler = immediateScheduler;
        for (i = 0; i < len; i++) {
          sources.push(arguments[i]);
        }
      }
      if (Array.isArray(sources[0])) {
        sources = sources[0];
      }
      return observableOf(scheduler, sources).mergeAll();
    };
    var CompositeError = Rx.CompositeError = function(errors) {
      this.name = "NotImplementedError";
      this.innerErrors = errors;
      this.message = 'This contains multiple errors. Check the innerErrors';
      Error.call(this);
    };
    CompositeError.prototype = Error.prototype;
    Observable.mergeDelayError = function() {
      var args;
      if (Array.isArray(arguments[0])) {
        args = arguments[0];
      } else {
        var len = arguments.length;
        args = new Array(len);
        for (var i = 0; i < len; i++) {
          args[i] = arguments[i];
        }
      }
      var source = observableOf(null, args);
      return new AnonymousObservable(function(o) {
        var group = new CompositeDisposable(),
            m = new SingleAssignmentDisposable(),
            isStopped = false,
            errors = [];
        function setCompletion() {
          if (errors.length === 0) {
            o.onCompleted();
          } else if (errors.length === 1) {
            o.onError(errors[0]);
          } else {
            o.onError(new CompositeError(errors));
          }
        }
        group.add(m);
        m.setDisposable(source.subscribe(function(innerSource) {
          var innerSubscription = new SingleAssignmentDisposable();
          group.add(innerSubscription);
          isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
          innerSubscription.setDisposable(innerSource.subscribe(function(x) {
            o.onNext(x);
          }, function(e) {
            errors.push(e);
            group.remove(innerSubscription);
            isStopped && group.length === 1 && setCompletion();
          }, function() {
            group.remove(innerSubscription);
            isStopped && group.length === 1 && setCompletion();
          }));
        }, function(e) {
          errors.push(e);
          isStopped = true;
          group.length === 1 && setCompletion();
        }, function() {
          isStopped = true;
          group.length === 1 && setCompletion();
        }));
        return group;
      });
    };
    var MergeAllObservable = (function(__super__) {
      inherits(MergeAllObservable, __super__);
      function MergeAllObservable(source) {
        this.source = source;
        __super__.call(this);
      }
      MergeAllObservable.prototype.subscribeCore = function(observer) {
        var g = new CompositeDisposable(),
            m = new SingleAssignmentDisposable();
        g.add(m);
        m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
        return g;
      };
      return MergeAllObservable;
    }(ObservableBase));
    var MergeAllObserver = (function() {
      function MergeAllObserver(o, g) {
        this.o = o;
        this.g = g;
        this.isStopped = false;
        this.done = false;
      }
      MergeAllObserver.prototype.onNext = function(innerSource) {
        if (this.isStopped) {
          return ;
        }
        var sad = new SingleAssignmentDisposable();
        this.g.add(sad);
        isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
        sad.setDisposable(innerSource.subscribe(new InnerObserver(this, this.g, sad)));
      };
      MergeAllObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
        }
      };
      MergeAllObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this.done = true;
          this.g.length === 1 && this.o.onCompleted();
        }
      };
      MergeAllObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      MergeAllObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.o.onError(e);
          return true;
        }
        return false;
      };
      function InnerObserver(parent, g, sad) {
        this.parent = parent;
        this.g = g;
        this.sad = sad;
        this.isStopped = false;
      }
      InnerObserver.prototype.onNext = function(x) {
        if (!this.isStopped) {
          this.parent.o.onNext(x);
        }
      };
      InnerObserver.prototype.onError = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
        }
      };
      InnerObserver.prototype.onCompleted = function() {
        if (!this.isStopped) {
          var parent = this.parent;
          this.isStopped = true;
          parent.g.remove(this.sad);
          parent.done && parent.g.length === 1 && parent.o.onCompleted();
        }
      };
      InnerObserver.prototype.dispose = function() {
        this.isStopped = true;
      };
      InnerObserver.prototype.fail = function(e) {
        if (!this.isStopped) {
          this.isStopped = true;
          this.parent.o.onError(e);
          return true;
        }
        return false;
      };
      return MergeAllObserver;
    }());
    observableProto.mergeAll = observableProto.mergeObservable = function() {
      return new MergeAllObservable(this);
    };
    observableProto.onErrorResumeNext = function(second) {
      if (!second) {
        throw new Error('Second observable is required');
      }
      return onErrorResumeNext([this, second]);
    };
    var onErrorResumeNext = Observable.onErrorResumeNext = function() {
      var sources = [];
      if (Array.isArray(arguments[0])) {
        sources = arguments[0];
      } else {
        for (var i = 0,
            len = arguments.length; i < len; i++) {
          sources.push(arguments[i]);
        }
      }
      return new AnonymousObservable(function(observer) {
        var pos = 0,
            subscription = new SerialDisposable(),
            cancelable = immediateScheduler.scheduleRecursive(function(self) {
              var current,
                  d;
              if (pos < sources.length) {
                current = sources[pos++];
                isPromise(current) && (current = observableFromPromise(current));
                d = new SingleAssignmentDisposable();
                subscription.setDisposable(d);
                d.setDisposable(current.subscribe(observer.onNext.bind(observer), self, self));
              } else {
                observer.onCompleted();
              }
            });
        return new CompositeDisposable(subscription, cancelable);
      });
    };
    observableProto.skipUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var isOpen = false;
        var disposables = new CompositeDisposable(source.subscribe(function(left) {
          isOpen && o.onNext(left);
        }, function(e) {
          o.onError(e);
        }, function() {
          isOpen && o.onCompleted();
        }));
        isPromise(other) && (other = observableFromPromise(other));
        var rightSubscription = new SingleAssignmentDisposable();
        disposables.add(rightSubscription);
        rightSubscription.setDisposable(other.subscribe(function() {
          isOpen = true;
          rightSubscription.dispose();
        }, function(e) {
          o.onError(e);
        }, function() {
          rightSubscription.dispose();
        }));
        return disposables;
      }, source);
    };
    observableProto['switch'] = observableProto.switchLatest = function() {
      var sources = this;
      return new AnonymousObservable(function(observer) {
        var hasLatest = false,
            innerSubscription = new SerialDisposable(),
            isStopped = false,
            latest = 0,
            subscription = sources.subscribe(function(innerSource) {
              var d = new SingleAssignmentDisposable(),
                  id = ++latest;
              hasLatest = true;
              innerSubscription.setDisposable(d);
              isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
              d.setDisposable(innerSource.subscribe(function(x) {
                latest === id && observer.onNext(x);
              }, function(e) {
                latest === id && observer.onError(e);
              }, function() {
                if (latest === id) {
                  hasLatest = false;
                  isStopped && observer.onCompleted();
                }
              }));
            }, function(e) {
              observer.onError(e);
            }, function() {
              isStopped = true;
              !hasLatest && observer.onCompleted();
            });
        return new CompositeDisposable(subscription, innerSubscription);
      }, sources);
    };
    observableProto.takeUntil = function(other) {
      var source = this;
      return new AnonymousObservable(function(o) {
        isPromise(other) && (other = observableFromPromise(other));
        return new CompositeDisposable(source.subscribe(o), other.subscribe(function() {
          o.onCompleted();
        }, function(e) {
          o.onError(e);
        }, noop));
      }, source);
    };
    observableProto.withLatestFrom = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var resultSelector = args.pop(),
          source = this;
      if (typeof source === 'undefined') {
        throw new Error('Source observable not found for withLatestFrom().');
      }
      if (typeof resultSelector !== 'function') {
        throw new Error('withLatestFrom() expects a resultSelector function.');
      }
      if (Array.isArray(args[0])) {
        args = args[0];
      }
      return new AnonymousObservable(function(observer) {
        var falseFactory = function() {
          return false;
        },
            n = args.length,
            hasValue = arrayInitialize(n, falseFactory),
            hasValueAll = false,
            values = new Array(n);
        var subscriptions = new Array(n + 1);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var other = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(other) && (other = observableFromPromise(other));
            sad.setDisposable(other.subscribe(function(x) {
              values[i] = x;
              hasValue[i] = true;
              hasValueAll = hasValue.every(identity);
            }, observer.onError.bind(observer), function() {}));
            subscriptions[i] = sad;
          }(idx));
        }
        var sad = new SingleAssignmentDisposable();
        sad.setDisposable(source.subscribe(function(x) {
          var res;
          var allValues = [x].concat(values);
          if (!hasValueAll)
            return ;
          try {
            res = resultSelector.apply(null, allValues);
          } catch (ex) {
            observer.onError(ex);
            return ;
          }
          observer.onNext(res);
        }, observer.onError.bind(observer), function() {
          observer.onCompleted();
        }));
        subscriptions[n] = sad;
        return new CompositeDisposable(subscriptions);
      }, this);
    };
    function zipArray(second, resultSelector) {
      var first = this;
      return new AnonymousObservable(function(observer) {
        var index = 0,
            len = second.length;
        return first.subscribe(function(left) {
          if (index < len) {
            var right = second[index++],
                result;
            try {
              result = resultSelector(left, right);
            } catch (e) {
              return observer.onError(e);
            }
            observer.onNext(result);
          } else {
            observer.onCompleted();
          }
        }, function(e) {
          observer.onError(e);
        }, function() {
          observer.onCompleted();
        });
      }, first);
    }
    function falseFactory() {
      return false;
    }
    function emptyArrayFactory() {
      return [];
    }
    observableProto.zip = function() {
      if (Array.isArray(arguments[0])) {
        return zipArray.apply(this, arguments);
      }
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var parent = this,
          resultSelector = args.pop();
      args.unshift(parent);
      return new AnonymousObservable(function(observer) {
        var n = args.length,
            queues = arrayInitialize(n, emptyArrayFactory),
            isDone = arrayInitialize(n, falseFactory);
        function next(i) {
          var res,
              queuedValues;
          if (queues.every(function(x) {
            return x.length > 0;
          })) {
            try {
              queuedValues = queues.map(function(x) {
                return x.shift();
              });
              res = resultSelector.apply(parent, queuedValues);
            } catch (ex) {
              observer.onError(ex);
              return ;
            }
            observer.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            observer.onCompleted();
          }
        }
        ;
        function done(i) {
          isDone[i] = true;
          if (isDone.every(function(x) {
            return x;
          })) {
            observer.onCompleted();
          }
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            var source = args[i],
                sad = new SingleAssignmentDisposable();
            isPromise(source) && (source = observableFromPromise(source));
            sad.setDisposable(source.subscribe(function(x) {
              queues[i].push(x);
              next(i);
            }, function(e) {
              observer.onError(e);
            }, function() {
              done(i);
            }));
            subscriptions[i] = sad;
          })(idx);
        }
        return new CompositeDisposable(subscriptions);
      }, parent);
    };
    Observable.zip = function() {
      var len = arguments.length,
          args = new Array(len);
      for (var i = 0; i < len; i++) {
        args[i] = arguments[i];
      }
      var first = args.shift();
      return first.zip.apply(first, args);
    };
    Observable.zipArray = function() {
      var sources;
      if (Array.isArray(arguments[0])) {
        sources = arguments[0];
      } else {
        var len = arguments.length;
        sources = new Array(len);
        for (var i = 0; i < len; i++) {
          sources[i] = arguments[i];
        }
      }
      return new AnonymousObservable(function(observer) {
        var n = sources.length,
            queues = arrayInitialize(n, function() {
              return [];
            }),
            isDone = arrayInitialize(n, function() {
              return false;
            });
        function next(i) {
          if (queues.every(function(x) {
            return x.length > 0;
          })) {
            var res = queues.map(function(x) {
              return x.shift();
            });
            observer.onNext(res);
          } else if (isDone.filter(function(x, j) {
            return j !== i;
          }).every(identity)) {
            observer.onCompleted();
            return ;
          }
        }
        ;
        function done(i) {
          isDone[i] = true;
          if (isDone.every(identity)) {
            observer.onCompleted();
            return ;
          }
        }
        var subscriptions = new Array(n);
        for (var idx = 0; idx < n; idx++) {
          (function(i) {
            subscriptions[i] = new SingleAssignmentDisposable();
            subscriptions[i].setDisposable(sources[i].subscribe(function(x) {
              queues[i].push(x);
              next(i);
            }, function(e) {
              observer.onError(e);
            }, function() {
              done(i);
            }));
          })(idx);
        }
        return new CompositeDisposable(subscriptions);
      });
    };
    observableProto.asObservable = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(o);
      }, this);
    };
    observableProto.bufferWithCount = function(count, skip) {
      if (typeof skip !== 'number') {
        skip = count;
      }
      return this.windowWithCount(count, skip).selectMany(function(x) {
        return x.toArray();
      }).where(function(x) {
        return x.length > 0;
      });
    };
    observableProto.dematerialize = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(function(x) {
          return x.accept(o);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    observableProto.distinctUntilChanged = function(keySelector, comparer) {
      var source = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var hasCurrentKey = false,
            currentKey;
        return source.subscribe(function(value) {
          var key = value;
          if (keySelector) {
            try {
              key = keySelector(value);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          if (hasCurrentKey) {
            try {
              var comparerEquals = comparer(currentKey, key);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          if (!hasCurrentKey || !comparerEquals) {
            hasCurrentKey = true;
            currentKey = key;
            o.onNext(value);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    observableProto['do'] = observableProto.tap = observableProto.doAction = function(observerOrOnNext, onError, onCompleted) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var tapObserver = !observerOrOnNext || isFunction(observerOrOnNext) ? observerCreate(observerOrOnNext || noop, onError || noop, onCompleted || noop) : observerOrOnNext;
        return source.subscribe(function(x) {
          try {
            tapObserver.onNext(x);
          } catch (e) {
            observer.onError(e);
          }
          observer.onNext(x);
        }, function(err) {
          try {
            tapObserver.onError(err);
          } catch (e) {
            observer.onError(e);
          }
          observer.onError(err);
        }, function() {
          try {
            tapObserver.onCompleted();
          } catch (e) {
            observer.onError(e);
          }
          observer.onCompleted();
        });
      }, this);
    };
    observableProto.doOnNext = observableProto.tapOnNext = function(onNext, thisArg) {
      return this.tap(typeof thisArg !== 'undefined' ? function(x) {
        onNext.call(thisArg, x);
      } : onNext);
    };
    observableProto.doOnError = observableProto.tapOnError = function(onError, thisArg) {
      return this.tap(noop, typeof thisArg !== 'undefined' ? function(e) {
        onError.call(thisArg, e);
      } : onError);
    };
    observableProto.doOnCompleted = observableProto.tapOnCompleted = function(onCompleted, thisArg) {
      return this.tap(noop, null, typeof thisArg !== 'undefined' ? function() {
        onCompleted.call(thisArg);
      } : onCompleted);
    };
    observableProto['finally'] = observableProto.ensure = function(action) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var subscription;
        try {
          subscription = source.subscribe(observer);
        } catch (e) {
          action();
          throw e;
        }
        return disposableCreate(function() {
          try {
            subscription.dispose();
          } catch (e) {
            throw e;
          } finally {
            action();
          }
        });
      }, this);
    };
    observableProto.finallyAction = function(action) {
      return this.ensure(action);
    };
    observableProto.ignoreElements = function() {
      var source = this;
      return new AnonymousObservable(function(o) {
        return source.subscribe(noop, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.materialize = function() {
      var source = this;
      return new AnonymousObservable(function(observer) {
        return source.subscribe(function(value) {
          observer.onNext(notificationCreateOnNext(value));
        }, function(e) {
          observer.onNext(notificationCreateOnError(e));
          observer.onCompleted();
        }, function() {
          observer.onNext(notificationCreateOnCompleted());
          observer.onCompleted();
        });
      }, source);
    };
    observableProto.repeat = function(repeatCount) {
      return enumerableRepeat(this, repeatCount).concat();
    };
    observableProto.retry = function(retryCount) {
      return enumerableRepeat(this, retryCount).catchError();
    };
    observableProto.retryWhen = function(notifier) {
      return enumerableRepeat(this).catchErrorWhen(notifier);
    };
    observableProto.scan = function() {
      var hasSeed = false,
          seed,
          accumulator,
          source = this;
      if (arguments.length === 2) {
        hasSeed = true;
        seed = arguments[0];
        accumulator = arguments[1];
      } else {
        accumulator = arguments[0];
      }
      return new AnonymousObservable(function(o) {
        var hasAccumulation,
            accumulation,
            hasValue;
        return source.subscribe(function(x) {
          !hasValue && (hasValue = true);
          try {
            if (hasAccumulation) {
              accumulation = accumulator(accumulation, x);
            } else {
              accumulation = hasSeed ? accumulator(seed, x) : x;
              hasAccumulation = true;
            }
          } catch (e) {
            o.onError(e);
            return ;
          }
          o.onNext(accumulation);
        }, function(e) {
          o.onError(e);
        }, function() {
          !hasValue && hasSeed && o.onNext(seed);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.skipLast = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && o.onNext(q.shift());
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.startWith = function() {
      var values,
          scheduler,
          start = 0;
      if (!!arguments.length && isScheduler(arguments[0])) {
        scheduler = arguments[0];
        start = 1;
      } else {
        scheduler = immediateScheduler;
      }
      for (var args = [],
          i = start,
          len = arguments.length; i < len; i++) {
        args.push(arguments[i]);
      }
      return enumerableOf([observableFromArray(args, scheduler), this]).concat();
    };
    observableProto.takeLast = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && q.shift();
        }, function(e) {
          o.onError(e);
        }, function() {
          while (q.length > 0) {
            o.onNext(q.shift());
          }
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeLastBuffer = function(count) {
      var source = this;
      return new AnonymousObservable(function(o) {
        var q = [];
        return source.subscribe(function(x) {
          q.push(x);
          q.length > count && q.shift();
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onNext(q);
          o.onCompleted();
        });
      }, source);
    };
    observableProto.windowWithCount = function(count, skip) {
      var source = this;
      +count || (count = 0);
      Math.abs(count) === Infinity && (count = 0);
      if (count <= 0) {
        throw new ArgumentOutOfRangeError();
      }
      skip == null && (skip = count);
      +skip || (skip = 0);
      Math.abs(skip) === Infinity && (skip = 0);
      if (skip <= 0) {
        throw new ArgumentOutOfRangeError();
      }
      return new AnonymousObservable(function(observer) {
        var m = new SingleAssignmentDisposable(),
            refCountDisposable = new RefCountDisposable(m),
            n = 0,
            q = [];
        function createWindow() {
          var s = new Subject();
          q.push(s);
          observer.onNext(addRef(s, refCountDisposable));
        }
        createWindow();
        m.setDisposable(source.subscribe(function(x) {
          for (var i = 0,
              len = q.length; i < len; i++) {
            q[i].onNext(x);
          }
          var c = n - count + 1;
          c >= 0 && c % skip === 0 && q.shift().onCompleted();
          ++n % skip === 0 && createWindow();
        }, function(e) {
          while (q.length > 0) {
            q.shift().onError(e);
          }
          observer.onError(e);
        }, function() {
          while (q.length > 0) {
            q.shift().onCompleted();
          }
          observer.onCompleted();
        }));
        return refCountDisposable;
      }, source);
    };
    function concatMap(source, selector, thisArg) {
      var selectorFunc = bindCallback(selector, thisArg, 3);
      return source.map(function(x, i) {
        var result = selectorFunc(x, i, source);
        isPromise(result) && (result = observableFromPromise(result));
        (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
        return result;
      }).concatAll();
    }
    observableProto.selectConcat = observableProto.concatMap = function(selector, resultSelector, thisArg) {
      if (isFunction(selector) && isFunction(resultSelector)) {
        return this.concatMap(function(x, i) {
          var selectorResult = selector(x, i);
          isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
          (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
          return selectorResult.map(function(y, i2) {
            return resultSelector(x, y, i, i2);
          });
        });
      }
      return isFunction(selector) ? concatMap(this, selector, thisArg) : concatMap(this, function() {
        return selector;
      });
    };
    observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {
      var source = this,
          onNextFunc = bindCallback(onNext, thisArg, 2),
          onErrorFunc = bindCallback(onError, thisArg, 1),
          onCompletedFunc = bindCallback(onCompleted, thisArg, 0);
      return new AnonymousObservable(function(observer) {
        var index = 0;
        return source.subscribe(function(x) {
          var result;
          try {
            result = onNextFunc(x, index++);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
        }, function(err) {
          var result;
          try {
            result = onErrorFunc(err);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        }, function() {
          var result;
          try {
            result = onCompletedFunc();
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        });
      }, this).concatAll();
    };
    observableProto.defaultIfEmpty = function(defaultValue) {
      var source = this;
      defaultValue === undefined && (defaultValue = null);
      return new AnonymousObservable(function(observer) {
        var found = false;
        return source.subscribe(function(x) {
          found = true;
          observer.onNext(x);
        }, function(e) {
          observer.onError(e);
        }, function() {
          !found && observer.onNext(defaultValue);
          observer.onCompleted();
        });
      }, source);
    };
    function arrayIndexOfComparer(array, item, comparer) {
      for (var i = 0,
          len = array.length; i < len; i++) {
        if (comparer(array[i], item)) {
          return i;
        }
      }
      return -1;
    }
    function HashSet(comparer) {
      this.comparer = comparer;
      this.set = [];
    }
    HashSet.prototype.push = function(value) {
      var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;
      retValue && this.set.push(value);
      return retValue;
    };
    observableProto.distinct = function(keySelector, comparer) {
      var source = this;
      comparer || (comparer = defaultComparer);
      return new AnonymousObservable(function(o) {
        var hashSet = new HashSet(comparer);
        return source.subscribe(function(x) {
          var key = x;
          if (keySelector) {
            try {
              key = keySelector(x);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          hashSet.push(key) && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, this);
    };
    var MapObservable = (function(__super__) {
      inherits(MapObservable, __super__);
      function MapObservable(source, selector, thisArg) {
        this.source = source;
        this.selector = bindCallback(selector, thisArg, 3);
        __super__.call(this);
      }
      MapObservable.prototype.internalMap = function(selector, thisArg) {
        var self = this;
        return new MapObservable(this.source, function(x, i, o) {
          return selector.call(this, self.selector(x, i, o), i, o);
        }, thisArg);
      };
      MapObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new MapObserver(observer, this.selector, this));
      };
      return MapObservable;
    }(ObservableBase));
    function MapObserver(observer, selector, source) {
      this.observer = observer;
      this.selector = selector;
      this.source = source;
      this.i = 0;
      this.isStopped = false;
    }
    MapObserver.prototype.onNext = function(x) {
      if (this.isStopped) {
        return ;
      }
      var result = tryCatch(this.selector).call(this, x, this.i++, this.source);
      if (result === errorObj) {
        return this.observer.onError(result.e);
      }
      this.observer.onNext(result);
    };
    MapObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    MapObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onCompleted();
      }
    };
    MapObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    MapObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.map = observableProto.select = function(selector, thisArg) {
      var selectorFn = typeof selector === 'function' ? selector : function() {
        return selector;
      };
      return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
    };
    observableProto.pluck = function() {
      var args = arguments,
          len = arguments.length;
      if (len === 0) {
        throw new Error('List of properties cannot be empty.');
      }
      return this.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < len; i++) {
          var p = currentProp[args[i]];
          if (typeof p !== 'undefined') {
            currentProp = p;
          } else {
            return undefined;
          }
        }
        return currentProp;
      });
    };
    observableProto.flatMapObserver = observableProto.selectManyObserver = function(onNext, onError, onCompleted, thisArg) {
      var source = this;
      return new AnonymousObservable(function(observer) {
        var index = 0;
        return source.subscribe(function(x) {
          var result;
          try {
            result = onNext.call(thisArg, x, index++);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
        }, function(err) {
          var result;
          try {
            result = onError.call(thisArg, err);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        }, function() {
          var result;
          try {
            result = onCompleted.call(thisArg);
          } catch (e) {
            observer.onError(e);
            return ;
          }
          isPromise(result) && (result = observableFromPromise(result));
          observer.onNext(result);
          observer.onCompleted();
        });
      }, source).mergeAll();
    };
    function flatMap(source, selector, thisArg) {
      var selectorFunc = bindCallback(selector, thisArg, 3);
      return source.map(function(x, i) {
        var result = selectorFunc(x, i, source);
        isPromise(result) && (result = observableFromPromise(result));
        (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));
        return result;
      }).mergeAll();
    }
    observableProto.selectMany = observableProto.flatMap = function(selector, resultSelector, thisArg) {
      if (isFunction(selector) && isFunction(resultSelector)) {
        return this.flatMap(function(x, i) {
          var selectorResult = selector(x, i);
          isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));
          (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));
          return selectorResult.map(function(y, i2) {
            return resultSelector(x, y, i, i2);
          });
        }, thisArg);
      }
      return isFunction(selector) ? flatMap(this, selector, thisArg) : flatMap(this, function() {
        return selector;
      });
    };
    observableProto.selectSwitch = observableProto.flatMapLatest = observableProto.switchMap = function(selector, thisArg) {
      return this.select(selector, thisArg).switchLatest();
    };
    observableProto.skip = function(count) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var remaining = count;
        return source.subscribe(function(x) {
          if (remaining <= 0) {
            o.onNext(x);
          } else {
            remaining--;
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.skipWhile = function(predicate, thisArg) {
      var source = this,
          callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0,
            running = false;
        return source.subscribe(function(x) {
          if (!running) {
            try {
              running = !callback(x, i++, source);
            } catch (e) {
              o.onError(e);
              return ;
            }
          }
          running && o.onNext(x);
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.take = function(count, scheduler) {
      if (count < 0) {
        throw new ArgumentOutOfRangeError();
      }
      if (count === 0) {
        return observableEmpty(scheduler);
      }
      var source = this;
      return new AnonymousObservable(function(o) {
        var remaining = count;
        return source.subscribe(function(x) {
          if (remaining-- > 0) {
            o.onNext(x);
            remaining === 0 && o.onCompleted();
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    observableProto.takeWhile = function(predicate, thisArg) {
      var source = this,
          callback = bindCallback(predicate, thisArg, 3);
      return new AnonymousObservable(function(o) {
        var i = 0,
            running = true;
        return source.subscribe(function(x) {
          if (running) {
            try {
              running = callback(x, i++, source);
            } catch (e) {
              o.onError(e);
              return ;
            }
            if (running) {
              o.onNext(x);
            } else {
              o.onCompleted();
            }
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          o.onCompleted();
        });
      }, source);
    };
    var FilterObservable = (function(__super__) {
      inherits(FilterObservable, __super__);
      function FilterObservable(source, predicate, thisArg) {
        this.source = source;
        this.predicate = bindCallback(predicate, thisArg, 3);
        __super__.call(this);
      }
      FilterObservable.prototype.subscribeCore = function(observer) {
        return this.source.subscribe(new FilterObserver(observer, this.predicate, this));
      };
      FilterObservable.prototype.internalFilter = function(predicate, thisArg) {
        var self = this;
        return new FilterObservable(this.source, function(x, i, o) {
          return self.predicate(x, i, o) && predicate.call(this, x, i, o);
        }, thisArg);
      };
      return FilterObservable;
    }(ObservableBase));
    function FilterObserver(observer, predicate, source) {
      this.observer = observer;
      this.predicate = predicate;
      this.source = source;
      this.i = 0;
      this.isStopped = false;
    }
    FilterObserver.prototype.onNext = function(x) {
      if (this.isStopped) {
        return ;
      }
      var shouldYield = tryCatch(this.predicate).call(this, x, this.i++, this.source);
      if (shouldYield === errorObj) {
        return this.observer.onError(shouldYield.e);
      }
      shouldYield && this.observer.onNext(x);
    };
    FilterObserver.prototype.onError = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
      }
    };
    FilterObserver.prototype.onCompleted = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onCompleted();
      }
    };
    FilterObserver.prototype.dispose = function() {
      this.isStopped = true;
    };
    FilterObserver.prototype.fail = function(e) {
      if (!this.isStopped) {
        this.isStopped = true;
        this.observer.onError(e);
        return true;
      }
      return false;
    };
    observableProto.filter = observableProto.where = function(predicate, thisArg) {
      return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
    };
    observableProto.transduce = function(transducer) {
      var source = this;
      function transformForObserver(o) {
        return {
          '@@transducer/init': function() {
            return o;
          },
          '@@transducer/step': function(obs, input) {
            return obs.onNext(input);
          },
          '@@transducer/result': function(obs) {
            return obs.onCompleted();
          }
        };
      }
      return new AnonymousObservable(function(o) {
        var xform = transducer(transformForObserver(o));
        return source.subscribe(function(v) {
          try {
            xform['@@transducer/step'](o, v);
          } catch (e) {
            o.onError(e);
          }
        }, function(e) {
          o.onError(e);
        }, function() {
          xform['@@transducer/result'](o);
        });
      }, source);
    };
    var AnonymousObservable = Rx.AnonymousObservable = (function(__super__) {
      inherits(AnonymousObservable, __super__);
      function fixSubscriber(subscriber) {
        return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
      }
      function setDisposable(s, state) {
        var ado = state[0],
            subscribe = state[1];
        var sub = tryCatch(subscribe)(ado);
        if (sub === errorObj) {
          if (!ado.fail(errorObj.e)) {
            return thrower(errorObj.e);
          }
        }
        ado.setDisposable(fixSubscriber(sub));
      }
      function AnonymousObservable(subscribe, parent) {
        this.source = parent;
        function s(observer) {
          var ado = new AutoDetachObserver(observer),
              state = [ado, subscribe];
          if (currentThreadScheduler.scheduleRequired()) {
            currentThreadScheduler.scheduleWithState(state, setDisposable);
          } else {
            setDisposable(null, state);
          }
          return ado;
        }
        __super__.call(this, s);
      }
      return AnonymousObservable;
    }(Observable));
    var AutoDetachObserver = (function(__super__) {
      inherits(AutoDetachObserver, __super__);
      function AutoDetachObserver(observer) {
        __super__.call(this);
        this.observer = observer;
        this.m = new SingleAssignmentDisposable();
      }
      var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
      AutoDetachObserverPrototype.next = function(value) {
        var result = tryCatch(this.observer.onNext).call(this.observer, value);
        if (result === errorObj) {
          this.dispose();
          thrower(result.e);
        }
      };
      AutoDetachObserverPrototype.error = function(err) {
        var result = tryCatch(this.observer.onError).call(this.observer, err);
        this.dispose();
        result === errorObj && thrower(result.e);
      };
      AutoDetachObserverPrototype.completed = function() {
        var result = tryCatch(this.observer.onCompleted).call(this.observer);
        this.dispose();
        result === errorObj && thrower(result.e);
      };
      AutoDetachObserverPrototype.setDisposable = function(value) {
        this.m.setDisposable(value);
      };
      AutoDetachObserverPrototype.getDisposable = function() {
        return this.m.getDisposable();
      };
      AutoDetachObserverPrototype.dispose = function() {
        __super__.prototype.dispose.call(this);
        this.m.dispose();
      };
      return AutoDetachObserver;
    }(AbstractObserver));
    var InnerSubscription = function(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function() {
      if (!this.subject.isDisposed && this.observer !== null) {
        var idx = this.subject.observers.indexOf(this.observer);
        this.subject.observers.splice(idx, 1);
        this.observer = null;
      }
    };
    var Subject = Rx.Subject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
          return disposableEmpty;
        }
        observer.onCompleted();
        return disposableEmpty;
      }
      inherits(Subject, __super__);
      function Subject() {
        __super__.call(this, subscribe);
        this.isDisposed = false, this.isStopped = false, this.observers = [];
        this.hasError = false;
      }
      addProperties(Subject.prototype, Observer.prototype, {
        hasObservers: function() {
          return this.observers.length > 0;
        },
        onCompleted: function() {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onCompleted();
            }
            this.observers.length = 0;
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            this.error = error;
            this.hasError = true;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onError(error);
            }
            this.observers.length = 0;
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (!this.isStopped) {
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onNext(value);
            }
          }
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
        }
      });
      Subject.create = function(observer, observable) {
        return new AnonymousSubject(observer, observable);
      };
      return Subject;
    }(Observable));
    var AsyncSubject = Rx.AsyncSubject = (function(__super__) {
      function subscribe(observer) {
        checkDisposed(this);
        if (!this.isStopped) {
          this.observers.push(observer);
          return new InnerSubscription(this, observer);
        }
        if (this.hasError) {
          observer.onError(this.error);
        } else if (this.hasValue) {
          observer.onNext(this.value);
          observer.onCompleted();
        } else {
          observer.onCompleted();
        }
        return disposableEmpty;
      }
      inherits(AsyncSubject, __super__);
      function AsyncSubject() {
        __super__.call(this, subscribe);
        this.isDisposed = false;
        this.isStopped = false;
        this.hasValue = false;
        this.observers = [];
        this.hasError = false;
      }
      addProperties(AsyncSubject.prototype, Observer, {
        hasObservers: function() {
          checkDisposed(this);
          return this.observers.length > 0;
        },
        onCompleted: function() {
          var i,
              len;
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            var os = cloneArray(this.observers),
                len = os.length;
            if (this.hasValue) {
              for (i = 0; i < len; i++) {
                var o = os[i];
                o.onNext(this.value);
                o.onCompleted();
              }
            } else {
              for (i = 0; i < len; i++) {
                os[i].onCompleted();
              }
            }
            this.observers.length = 0;
          }
        },
        onError: function(error) {
          checkDisposed(this);
          if (!this.isStopped) {
            this.isStopped = true;
            this.hasError = true;
            this.error = error;
            for (var i = 0,
                os = cloneArray(this.observers),
                len = os.length; i < len; i++) {
              os[i].onError(error);
            }
            this.observers.length = 0;
          }
        },
        onNext: function(value) {
          checkDisposed(this);
          if (this.isStopped) {
            return ;
          }
          this.value = value;
          this.hasValue = true;
        },
        dispose: function() {
          this.isDisposed = true;
          this.observers = null;
          this.exception = null;
          this.value = null;
        }
      });
      return AsyncSubject;
    }(Observable));
    var AnonymousSubject = Rx.AnonymousSubject = (function(__super__) {
      inherits(AnonymousSubject, __super__);
      function subscribe(observer) {
        return this.observable.subscribe(observer);
      }
      function AnonymousSubject(observer, observable) {
        this.observer = observer;
        this.observable = observable;
        __super__.call(this, subscribe);
      }
      addProperties(AnonymousSubject.prototype, Observer.prototype, {
        onCompleted: function() {
          this.observer.onCompleted();
        },
        onError: function(error) {
          this.observer.onError(error);
        },
        onNext: function(value) {
          this.observer.onNext(value);
        }
      });
      return AnonymousSubject;
    }(Observable));
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      root.Rx = Rx;
      define(function() {
        return Rx;
      });
    } else if (freeExports && freeModule) {
      if (moduleExports) {
        (freeModule.exports = Rx).Rx = Rx;
      } else {
        freeExports.Rx = Rx;
      }
    } else {
      root.Rx = Rx;
    }
    var rEndingLine = captureLine();
  }.call(this));
  global.define = __define;
  return module.exports;
});

System.register("angular2/src/facade/lang", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/lang";
  var _global,
      Type,
      isDart,
      BaseException,
      Math,
      Date,
      assertionsEnabled_,
      StringWrapper,
      StringJoiner,
      NumberParseError,
      NumberWrapper,
      RegExp,
      RegExpWrapper,
      RegExpMatcherWrapper,
      FunctionWrapper,
      Json,
      DateWrapper;
  function getTypeNameForDebugging(type) {
    return type['name'];
  }
  function makeTypeError(message) {
    return new TypeError(message);
  }
  function assertionsEnabled() {
    return assertionsEnabled_;
  }
  function ENUM_INDEX(value) {
    return value;
  }
  function CONST_EXPR(expr) {
    return expr;
  }
  function CONST() {
    return (function(target) {
      return target;
    });
  }
  function ABSTRACT() {
    return (function(t) {
      return t;
    });
  }
  function IMPLEMENTS(_) {
    return (function(t) {
      return t;
    });
  }
  function isPresent(obj) {
    return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
    return obj === undefined || obj === null;
  }
  function isString(obj) {
    return typeof obj === "string";
  }
  function isFunction(obj) {
    return typeof obj === "function";
  }
  function isType(obj) {
    return isFunction(obj);
  }
  function isStringMap(obj) {
    return typeof obj === 'object' && obj !== null;
  }
  function isPromise(obj) {
    return obj instanceof _global.Promise;
  }
  function isArray(obj) {
    return Array.isArray(obj);
  }
  function isNumber(obj) {
    return typeof obj === 'number';
  }
  function isDate(obj) {
    return obj instanceof Date && !isNaN(obj.valueOf());
  }
  function stringify(token) {
    if (typeof token === 'string') {
      return token;
    }
    if (token === undefined || token === null) {
      return '' + token;
    }
    if (token.name) {
      return token.name;
    }
    var res = token.toString();
    var newLineIndex = res.indexOf("\n");
    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
  }
  function serializeEnum(val) {
    return val;
  }
  function deserializeEnum(val, values) {
    return val;
  }
  function looseIdentical(a, b) {
    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
  }
  function getMapKey(value) {
    return value;
  }
  function normalizeBlank(obj) {
    return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
    return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function print(obj) {
    if (obj instanceof BaseException) {
      console.log(obj.stack);
    } else {
      console.log(obj);
    }
  }
  $__export("getTypeNameForDebugging", getTypeNameForDebugging);
  $__export("makeTypeError", makeTypeError);
  $__export("assertionsEnabled", assertionsEnabled);
  $__export("ENUM_INDEX", ENUM_INDEX);
  $__export("CONST_EXPR", CONST_EXPR);
  $__export("CONST", CONST);
  $__export("ABSTRACT", ABSTRACT);
  $__export("IMPLEMENTS", IMPLEMENTS);
  $__export("isPresent", isPresent);
  $__export("isBlank", isBlank);
  $__export("isString", isString);
  $__export("isFunction", isFunction);
  $__export("isType", isType);
  $__export("isStringMap", isStringMap);
  $__export("isPromise", isPromise);
  $__export("isArray", isArray);
  $__export("isNumber", isNumber);
  $__export("isDate", isDate);
  $__export("stringify", stringify);
  $__export("serializeEnum", serializeEnum);
  $__export("deserializeEnum", deserializeEnum);
  $__export("looseIdentical", looseIdentical);
  $__export("getMapKey", getMapKey);
  $__export("normalizeBlank", normalizeBlank);
  $__export("normalizeBool", normalizeBool);
  $__export("isJsObject", isJsObject);
  $__export("print", print);
  return {
    setters: [],
    execute: function() {
      _global = (typeof window === 'undefined' ? global : window);
      $__export("global", _global);
      Type = Function;
      $__export("Type", Type);
      isDart = false;
      $__export("isDart", isDart);
      BaseException = (function($__super) {
        function BaseException(message, _originalException, _originalStack, _context) {
          $traceurRuntime.superConstructor(BaseException).call(this, message);
          this.message = message;
          this._originalException = _originalException;
          this._originalStack = _originalStack;
          this._context = _context;
          this.stack = (new Error(message)).stack;
        }
        return ($traceurRuntime.createClass)(BaseException, {
          get originalException() {
            return this._originalException;
          },
          get originalStack() {
            return this._originalStack;
          },
          get context() {
            return this._context;
          },
          toString: function() {
            return this.message;
          }
        }, {}, $__super);
      }(Error));
      $__export("BaseException", BaseException);
      Math = _global.Math;
      $__export("Math", Math);
      Date = _global.Date;
      $__export("Date", Date);
      assertionsEnabled_ = typeof _global['assert'] !== 'undefined';
      _global.assert = function assert(condition) {
        if (assertionsEnabled_) {
          _global['assert'].call(condition);
        }
      };
      StringWrapper = (function() {
        function StringWrapper() {}
        return ($traceurRuntime.createClass)(StringWrapper, {}, {
          fromCharCode: function(code) {
            return String.fromCharCode(code);
          },
          charCodeAt: function(s, index) {
            return s.charCodeAt(index);
          },
          split: function(s, regExp) {
            return s.split(regExp);
          },
          equals: function(s, s2) {
            return s === s2;
          },
          replace: function(s, from, replace) {
            return s.replace(from, replace);
          },
          replaceAll: function(s, from, replace) {
            return s.replace(from, replace);
          },
          toUpperCase: function(s) {
            return s.toUpperCase();
          },
          toLowerCase: function(s) {
            return s.toLowerCase();
          },
          startsWith: function(s, start) {
            return s.startsWith(start);
          },
          substring: function(s, start) {
            var end = arguments[2] !== (void 0) ? arguments[2] : null;
            return s.substring(start, end === null ? undefined : end);
          },
          replaceAllMapped: function(s, from, cb) {
            return s.replace(from, function() {
              for (var matches = [],
                  $__1 = 0; $__1 < arguments.length; $__1++)
                matches[$__1] = arguments[$__1];
              matches.splice(-2, 2);
              return cb(matches);
            });
          },
          contains: function(s, substr) {
            return s.indexOf(substr) != -1;
          },
          compare: function(a, b) {
            if (a < b) {
              return -1;
            } else if (a > b) {
              return 1;
            } else {
              return 0;
            }
          }
        });
      }());
      $__export("StringWrapper", StringWrapper);
      StringJoiner = (function() {
        function StringJoiner() {
          var parts = arguments[0] !== (void 0) ? arguments[0] : [];
          this.parts = parts;
        }
        return ($traceurRuntime.createClass)(StringJoiner, {
          add: function(part) {
            this.parts.push(part);
          },
          toString: function() {
            return this.parts.join("");
          }
        }, {});
      }());
      $__export("StringJoiner", StringJoiner);
      NumberParseError = (function($__super) {
        function NumberParseError(message) {
          $traceurRuntime.superConstructor(NumberParseError).call(this);
          this.message = message;
        }
        return ($traceurRuntime.createClass)(NumberParseError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("NumberParseError", NumberParseError);
      NumberWrapper = (function() {
        function NumberWrapper() {}
        return ($traceurRuntime.createClass)(NumberWrapper, {}, {
          toFixed: function(n, fractionDigits) {
            return n.toFixed(fractionDigits);
          },
          equal: function(a, b) {
            return a === b;
          },
          parseIntAutoRadix: function(text) {
            var result = parseInt(text);
            if (isNaN(result)) {
              throw new NumberParseError("Invalid integer literal when parsing " + text);
            }
            return result;
          },
          parseInt: function(text, radix) {
            if (radix == 10) {
              if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else if (radix == 16) {
              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
              }
            } else {
              var result = parseInt(text, radix);
              if (!isNaN(result)) {
                return result;
              }
            }
            throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " + radix);
          },
          parseFloat: function(text) {
            return parseFloat(text);
          },
          get NaN() {
            return NaN;
          },
          isNaN: function(value) {
            return isNaN(value);
          },
          isInteger: function(value) {
            return Number.isInteger(value);
          }
        });
      }());
      $__export("NumberWrapper", NumberWrapper);
      RegExp = _global.RegExp;
      $__export("RegExp", RegExp);
      RegExpWrapper = (function() {
        function RegExpWrapper() {}
        return ($traceurRuntime.createClass)(RegExpWrapper, {}, {
          create: function(regExpStr) {
            var flags = arguments[1] !== (void 0) ? arguments[1] : '';
            flags = flags.replace(/g/g, '');
            return new _global.RegExp(regExpStr, flags + 'g');
          },
          firstMatch: function(regExp, input) {
            regExp.lastIndex = 0;
            return regExp.exec(input);
          },
          test: function(regExp, input) {
            return regExp.test(input);
          },
          matcher: function(regExp, input) {
            regExp.lastIndex = 0;
            return {
              re: regExp,
              input: input
            };
          }
        });
      }());
      $__export("RegExpWrapper", RegExpWrapper);
      RegExpMatcherWrapper = (function() {
        function RegExpMatcherWrapper() {}
        return ($traceurRuntime.createClass)(RegExpMatcherWrapper, {}, {next: function(matcher) {
            return matcher.re.exec(matcher.input);
          }});
      }());
      $__export("RegExpMatcherWrapper", RegExpMatcherWrapper);
      FunctionWrapper = (function() {
        function FunctionWrapper() {}
        return ($traceurRuntime.createClass)(FunctionWrapper, {}, {apply: function(fn, posArgs) {
            return fn.apply(null, posArgs);
          }});
      }());
      $__export("FunctionWrapper", FunctionWrapper);
      Json = (function() {
        function Json() {}
        return ($traceurRuntime.createClass)(Json, {}, {
          parse: function(s) {
            return _global.JSON.parse(s);
          },
          stringify: function(data) {
            return _global.JSON.stringify(data, null, 2);
          }
        });
      }());
      $__export("Json", Json);
      DateWrapper = (function() {
        function DateWrapper() {}
        return ($traceurRuntime.createClass)(DateWrapper, {}, {
          create: function(year) {
            var month = arguments[1] !== (void 0) ? arguments[1] : 1;
            var day = arguments[2] !== (void 0) ? arguments[2] : 1;
            var hour = arguments[3] !== (void 0) ? arguments[3] : 0;
            var minutes = arguments[4] !== (void 0) ? arguments[4] : 0;
            var seconds = arguments[5] !== (void 0) ? arguments[5] : 0;
            var milliseconds = arguments[6] !== (void 0) ? arguments[6] : 0;
            return new Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
          },
          fromMillis: function(ms) {
            return new Date(ms);
          },
          toMillis: function(date) {
            return date.getTime();
          },
          now: function() {
            return new Date();
          },
          toJson: function(date) {
            return date.toJSON();
          }
        });
      }());
      $__export("DateWrapper", DateWrapper);
    }
  };
});

System.register("angular2/src/util/decorators", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/util/decorators";
  var global,
      isFunction,
      stringify,
      Reflect;
  function extractAnnotation(annotation) {
    if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
      annotation = annotation.annotation;
    }
    return annotation;
  }
  function applyParams(fnOrArray, key) {
    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function || fnOrArray === Number || fnOrArray === Array) {
      throw new Error(("Can not use native " + stringify(fnOrArray) + " as constructor"));
    }
    if (isFunction(fnOrArray)) {
      return fnOrArray;
    } else if (fnOrArray instanceof Array) {
      var annotations = fnOrArray;
      var fn = fnOrArray[fnOrArray.length - 1];
      if (!isFunction(fn)) {
        throw new Error(("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'"));
      }
      var annoLength = annotations.length - 1;
      if (annoLength != fn.length) {
        throw new Error(("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn)));
      }
      var paramsAnnotations = [];
      for (var i = 0,
          ii = annotations.length - 1; i < ii; i++) {
        var paramAnnotations = [];
        paramsAnnotations.push(paramAnnotations);
        var annotation = annotations[i];
        if (annotation instanceof Array) {
          for (var j = 0; j < annotation.length; j++) {
            paramAnnotations.push(extractAnnotation(annotation[j]));
          }
        } else if (isFunction(annotation)) {
          paramAnnotations.push(extractAnnotation(annotation));
        } else {
          paramAnnotations.push(annotation);
        }
      }
      Reflect.defineMetadata('parameters', paramsAnnotations, fn);
      return fn;
    } else {
      throw new Error(("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'"));
    }
  }
  function Class(clsDef) {
    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
    var proto = constructor.prototype;
    if (clsDef.hasOwnProperty('extends')) {
      if (isFunction(clsDef.extends)) {
        constructor.prototype = proto = Object.create(clsDef.extends.prototype);
      } else {
        throw new Error(("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends)));
      }
    }
    for (var key in clsDef) {
      if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
        proto[key] = applyParams(clsDef[key], key);
      }
    }
    if (this && this.annotations instanceof Array) {
      Reflect.defineMetadata('annotations', this.annotations, constructor);
    }
    return constructor;
  }
  function makeDecorator(annotationCls) {
    var chainFn = arguments[1] !== (void 0) ? arguments[1] : null;
    function DecoratorFactory(objOrType) {
      var annotationInstance = new annotationCls(objOrType);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
        chainAnnotation.push(annotationInstance);
        var TypeDecorator = function TypeDecorator(cls) {
          var annotations = Reflect.getMetadata('annotations', cls);
          annotations = annotations || [];
          annotations.push(annotationInstance);
          Reflect.defineMetadata('annotations', annotations, cls);
          return cls;
        };
        TypeDecorator.annotations = chainAnnotation;
        TypeDecorator.Class = Class;
        if (chainFn)
          chainFn(TypeDecorator);
        return TypeDecorator;
      }
    }
    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return DecoratorFactory;
  }
  function makeParamDecorator(annotationCls) {
    function ParamDecoratorFactory() {
      for (var args = [],
          $__0 = 0; $__0 < arguments.length; $__0++)
        args[$__0] = arguments[$__0];
      var annotationInstance = Object.create(annotationCls.prototype);
      annotationCls.apply(annotationInstance, args);
      if (this instanceof annotationCls) {
        return annotationInstance;
      } else {
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
      }
      function ParamDecorator(cls, unusedKey, index) {
        var parameters = Reflect.getMetadata('parameters', cls);
        parameters = parameters || [];
        while (parameters.length <= index) {
          parameters.push(null);
        }
        parameters[index] = parameters[index] || [];
        var annotationsForParam = parameters[index];
        annotationsForParam.push(annotationInstance);
        Reflect.defineMetadata('parameters', parameters, cls);
        return cls;
      }
    }
    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
    return ParamDecoratorFactory;
  }
  $__export("Class", Class);
  $__export("makeDecorator", makeDecorator);
  $__export("makeParamDecorator", makeParamDecorator);
  return {
    setters: [function($__m) {
      global = $__m.global;
      isFunction = $__m.isFunction;
      stringify = $__m.stringify;
    }],
    execute: function() {
      Reflect = global.Reflect;
      if (!(Reflect && Reflect.getMetadata)) {
        throw 'reflect-metadata shim is required when using class decorators';
      }
    }
  };
});

System.register("angular2/src/di/forward_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/forward_ref";
  var stringify,
      isFunction;
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    if (isFunction(type) && type.hasOwnProperty('__forward_ref__') && type.__forward_ref__ === forwardRef) {
      return type();
    } else {
      return type;
    }
  }
  $__export("forwardRef", forwardRef);
  $__export("resolveForwardRef", resolveForwardRef);
  return {
    setters: [function($__m) {
      stringify = $__m.stringify;
      isFunction = $__m.isFunction;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/facade/collection", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/collection";
  var isJsObject,
      global,
      isPresent,
      isArray,
      List,
      Map,
      Set,
      StringMap,
      createMapFromPairs,
      createMapFromMap,
      _clearValues,
      MapWrapper,
      StringMapWrapper,
      ListWrapper,
      createSetFromList,
      SetWrapper;
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return isArray(obj) || (!(obj instanceof Map) && Symbol.iterator in obj);
  }
  function iterateListLike(obj, fn) {
    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        fn(obj[i]);
      }
    } else {
      var iterator = obj[Symbol.iterator]();
      var item;
      while (!((item = iterator.next()).done)) {
        fn(item.value);
      }
    }
  }
  $__export("isListLikeIterable", isListLikeIterable);
  $__export("iterateListLike", iterateListLike);
  return {
    setters: [function($__m) {
      isJsObject = $__m.isJsObject;
      global = $__m.global;
      isPresent = $__m.isPresent;
      isArray = $__m.isArray;
    }],
    execute: function() {
      List = global.Array;
      $__export("List", List);
      Map = global.Map;
      $__export("Map", Map);
      Set = global.Set;
      $__export("Set", Set);
      StringMap = global.Object;
      $__export("StringMap", StringMap);
      createMapFromPairs = (function() {
        try {
          if (new Map([1, 2]).size === 2) {
            return function createMapFromPairs(pairs) {
              return new Map(pairs);
            };
          }
        } catch (e) {}
        return function createMapAndPopulateFromPairs(pairs) {
          var map = new Map();
          for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i];
            map.set(pair[0], pair[1]);
          }
          return map;
        };
      })();
      createMapFromMap = (function() {
        try {
          if (new Map(new Map())) {
            return function createMapFromMap(m) {
              return new Map(m);
            };
          }
        } catch (e) {}
        return function createMapAndPopulateFromMap(m) {
          var map = new Map();
          m.forEach((function(v, k) {
            map.set(k, v);
          }));
          return map;
        };
      })();
      _clearValues = (function() {
        if ((new Map()).keys().next) {
          return function _clearValues(m) {
            var keyIterator = m.keys();
            var k;
            while (!((k = keyIterator.next()).done)) {
              m.set(k.value, null);
            }
          };
        } else {
          return function _clearValuesWithForeEach(m) {
            m.forEach((function(v, k) {
              m.set(k, null);
            }));
          };
        }
      })();
      MapWrapper = (function() {
        function MapWrapper() {}
        return ($traceurRuntime.createClass)(MapWrapper, {}, {
          clone: function(m) {
            return createMapFromMap(m);
          },
          createFromStringMap: function(stringMap) {
            var result = new Map();
            for (var prop in stringMap) {
              result.set(prop, stringMap[prop]);
            }
            return result;
          },
          toStringMap: function(m) {
            var r = {};
            m.forEach((function(v, k) {
              return r[k] = v;
            }));
            return r;
          },
          createFromPairs: function(pairs) {
            return createMapFromPairs(pairs);
          },
          forEach: function(m, fn) {
            m.forEach(fn);
          },
          get: function(map, key) {
            return map.get(key);
          },
          size: function(m) {
            return m.size;
          },
          delete: function(m, k) {
            m.delete(k);
          },
          clearValues: function(m) {
            _clearValues(m);
          },
          iterable: function(m) {
            return m;
          },
          keys: function(m) {
            return Array.from(m.keys());
          },
          values: function(m) {
            return Array.from(m.values());
          }
        });
      }());
      $__export("MapWrapper", MapWrapper);
      StringMapWrapper = (function() {
        function StringMapWrapper() {}
        return ($traceurRuntime.createClass)(StringMapWrapper, {}, {
          create: function() {
            return {};
          },
          contains: function(map, key) {
            return map.hasOwnProperty(key);
          },
          get: function(map, key) {
            return map.hasOwnProperty(key) ? map[key] : undefined;
          },
          set: function(map, key, value) {
            map[key] = value;
          },
          keys: function(map) {
            return Object.keys(map);
          },
          isEmpty: function(map) {
            for (var prop in map) {
              return false;
            }
            return true;
          },
          delete: function(map, key) {
            delete map[key];
          },
          forEach: function(map, callback) {
            for (var prop in map) {
              if (map.hasOwnProperty(prop)) {
                callback(map[prop], prop);
              }
            }
          },
          merge: function(m1, m2) {
            var m = {};
            for (var attr in m1) {
              if (m1.hasOwnProperty(attr)) {
                m[attr] = m1[attr];
              }
            }
            for (var attr in m2) {
              if (m2.hasOwnProperty(attr)) {
                m[attr] = m2[attr];
              }
            }
            return m;
          },
          equals: function(m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
              return false;
            }
            var key;
            for (var i = 0; i < k1.length; i++) {
              key = k1[i];
              if (m1[key] !== m2[key]) {
                return false;
              }
            }
            return true;
          }
        });
      }());
      $__export("StringMapWrapper", StringMapWrapper);
      ListWrapper = (function() {
        function ListWrapper() {}
        return ($traceurRuntime.createClass)(ListWrapper, {}, {
          createFixedSize: function(size) {
            return new List(size);
          },
          createGrowableSize: function(size) {
            return new List(size);
          },
          get: function(m, k) {
            return m[k];
          },
          set: function(m, k, v) {
            m[k] = v;
          },
          clone: function(array) {
            return array.slice(0);
          },
          map: function(array, fn) {
            return array.map(fn);
          },
          forEach: function(array, fn) {
            for (var i = 0; i < array.length; i++) {
              fn(array[i]);
            }
          },
          first: function(array) {
            if (!array)
              return null;
            return array[0];
          },
          last: function(array) {
            if (!array || array.length == 0)
              return null;
            return array[array.length - 1];
          },
          find: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return list[i];
            }
            return null;
          },
          indexOf: function(array, value) {
            var startIndex = arguments[2] !== (void 0) ? arguments[2] : 0;
            return array.indexOf(value, startIndex);
          },
          reduce: function(list, fn, init) {
            return list.reduce(fn, init);
          },
          filter: function(array, pred) {
            return array.filter(pred);
          },
          any: function(list, pred) {
            for (var i = 0; i < list.length; ++i) {
              if (pred(list[i]))
                return true;
            }
            return false;
          },
          contains: function(list, el) {
            return list.indexOf(el) !== -1;
          },
          reversed: function(array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
          },
          concat: function(a, b) {
            return a.concat(b);
          },
          insert: function(list, index, value) {
            list.splice(index, 0, value);
          },
          removeAt: function(list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
          },
          removeAll: function(list, items) {
            for (var i = 0; i < items.length; ++i) {
              var index = list.indexOf(items[i]);
              list.splice(index, 1);
            }
          },
          removeLast: function(list) {
            return list.pop();
          },
          remove: function(list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
              list.splice(index, 1);
              return true;
            }
            return false;
          },
          clear: function(list) {
            list.splice(0, list.length);
          },
          join: function(list, s) {
            return list.join(s);
          },
          isEmpty: function(list) {
            return list.length == 0;
          },
          fill: function(list, value) {
            var start = arguments[2] !== (void 0) ? arguments[2] : 0;
            var end = arguments[3] !== (void 0) ? arguments[3] : null;
            list.fill(value, start, end === null ? undefined : end);
          },
          equals: function(a, b) {
            if (a.length != b.length)
              return false;
            for (var i = 0; i < a.length; ++i) {
              if (a[i] !== b[i])
                return false;
            }
            return true;
          },
          slice: function(l) {
            var from = arguments[1] !== (void 0) ? arguments[1] : 0;
            var to = arguments[2] !== (void 0) ? arguments[2] : null;
            return l.slice(from, to === null ? undefined : to);
          },
          splice: function(l, from, length) {
            return l.splice(from, length);
          },
          sort: function(l, compareFn) {
            if (isPresent(compareFn)) {
              l.sort(compareFn);
            } else {
              l.sort();
            }
          },
          toString: function(l) {
            return l.toString();
          },
          toJSON: function(l) {
            return JSON.stringify(l);
          }
        });
      }());
      $__export("ListWrapper", ListWrapper);
      createSetFromList = (function() {
        var test = new Set([1, 2, 3]);
        if (test.size === 3) {
          return function createSetFromList(lst) {
            return new Set(lst);
          };
        } else {
          return function createSetAndPopulateFromList(lst) {
            var res = new Set(lst);
            if (res.size !== lst.length) {
              for (var i = 0; i < lst.length; i++) {
                res.add(lst[i]);
              }
            }
            return res;
          };
        }
      })();
      SetWrapper = (function() {
        function SetWrapper() {}
        return ($traceurRuntime.createClass)(SetWrapper, {}, {
          createFromList: function(lst) {
            return createSetFromList(lst);
          },
          has: function(s, key) {
            return s.has(key);
          },
          delete: function(m, k) {
            m.delete(k);
          }
        });
      }());
      $__export("SetWrapper", SetWrapper);
    }
  };
});

System.register("angular2/src/reflection/reflector", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflector";
  var isPresent,
      Map,
      StringMapWrapper,
      ReflectionInfo,
      Reflector;
  function _mergeMaps(target, config) {
    StringMapWrapper.forEach(config, (function(v, k) {
      return target.set(k, v);
    }));
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      ReflectionInfo = (function() {
        function ReflectionInfo(annotations, parameters, factory, interfaces) {
          this._annotations = annotations;
          this._parameters = parameters;
          this._factory = factory;
          this._interfaces = interfaces;
        }
        return ($traceurRuntime.createClass)(ReflectionInfo, {}, {});
      }());
      $__export("ReflectionInfo", ReflectionInfo);
      Reflector = (function() {
        function Reflector(reflectionCapabilities) {
          this._injectableInfo = new Map();
          this._getters = new Map();
          this._setters = new Map();
          this._methods = new Map();
          this.reflectionCapabilities = reflectionCapabilities;
        }
        return ($traceurRuntime.createClass)(Reflector, {
          isReflectionEnabled: function() {
            return this.reflectionCapabilities.isReflectionEnabled();
          },
          registerFunction: function(func, funcInfo) {
            this._injectableInfo.set(func, funcInfo);
          },
          registerType: function(type, typeInfo) {
            this._injectableInfo.set(type, typeInfo);
          },
          registerGetters: function(getters) {
            _mergeMaps(this._getters, getters);
          },
          registerSetters: function(setters) {
            _mergeMaps(this._setters, setters);
          },
          registerMethods: function(methods) {
            _mergeMaps(this._methods, methods);
          },
          factory: function(type) {
            if (this._containsReflectionInfo(type)) {
              var res = this._injectableInfo.get(type)._factory;
              return isPresent(res) ? res : null;
            } else {
              return this.reflectionCapabilities.factory(type);
            }
          },
          parameters: function(typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
              var res = this._injectableInfo.get(typeOrFunc)._parameters;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.parameters(typeOrFunc);
            }
          },
          annotations: function(typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
              var res = this._injectableInfo.get(typeOrFunc)._annotations;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.annotations(typeOrFunc);
            }
          },
          interfaces: function(type) {
            if (this._injectableInfo.has(type)) {
              var res = this._injectableInfo.get(type)._interfaces;
              return isPresent(res) ? res : [];
            } else {
              return this.reflectionCapabilities.interfaces(type);
            }
          },
          getter: function(name) {
            if (this._getters.has(name)) {
              return this._getters.get(name);
            } else {
              return this.reflectionCapabilities.getter(name);
            }
          },
          setter: function(name) {
            if (this._setters.has(name)) {
              return this._setters.get(name);
            } else {
              return this.reflectionCapabilities.setter(name);
            }
          },
          method: function(name) {
            if (this._methods.has(name)) {
              return this._methods.get(name);
            } else {
              return this.reflectionCapabilities.method(name);
            }
          },
          _containsReflectionInfo: function(typeOrFunc) {
            return this._injectableInfo.has(typeOrFunc);
          }
        }, {});
      }());
      $__export("Reflector", Reflector);
    }
  };
});

System.register("angular2/src/reflection/reflection_capabilities", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection_capabilities";
  var isPresent,
      isFunction,
      global,
      stringify,
      BaseException,
      ListWrapper,
      ReflectionCapabilities;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isFunction = $__m.isFunction;
      global = $__m.global;
      stringify = $__m.stringify;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      ReflectionCapabilities = (function() {
        function ReflectionCapabilities(reflect) {
          this._reflect = isPresent(reflect) ? reflect : global.Reflect;
        }
        return ($traceurRuntime.createClass)(ReflectionCapabilities, {
          isReflectionEnabled: function() {
            return true;
          },
          factory: function(t) {
            switch (t.length) {
              case 0:
                return (function() {
                  return new t();
                });
              case 1:
                return (function(a1) {
                  return new t(a1);
                });
              case 2:
                return (function(a1, a2) {
                  return new t(a1, a2);
                });
              case 3:
                return (function(a1, a2, a3) {
                  return new t(a1, a2, a3);
                });
              case 4:
                return (function(a1, a2, a3, a4) {
                  return new t(a1, a2, a3, a4);
                });
              case 5:
                return (function(a1, a2, a3, a4, a5) {
                  return new t(a1, a2, a3, a4, a5);
                });
              case 6:
                return (function(a1, a2, a3, a4, a5, a6) {
                  return new t(a1, a2, a3, a4, a5, a6);
                });
              case 7:
                return (function(a1, a2, a3, a4, a5, a6, a7) {
                  return new t(a1, a2, a3, a4, a5, a6, a7);
                });
              case 8:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8);
                });
              case 9:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9);
                });
              case 10:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
                });
              case 11:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
                });
              case 12:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
                });
              case 13:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
                });
              case 14:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
                });
              case 15:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
                });
              case 16:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
                });
              case 17:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
                });
              case 18:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
                });
              case 19:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
                });
              case 20:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
                  return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
                });
            }
            ;
            throw new Error(("Cannot create a factory for '" + stringify(t) + "' because its constructor has more than 20 arguments"));
          },
          _zipTypesAndAnnotaions: function(paramTypes, paramAnnotations) {
            var result;
            if (typeof paramTypes === 'undefined') {
              result = ListWrapper.createFixedSize(paramAnnotations.length);
            } else {
              result = ListWrapper.createFixedSize(paramTypes.length);
            }
            for (var i = 0; i < result.length; i++) {
              if (typeof paramTypes === 'undefined') {
                result[i] = [];
              } else if (paramTypes[i] != Object) {
                result[i] = [paramTypes[i]];
              } else {
                result[i] = [];
              }
              if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
                result[i] = result[i].concat(paramAnnotations[i]);
              }
            }
            return result;
          },
          parameters: function(typeOfFunc) {
            if (isPresent(typeOfFunc.parameters)) {
              return typeOfFunc.parameters;
            }
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
              var paramAnnotations = this._reflect.getMetadata('parameters', typeOfFunc);
              var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOfFunc);
              if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
              }
            }
            return ListWrapper.createFixedSize(typeOfFunc.length);
          },
          annotations: function(typeOfFunc) {
            if (isPresent(typeOfFunc.annotations)) {
              var annotations = typeOfFunc.annotations;
              if (isFunction(annotations) && annotations.annotations) {
                annotations = annotations.annotations;
              }
              return annotations;
            }
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
              var annotations = this._reflect.getMetadata('annotations', typeOfFunc);
              if (isPresent(annotations))
                return annotations;
            }
            return [];
          },
          interfaces: function(type) {
            throw new BaseException("JavaScript does not support interfaces");
          },
          getter: function(name) {
            return new Function('o', 'return o.' + name + ';');
          },
          setter: function(name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
          },
          method: function(name) {
            var functionBody = ("if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);");
            return new Function('o', 'args', functionBody);
          }
        }, {});
      }());
      $__export("ReflectionCapabilities", ReflectionCapabilities);
    }
  };
});

System.register("angular2/src/di/type_literal", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/type_literal";
  var TypeLiteral;
  return {
    setters: [],
    execute: function() {
      TypeLiteral = (function() {
        function TypeLiteral() {}
        return ($traceurRuntime.createClass)(TypeLiteral, {get type() {
            throw new Error("Type literals are only supported in Dart");
          }}, {});
      }());
      $__export("TypeLiteral", TypeLiteral);
    }
  };
});

System.register("angular2/src/di/exceptions", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/exceptions";
  var ListWrapper,
      stringify,
      BaseException,
      isBlank,
      AbstractBindingError,
      NoBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      NoAnnotationError,
      OutOfBoundsError;
  function findFirstClosedCycle(keys) {
    var res = [];
    for (var i = 0; i < keys.length; ++i) {
      if (ListWrapper.contains(res, keys[i])) {
        res.push(keys[i]);
        return res;
      } else {
        res.push(keys[i]);
      }
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
      var tokenStrs = ListWrapper.map(reversed, (function(k) {
        return stringify(k.token);
      }));
      return " (" + tokenStrs.join(' -> ') + ")";
    } else {
      return "";
    }
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      AbstractBindingError = (function($__super) {
        function AbstractBindingError(injector, key, constructResolvingMessage, originalException, originalStack) {
          $traceurRuntime.superConstructor(AbstractBindingError).call(this, "DI Exception", originalException, originalStack, null);
          this.keys = [key];
          this.injectors = [injector];
          this.constructResolvingMessage = constructResolvingMessage;
          this.message = this.constructResolvingMessage(this.keys);
        }
        return ($traceurRuntime.createClass)(AbstractBindingError, {
          addKey: function(injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
          },
          get context() {
            return this.injectors[this.injectors.length - 1].debugContext();
          },
          toString: function() {
            return this.message;
          }
        }, {}, $__super);
      }(BaseException));
      $__export("AbstractBindingError", AbstractBindingError);
      NoBindingError = (function($__super) {
        function NoBindingError(injector, key) {
          $traceurRuntime.superConstructor(NoBindingError).call(this, injector, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("No provider for " + first + "!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(NoBindingError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("NoBindingError", NoBindingError);
      CyclicDependencyError = (function($__super) {
        function CyclicDependencyError(injector, key) {
          $traceurRuntime.superConstructor(CyclicDependencyError).call(this, injector, key, function(keys) {
            return ("Cannot instantiate cyclic dependency!" + constructResolvingPath(keys));
          });
        }
        return ($traceurRuntime.createClass)(CyclicDependencyError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("CyclicDependencyError", CyclicDependencyError);
      InstantiationError = (function($__super) {
        function InstantiationError(injector, originalException, originalStack, key) {
          $traceurRuntime.superConstructor(InstantiationError).call(this, injector, key, function(keys) {
            var first = stringify(ListWrapper.first(keys).token);
            return ("Error during instantiation of " + first + "!" + constructResolvingPath(keys) + ".");
          }, originalException, originalStack);
          this.causeKey = key;
        }
        return ($traceurRuntime.createClass)(InstantiationError, {}, {}, $__super);
      }(AbstractBindingError));
      $__export("InstantiationError", InstantiationError);
      InvalidBindingError = (function($__super) {
        function InvalidBindingError(binding) {
          $traceurRuntime.superConstructor(InvalidBindingError).call(this);
          this.message = "Invalid binding - only instances of Binding and Type are allowed, got: " + binding.toString();
        }
        return ($traceurRuntime.createClass)(InvalidBindingError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("InvalidBindingError", InvalidBindingError);
      NoAnnotationError = (function($__super) {
        function NoAnnotationError(typeOrFunc, params) {
          $traceurRuntime.superConstructor(NoAnnotationError).call(this);
          var signature = [];
          for (var i = 0,
              ii = params.length; i < ii; i++) {
            var parameter = params[i];
            if (isBlank(parameter) || parameter.length == 0) {
              signature.push('?');
            } else {
              signature.push(ListWrapper.map(parameter, stringify).join(' '));
            }
          }
          this.message = "Cannot resolve all parameters for " + stringify(typeOrFunc) + "(" + signature.join(', ') + "). " + 'Make sure they all have valid type or annotations.';
        }
        return ($traceurRuntime.createClass)(NoAnnotationError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("NoAnnotationError", NoAnnotationError);
      OutOfBoundsError = (function($__super) {
        function OutOfBoundsError(index) {
          $traceurRuntime.superConstructor(OutOfBoundsError).call(this);
          this.message = ("Index " + index + " is out-of-bounds.");
        }
        return ($traceurRuntime.createClass)(OutOfBoundsError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("OutOfBoundsError", OutOfBoundsError);
    }
  };
});

System.register("angular2/src/di/opaque_token", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/opaque_token";
  var __decorate,
      __metadata,
      CONST,
      OpaqueToken;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      OpaqueToken = (($traceurRuntime.createClass)(function(desc) {
        this._desc = 'Token(' + desc + ')';
      }, {toString: function() {
          return this._desc;
        }}, {}));
      $__export("OpaqueToken", OpaqueToken);
      $__export("OpaqueToken", OpaqueToken = __decorate([CONST(), __metadata('design:paramtypes', [String])], OpaqueToken));
    }
  };
});

System.register("angular2/src/dom/dom_adapter", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/dom_adapter";
  var BaseException,
      isBlank,
      DOM,
      DomAdapter;
  function setRootDomAdapter(adapter) {
    if (isBlank(DOM)) {
      $__export("DOM", DOM = adapter);
    }
  }
  function _abstract() {
    return new BaseException('This method is abstract');
  }
  $__export("setRootDomAdapter", setRootDomAdapter);
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      $__export("DOM", DOM);
      DomAdapter = (function() {
        function DomAdapter() {}
        return ($traceurRuntime.createClass)(DomAdapter, {
          hasProperty: function(element, name) {
            throw _abstract();
          },
          setProperty: function(el, name, value) {
            throw _abstract();
          },
          getProperty: function(el, name) {
            throw _abstract();
          },
          invoke: function(el, methodName, args) {
            throw _abstract();
          },
          logError: function(error) {
            throw _abstract();
          },
          log: function(error) {
            throw _abstract();
          },
          logGroup: function(error) {
            throw _abstract();
          },
          logGroupEnd: function() {
            throw _abstract();
          },
          get attrToPropMap() {
            throw _abstract();
          },
          parse: function(templateHtml) {
            throw _abstract();
          },
          query: function(selector) {
            throw _abstract();
          },
          querySelector: function(el, selector) {
            throw _abstract();
          },
          querySelectorAll: function(el, selector) {
            throw _abstract();
          },
          on: function(el, evt, listener) {
            throw _abstract();
          },
          onAndCancel: function(el, evt, listener) {
            throw _abstract();
          },
          dispatchEvent: function(el, evt) {
            throw _abstract();
          },
          createMouseEvent: function(eventType) {
            throw _abstract();
          },
          createEvent: function(eventType) {
            throw _abstract();
          },
          preventDefault: function(evt) {
            throw _abstract();
          },
          getInnerHTML: function(el) {
            throw _abstract();
          },
          getOuterHTML: function(el) {
            throw _abstract();
          },
          nodeName: function(node) {
            throw _abstract();
          },
          nodeValue: function(node) {
            throw _abstract();
          },
          type: function(node) {
            throw _abstract();
          },
          content: function(node) {
            throw _abstract();
          },
          firstChild: function(el) {
            throw _abstract();
          },
          nextSibling: function(el) {
            throw _abstract();
          },
          parentElement: function(el) {
            throw _abstract();
          },
          childNodes: function(el) {
            throw _abstract();
          },
          childNodesAsList: function(el) {
            throw _abstract();
          },
          clearNodes: function(el) {
            throw _abstract();
          },
          appendChild: function(el, node) {
            throw _abstract();
          },
          removeChild: function(el, node) {
            throw _abstract();
          },
          replaceChild: function(el, newNode, oldNode) {
            throw _abstract();
          },
          remove: function(el) {
            throw _abstract();
          },
          insertBefore: function(el, node) {
            throw _abstract();
          },
          insertAllBefore: function(el, nodes) {
            throw _abstract();
          },
          insertAfter: function(el, node) {
            throw _abstract();
          },
          setInnerHTML: function(el, value) {
            throw _abstract();
          },
          getText: function(el) {
            throw _abstract();
          },
          setText: function(el, value) {
            throw _abstract();
          },
          getValue: function(el) {
            throw _abstract();
          },
          setValue: function(el, value) {
            throw _abstract();
          },
          getChecked: function(el) {
            throw _abstract();
          },
          setChecked: function(el, value) {
            throw _abstract();
          },
          createTemplate: function(html) {
            throw _abstract();
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : null;
            throw _abstract();
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : null;
            throw _abstract();
          },
          createShadowRoot: function(el) {
            throw _abstract();
          },
          getShadowRoot: function(el) {
            throw _abstract();
          },
          getHost: function(el) {
            throw _abstract();
          },
          getDistributedNodes: function(el) {
            throw _abstract();
          },
          clone: function(node) {
            throw _abstract();
          },
          getElementsByClassName: function(element, name) {
            throw _abstract();
          },
          getElementsByTagName: function(element, name) {
            throw _abstract();
          },
          classList: function(element) {
            throw _abstract();
          },
          addClass: function(element, classname) {
            throw _abstract();
          },
          removeClass: function(element, classname) {
            throw _abstract();
          },
          hasClass: function(element, classname) {
            throw _abstract();
          },
          setStyle: function(element, stylename, stylevalue) {
            throw _abstract();
          },
          removeStyle: function(element, stylename) {
            throw _abstract();
          },
          getStyle: function(element, stylename) {
            throw _abstract();
          },
          tagName: function(element) {
            throw _abstract();
          },
          attributeMap: function(element) {
            throw _abstract();
          },
          hasAttribute: function(element, attribute) {
            throw _abstract();
          },
          getAttribute: function(element, attribute) {
            throw _abstract();
          },
          setAttribute: function(element, name, value) {
            throw _abstract();
          },
          removeAttribute: function(element, attribute) {
            throw _abstract();
          },
          templateAwareRoot: function(el) {
            throw _abstract();
          },
          createHtmlDocument: function() {
            throw _abstract();
          },
          defaultDoc: function() {
            throw _abstract();
          },
          getBoundingClientRect: function(el) {
            throw _abstract();
          },
          getTitle: function() {
            throw _abstract();
          },
          setTitle: function(newTitle) {
            throw _abstract();
          },
          elementMatches: function(n, selector) {
            throw _abstract();
          },
          isTemplateElement: function(el) {
            throw _abstract();
          },
          isTextNode: function(node) {
            throw _abstract();
          },
          isCommentNode: function(node) {
            throw _abstract();
          },
          isElementNode: function(node) {
            throw _abstract();
          },
          hasShadowRoot: function(node) {
            throw _abstract();
          },
          isShadowRoot: function(node) {
            throw _abstract();
          },
          importIntoDoc: function(node) {
            throw _abstract();
          },
          isPageRule: function(rule) {
            throw _abstract();
          },
          isStyleRule: function(rule) {
            throw _abstract();
          },
          isMediaRule: function(rule) {
            throw _abstract();
          },
          isKeyframesRule: function(rule) {
            throw _abstract();
          },
          getHref: function(element) {
            throw _abstract();
          },
          getEventKey: function(event) {
            throw _abstract();
          },
          resolveAndSetHref: function(element, baseUrl, href) {
            throw _abstract();
          },
          cssToRules: function(css) {
            throw _abstract();
          },
          supportsDOMEvents: function() {
            throw _abstract();
          },
          supportsNativeShadowDOM: function() {
            throw _abstract();
          },
          getGlobalEventTarget: function(target) {
            throw _abstract();
          },
          getHistory: function() {
            throw _abstract();
          },
          getLocation: function() {
            throw _abstract();
          },
          getBaseHref: function() {
            throw _abstract();
          },
          getUserAgent: function() {
            throw _abstract();
          },
          setData: function(element, name, value) {
            throw _abstract();
          },
          getData: function(element, name) {
            throw _abstract();
          },
          setGlobalVar: function(name, value) {
            throw _abstract();
          }
        }, {});
      }());
      $__export("DomAdapter", DomAdapter);
    }
  };
});

System.register("angular2/src/dom/generic_browser_adapter", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/generic_browser_adapter";
  var ListWrapper,
      isPresent,
      isFunction,
      DomAdapter,
      GenericBrowserDomAdapter;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isFunction = $__m.isFunction;
    }, function($__m) {
      DomAdapter = $__m.DomAdapter;
    }],
    execute: function() {
      GenericBrowserDomAdapter = (function($__super) {
        function GenericBrowserDomAdapter() {
          $traceurRuntime.superConstructor(GenericBrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(GenericBrowserDomAdapter, {
          getDistributedNodes: function(el) {
            return el.getDistributedNodes();
          },
          resolveAndSetHref: function(el, baseUrl, href) {
            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
          },
          cssToRules: function(css) {
            var style = this.createStyleElement(css);
            this.appendChild(this.defaultDoc().head, style);
            var rules = [];
            if (isPresent(style.sheet)) {
              try {
                var rawRules = style.sheet.cssRules;
                rules = ListWrapper.createFixedSize(rawRules.length);
                for (var i = 0; i < rawRules.length; i++) {
                  rules[i] = rawRules[i];
                }
              } catch (e) {}
            } else {}
            this.remove(style);
            return rules;
          },
          supportsDOMEvents: function() {
            return true;
          },
          supportsNativeShadowDOM: function() {
            return isFunction(this.defaultDoc().body.createShadowRoot);
          }
        }, {}, $__super);
      }(DomAdapter));
      $__export("GenericBrowserDomAdapter", GenericBrowserDomAdapter);
    }
  };
});

System.register("angular2/src/change_detection/constants", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/constants";
  var CHECK_ONCE,
      CHECKED,
      CHECK_ALWAYS,
      DETACHED,
      ON_PUSH,
      DEFAULT;
  return {
    setters: [],
    execute: function() {
      CHECK_ONCE = "CHECK_ONCE";
      $__export("CHECK_ONCE", CHECK_ONCE);
      CHECKED = "CHECKED";
      $__export("CHECKED", CHECKED);
      CHECK_ALWAYS = "ALWAYS_CHECK";
      $__export("CHECK_ALWAYS", CHECK_ALWAYS);
      DETACHED = "DETACHED";
      $__export("DETACHED", DETACHED);
      ON_PUSH = "ON_PUSH";
      $__export("ON_PUSH", ON_PUSH);
      DEFAULT = "DEFAULT";
      $__export("DEFAULT", DEFAULT);
    }
  };
});

System.register("angular2/src/change_detection/exceptions", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/exceptions";
  var BaseException,
      ExpressionChangedAfterItHasBeenCheckedException,
      ChangeDetectionError,
      DehydratedException;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ExpressionChangedAfterItHasBeenCheckedException = (function($__super) {
        function ExpressionChangedAfterItHasBeenCheckedException(proto, change, context) {
          $traceurRuntime.superConstructor(ExpressionChangedAfterItHasBeenCheckedException).call(this, ("Expression '" + proto.expressionAsString + "' has changed after it was checked. ") + ("Previous value: '" + change.previousValue + "'. Current value: '" + change.currentValue + "'"));
        }
        return ($traceurRuntime.createClass)(ExpressionChangedAfterItHasBeenCheckedException, {}, {}, $__super);
      }(BaseException));
      $__export("ExpressionChangedAfterItHasBeenCheckedException", ExpressionChangedAfterItHasBeenCheckedException);
      ChangeDetectionError = (function($__super) {
        function ChangeDetectionError(proto, originalException, originalStack, context) {
          $traceurRuntime.superConstructor(ChangeDetectionError).call(this, (originalException + " in [" + proto.expressionAsString + "]"), originalException, originalStack, context);
          this.location = proto.expressionAsString;
        }
        return ($traceurRuntime.createClass)(ChangeDetectionError, {}, {}, $__super);
      }(BaseException));
      $__export("ChangeDetectionError", ChangeDetectionError);
      DehydratedException = (function($__super) {
        function DehydratedException() {
          $traceurRuntime.superConstructor(DehydratedException).call(this, 'Attempt to detect changes on a dehydrated detector.');
        }
        return ($traceurRuntime.createClass)(DehydratedException, {}, {}, $__super);
      }(BaseException));
      $__export("DehydratedException", DehydratedException);
    }
  };
});

System.register("angular2/src/change_detection/pipes/pipe", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/pipe";
  var __decorate,
      __metadata,
      BaseException,
      CONST,
      WrappedValue,
      _wrappedValues,
      _wrappedIndex,
      BasePipe;
  function _abstract() {
    throw new BaseException('This method is abstract');
  }
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      WrappedValue = (function() {
        function WrappedValue(wrapped) {
          this.wrapped = wrapped;
        }
        return ($traceurRuntime.createClass)(WrappedValue, {}, {wrap: function(value) {
            var w = _wrappedValues[_wrappedIndex++ % 5];
            w.wrapped = value;
            return w;
          }});
      }());
      $__export("WrappedValue", WrappedValue);
      _wrappedValues = [new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null), new WrappedValue(null)];
      _wrappedIndex = 0;
      BasePipe = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return true;
        },
        onDestroy: function() {},
        transform: function(value, args) {
          return _abstract();
        }
      }, {}));
      $__export("BasePipe", BasePipe);
      $__export("BasePipe", BasePipe = __decorate([CONST(), __metadata('design:paramtypes', [])], BasePipe));
    }
  };
});

System.register("angular2/src/change_detection/proto_record", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_record";
  var RecordType,
      ProtoRecord;
  return {
    setters: [],
    execute: function() {
      $__export("RecordType", RecordType);
      (function(RecordType) {
        RecordType[RecordType["SELF"] = 0] = "SELF";
        RecordType[RecordType["CONST"] = 1] = "CONST";
        RecordType[RecordType["PRIMITIVE_OP"] = 2] = "PRIMITIVE_OP";
        RecordType[RecordType["PROPERTY"] = 3] = "PROPERTY";
        RecordType[RecordType["LOCAL"] = 4] = "LOCAL";
        RecordType[RecordType["INVOKE_METHOD"] = 5] = "INVOKE_METHOD";
        RecordType[RecordType["INVOKE_CLOSURE"] = 6] = "INVOKE_CLOSURE";
        RecordType[RecordType["KEYED_ACCESS"] = 7] = "KEYED_ACCESS";
        RecordType[RecordType["PIPE"] = 8] = "PIPE";
        RecordType[RecordType["INTERPOLATE"] = 9] = "INTERPOLATE";
        RecordType[RecordType["SAFE_PROPERTY"] = 10] = "SAFE_PROPERTY";
        RecordType[RecordType["SAFE_INVOKE_METHOD"] = 11] = "SAFE_INVOKE_METHOD";
        RecordType[RecordType["DIRECTIVE_LIFECYCLE"] = 12] = "DIRECTIVE_LIFECYCLE";
      })(RecordType || ($__export("RecordType", RecordType = {})));
      ProtoRecord = (function() {
        function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, expressionAsString, lastInBinding, lastInDirective) {
          this.mode = mode;
          this.name = name;
          this.funcOrValue = funcOrValue;
          this.args = args;
          this.fixedArgs = fixedArgs;
          this.contextIndex = contextIndex;
          this.directiveIndex = directiveIndex;
          this.selfIndex = selfIndex;
          this.bindingRecord = bindingRecord;
          this.expressionAsString = expressionAsString;
          this.lastInBinding = lastInBinding;
          this.lastInDirective = lastInDirective;
        }
        return ($traceurRuntime.createClass)(ProtoRecord, {
          isPureFunction: function() {
            return this.mode === RecordType.INTERPOLATE || this.mode === RecordType.PRIMITIVE_OP;
          },
          isPipeRecord: function() {
            return this.mode === RecordType.PIPE;
          },
          isLifeCycleRecord: function() {
            return this.mode === RecordType.DIRECTIVE_LIFECYCLE;
          }
        }, {});
      }());
      $__export("ProtoRecord", ProtoRecord);
    }
  };
});

System.register("angular2/src/change_detection/codegen_name_util", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/codegen_name_util";
  var RegExpWrapper,
      StringWrapper,
      ListWrapper,
      _CONTEXT_IDX,
      _whiteSpaceRegExp,
      CodegenNameUtil;
  function sanitizeName(s) {
    return StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
  }
  $__export("sanitizeName", sanitizeName);
  return {
    setters: [function($__m) {
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      _CONTEXT_IDX = 0;
      _whiteSpaceRegExp = RegExpWrapper.create("\\W", "g");
      CodegenNameUtil = (function() {
        function CodegenNameUtil(records, directiveRecords, fieldPrefix, utilName) {
          this.records = records;
          this.directiveRecords = directiveRecords;
          this.fieldPrefix = fieldPrefix;
          this.utilName = utilName;
          this._sanitizedNames = ListWrapper.createFixedSize(this.records.length + 1);
          this._sanitizedNames[_CONTEXT_IDX] = 'context';
          for (var i = 0,
              iLen = this.records.length; i < iLen; ++i) {
            this._sanitizedNames[i + 1] = sanitizeName(("" + this.records[i].name + i));
          }
        }
        return ($traceurRuntime.createClass)(CodegenNameUtil, {
          getContextName: function() {
            return this.getFieldName(_CONTEXT_IDX);
          },
          getLocalName: function(idx) {
            return this._sanitizedNames[idx];
          },
          getChangeName: function(idx) {
            return ("c_" + this._sanitizedNames[idx]);
          },
          genInitLocals: function() {
            var declarations = [];
            var assignments = [];
            for (var i = 0,
                iLen = this.getFieldCount(); i < iLen; ++i) {
              var changeName = this.getChangeName(i);
              declarations.push((this.getLocalName(i) + "," + changeName));
              assignments.push(changeName);
            }
            return ("var " + ListWrapper.join(declarations, ',') + ";") + (ListWrapper.join(assignments, '=') + " = false;");
          },
          getFieldCount: function() {
            return this._sanitizedNames.length;
          },
          getFieldName: function(idx) {
            return ("" + this.fieldPrefix + this._sanitizedNames[idx]);
          },
          getAllFieldNames: function() {
            var fieldList = [];
            for (var k = 0,
                kLen = this.getFieldCount(); k < kLen; ++k) {
              fieldList.push(this.getFieldName(k));
            }
            for (var i = 0,
                iLen = this.records.length; i < iLen; ++i) {
              var rec = this.records[i];
              if (rec.isPipeRecord()) {
                fieldList.push(this.getPipeName(rec.selfIndex));
              }
            }
            for (var j = 0,
                jLen = this.directiveRecords.length; j < jLen; ++j) {
              var dRec = this.directiveRecords[j];
              fieldList.push(this.getDirectiveName(dRec.directiveIndex));
              if (dRec.isOnPushChangeDetection()) {
                fieldList.push(this.getDetectorName(dRec.directiveIndex));
              }
            }
            return fieldList;
          },
          genDeclareFields: function() {
            var fields = this.getAllFieldNames();
            ListWrapper.removeAt(fields, _CONTEXT_IDX);
            return ListWrapper.isEmpty(fields) ? '' : ("var " + ListWrapper.join(fields, ', ') + ";");
          },
          genDehydrateFields: function() {
            var fields = this.getAllFieldNames();
            ListWrapper.removeAt(fields, _CONTEXT_IDX);
            if (!ListWrapper.isEmpty(fields)) {
              fields.push((this.utilName + ".uninitialized;"));
            }
            return (this.getContextName() + " = null; " + ListWrapper.join(fields, ' = '));
          },
          genPipeOnDestroy: function() {
            var $__0 = this;
            return ListWrapper.join(ListWrapper.map(ListWrapper.filter(this.records, (function(r) {
              return r.isPipeRecord();
            })), (function(r) {
              return ($__0.getPipeName(r.selfIndex) + ".onDestroy();");
            })), '\n');
          },
          getPipeName: function(idx) {
            return ("" + this.fieldPrefix + this._sanitizedNames[idx] + "_pipe");
          },
          getAllDirectiveNames: function() {
            var $__0 = this;
            return ListWrapper.map(this.directiveRecords, (function(d) {
              return $__0.getDirectiveName(d.directiveIndex);
            }));
          },
          getDirectiveName: function(d) {
            return (this.fieldPrefix + "directive_" + d.name);
          },
          getAllDetectorNames: function() {
            var $__0 = this;
            return ListWrapper.map(ListWrapper.filter(this.directiveRecords, (function(r) {
              return r.isOnPushChangeDetection();
            })), (function(d) {
              return $__0.getDetectorName(d.directiveIndex);
            }));
          },
          getDetectorName: function(d) {
            return (this.fieldPrefix + "detector_" + d.name);
          }
        }, {});
      }());
      $__export("CodegenNameUtil", CodegenNameUtil);
    }
  };
});

System.register("angular2/src/change_detection/coalesce", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/coalesce";
  var isPresent,
      isBlank,
      looseIdentical,
      ListWrapper,
      Map,
      RecordType,
      ProtoRecord;
  function coalesce(records) {
    var res = [];
    var indexMap = new Map();
    for (var i = 0; i < records.length; ++i) {
      var r = records[i];
      var record = _replaceIndices(r, res.length + 1, indexMap);
      var matchingRecord = _findMatching(record, res);
      if (isPresent(matchingRecord) && record.lastInBinding) {
        res.push(_selfRecord(record, matchingRecord.selfIndex, res.length + 1));
        indexMap.set(r.selfIndex, matchingRecord.selfIndex);
      } else if (isPresent(matchingRecord) && !record.lastInBinding) {
        indexMap.set(r.selfIndex, matchingRecord.selfIndex);
      } else {
        res.push(record);
        indexMap.set(r.selfIndex, record.selfIndex);
      }
    }
    return res;
  }
  function _selfRecord(r, contextIndex, selfIndex) {
    return new ProtoRecord(RecordType.SELF, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
  }
  function _findMatching(r, rs) {
    return ListWrapper.find(rs, (function(rr) {
      return rr.mode !== RecordType.DIRECTIVE_LIFECYCLE && _sameDirIndex(rr, r) && rr.mode === r.mode && looseIdentical(rr.funcOrValue, r.funcOrValue) && rr.contextIndex === r.contextIndex && looseIdentical(rr.name, r.name) && ListWrapper.equals(rr.args, r.args);
    }));
  }
  function _sameDirIndex(a, b) {
    var di1 = isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;
    var ei1 = isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;
    var di2 = isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;
    var ei2 = isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;
    return di1 === di2 && ei1 === ei2;
  }
  function _replaceIndices(r, selfIndex, indexMap) {
    var args = ListWrapper.map(r.args, (function(a) {
      return _map(indexMap, a);
    }));
    var contextIndex = _map(indexMap, r.contextIndex);
    return new ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.expressionAsString, r.lastInBinding, r.lastInDirective);
  }
  function _map(indexMap, value) {
    var r = indexMap.get(value);
    return isPresent(r) ? r : value;
  }
  $__export("coalesce", coalesce);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      looseIdentical = $__m.looseIdentical;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }, function($__m) {
      RecordType = $__m.RecordType;
      ProtoRecord = $__m.ProtoRecord;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/change_detection/parser/ast", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/ast";
  var isBlank,
      isPresent,
      FunctionWrapper,
      BaseException,
      ListWrapper,
      StringMapWrapper,
      AST,
      EmptyExpr,
      ImplicitReceiver,
      Chain,
      Conditional,
      If,
      AccessMember,
      SafeAccessMember,
      KeyedAccess,
      BindingPipe,
      LiteralPrimitive,
      LiteralArray,
      LiteralMap,
      Interpolation,
      Binary,
      PrefixNot,
      Assignment,
      MethodCall,
      SafeMethodCall,
      FunctionCall,
      ASTWithSource,
      TemplateBinding,
      AstTransformer,
      _evalListCache;
  function evalList(context, locals, exps) {
    var length = exps.length;
    if (length > 10) {
      throw new BaseException("Cannot have more than 10 argument");
    }
    var result = _evalListCache[length];
    for (var i = 0; i < length; i++) {
      result[i] = exps[i].eval(context, locals);
    }
    return result;
  }
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      FunctionWrapper = $__m.FunctionWrapper;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      AST = (function() {
        function AST() {}
        return ($traceurRuntime.createClass)(AST, {
          eval: function(context, locals) {
            throw new BaseException("Not supported");
          },
          get isAssignable() {
            return false;
          },
          assign: function(context, locals, value) {
            throw new BaseException("Not supported");
          },
          visit: function(visitor) {
            return null;
          },
          toString: function() {
            return "AST";
          }
        }, {});
      }());
      $__export("AST", AST);
      EmptyExpr = (function($__super) {
        function EmptyExpr() {
          $traceurRuntime.superConstructor(EmptyExpr).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(EmptyExpr, {
          eval: function(context, locals) {
            return null;
          },
          visit: function(visitor) {}
        }, {}, $__super);
      }(AST));
      $__export("EmptyExpr", EmptyExpr);
      ImplicitReceiver = (function($__super) {
        function ImplicitReceiver() {
          $traceurRuntime.superConstructor(ImplicitReceiver).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(ImplicitReceiver, {
          eval: function(context, locals) {
            return context;
          },
          visit: function(visitor) {
            return visitor.visitImplicitReceiver(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("ImplicitReceiver", ImplicitReceiver);
      Chain = (function($__super) {
        function Chain(expressions) {
          $traceurRuntime.superConstructor(Chain).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Chain, {
          eval: function(context, locals) {
            var result;
            for (var i = 0; i < this.expressions.length; i++) {
              var last = this.expressions[i].eval(context, locals);
              if (isPresent(last))
                result = last;
            }
            return result;
          },
          visit: function(visitor) {
            return visitor.visitChain(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Chain", Chain);
      Conditional = (function($__super) {
        function Conditional(condition, trueExp, falseExp) {
          $traceurRuntime.superConstructor(Conditional).call(this);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
        }
        return ($traceurRuntime.createClass)(Conditional, {
          eval: function(context, locals) {
            if (this.condition.eval(context, locals)) {
              return this.trueExp.eval(context, locals);
            } else {
              return this.falseExp.eval(context, locals);
            }
          },
          visit: function(visitor) {
            return visitor.visitConditional(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Conditional", Conditional);
      If = (function($__super) {
        function If(condition, trueExp, falseExp) {
          $traceurRuntime.superConstructor(If).call(this);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
        }
        return ($traceurRuntime.createClass)(If, {
          eval: function(context, locals) {
            if (this.condition.eval(context, locals)) {
              this.trueExp.eval(context, locals);
            } else if (isPresent(this.falseExp)) {
              this.falseExp.eval(context, locals);
            }
          },
          visit: function(visitor) {
            return visitor.visitIf(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("If", If);
      AccessMember = (function($__super) {
        function AccessMember(receiver, name, getter, setter) {
          $traceurRuntime.superConstructor(AccessMember).call(this);
          this.receiver = receiver;
          this.name = name;
          this.getter = getter;
          this.setter = setter;
        }
        return ($traceurRuntime.createClass)(AccessMember, {
          eval: function(context, locals) {
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              return locals.get(this.name);
            } else {
              var evaluatedReceiver = this.receiver.eval(context, locals);
              return this.getter(evaluatedReceiver);
            }
          },
          get isAssignable() {
            return true;
          },
          assign: function(context, locals, value) {
            var evaluatedContext = this.receiver.eval(context, locals);
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              throw new BaseException(("Cannot reassign a variable binding " + this.name));
            } else {
              return this.setter(evaluatedContext, value);
            }
          },
          visit: function(visitor) {
            return visitor.visitAccessMember(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("AccessMember", AccessMember);
      SafeAccessMember = (function($__super) {
        function SafeAccessMember(receiver, name, getter, setter) {
          $traceurRuntime.superConstructor(SafeAccessMember).call(this);
          this.receiver = receiver;
          this.name = name;
          this.getter = getter;
          this.setter = setter;
        }
        return ($traceurRuntime.createClass)(SafeAccessMember, {
          eval: function(context, locals) {
            var evaluatedReceiver = this.receiver.eval(context, locals);
            return isBlank(evaluatedReceiver) ? null : this.getter(evaluatedReceiver);
          },
          visit: function(visitor) {
            return visitor.visitSafeAccessMember(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("SafeAccessMember", SafeAccessMember);
      KeyedAccess = (function($__super) {
        function KeyedAccess(obj, key) {
          $traceurRuntime.superConstructor(KeyedAccess).call(this);
          this.obj = obj;
          this.key = key;
        }
        return ($traceurRuntime.createClass)(KeyedAccess, {
          eval: function(context, locals) {
            var obj = this.obj.eval(context, locals);
            var key = this.key.eval(context, locals);
            return obj[key];
          },
          get isAssignable() {
            return true;
          },
          assign: function(context, locals, value) {
            var obj = this.obj.eval(context, locals);
            var key = this.key.eval(context, locals);
            obj[key] = value;
            return value;
          },
          visit: function(visitor) {
            return visitor.visitKeyedAccess(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("KeyedAccess", KeyedAccess);
      BindingPipe = (function($__super) {
        function BindingPipe(exp, name, args) {
          $traceurRuntime.superConstructor(BindingPipe).call(this);
          this.exp = exp;
          this.name = name;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(BindingPipe, {visit: function(visitor) {
            return visitor.visitPipe(this);
          }}, {}, $__super);
      }(AST));
      $__export("BindingPipe", BindingPipe);
      LiteralPrimitive = (function($__super) {
        function LiteralPrimitive(value) {
          $traceurRuntime.superConstructor(LiteralPrimitive).call(this);
          this.value = value;
        }
        return ($traceurRuntime.createClass)(LiteralPrimitive, {
          eval: function(context, locals) {
            return this.value;
          },
          visit: function(visitor) {
            return visitor.visitLiteralPrimitive(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralPrimitive", LiteralPrimitive);
      LiteralArray = (function($__super) {
        function LiteralArray(expressions) {
          $traceurRuntime.superConstructor(LiteralArray).call(this);
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(LiteralArray, {
          eval: function(context, locals) {
            return ListWrapper.map(this.expressions, (function(e) {
              return e.eval(context, locals);
            }));
          },
          visit: function(visitor) {
            return visitor.visitLiteralArray(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralArray", LiteralArray);
      LiteralMap = (function($__super) {
        function LiteralMap(keys, values) {
          $traceurRuntime.superConstructor(LiteralMap).call(this);
          this.keys = keys;
          this.values = values;
        }
        return ($traceurRuntime.createClass)(LiteralMap, {
          eval: function(context, locals) {
            var res = StringMapWrapper.create();
            for (var i = 0; i < this.keys.length; ++i) {
              StringMapWrapper.set(res, this.keys[i], this.values[i].eval(context, locals));
            }
            return res;
          },
          visit: function(visitor) {
            return visitor.visitLiteralMap(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("LiteralMap", LiteralMap);
      Interpolation = (function($__super) {
        function Interpolation(strings, expressions) {
          $traceurRuntime.superConstructor(Interpolation).call(this);
          this.strings = strings;
          this.expressions = expressions;
        }
        return ($traceurRuntime.createClass)(Interpolation, {
          eval: function(context, locals) {
            throw new BaseException("evaluating an Interpolation is not supported");
          },
          visit: function(visitor) {
            visitor.visitInterpolation(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Interpolation", Interpolation);
      Binary = (function($__super) {
        function Binary(operation, left, right) {
          $traceurRuntime.superConstructor(Binary).call(this);
          this.operation = operation;
          this.left = left;
          this.right = right;
        }
        return ($traceurRuntime.createClass)(Binary, {
          eval: function(context, locals) {
            var left = this.left.eval(context, locals);
            switch (this.operation) {
              case '&&':
                return left && this.right.eval(context, locals);
              case '||':
                return left || this.right.eval(context, locals);
            }
            var right = this.right.eval(context, locals);
            switch (this.operation) {
              case '+':
                return left + right;
              case '-':
                return left - right;
              case '*':
                return left * right;
              case '/':
                return left / right;
              case '%':
                return left % right;
              case '==':
                return left == right;
              case '!=':
                return left != right;
              case '===':
                return left === right;
              case '!==':
                return left !== right;
              case '<':
                return left < right;
              case '>':
                return left > right;
              case '<=':
                return left <= right;
              case '>=':
                return left >= right;
              case '^':
                return left ^ right;
              case '&':
                return left & right;
            }
            throw 'Internal error [$operation] not handled';
          },
          visit: function(visitor) {
            return visitor.visitBinary(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Binary", Binary);
      PrefixNot = (function($__super) {
        function PrefixNot(expression) {
          $traceurRuntime.superConstructor(PrefixNot).call(this);
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(PrefixNot, {
          eval: function(context, locals) {
            return !this.expression.eval(context, locals);
          },
          visit: function(visitor) {
            return visitor.visitPrefixNot(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("PrefixNot", PrefixNot);
      Assignment = (function($__super) {
        function Assignment(target, value) {
          $traceurRuntime.superConstructor(Assignment).call(this);
          this.target = target;
          this.value = value;
        }
        return ($traceurRuntime.createClass)(Assignment, {
          eval: function(context, locals) {
            return this.target.assign(context, locals, this.value.eval(context, locals));
          },
          visit: function(visitor) {
            return visitor.visitAssignment(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("Assignment", Assignment);
      MethodCall = (function($__super) {
        function MethodCall(receiver, name, fn, args) {
          $traceurRuntime.superConstructor(MethodCall).call(this);
          this.receiver = receiver;
          this.name = name;
          this.fn = fn;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(MethodCall, {
          eval: function(context, locals) {
            var evaluatedArgs = evalList(context, locals, this.args);
            if (this.receiver instanceof ImplicitReceiver && isPresent(locals) && locals.contains(this.name)) {
              var fn = locals.get(this.name);
              return FunctionWrapper.apply(fn, evaluatedArgs);
            } else {
              var evaluatedReceiver = this.receiver.eval(context, locals);
              return this.fn(evaluatedReceiver, evaluatedArgs);
            }
          },
          visit: function(visitor) {
            return visitor.visitMethodCall(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("MethodCall", MethodCall);
      SafeMethodCall = (function($__super) {
        function SafeMethodCall(receiver, name, fn, args) {
          $traceurRuntime.superConstructor(SafeMethodCall).call(this);
          this.receiver = receiver;
          this.name = name;
          this.fn = fn;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(SafeMethodCall, {
          eval: function(context, locals) {
            var evaluatedReceiver = this.receiver.eval(context, locals);
            if (isBlank(evaluatedReceiver))
              return null;
            var evaluatedArgs = evalList(context, locals, this.args);
            return this.fn(evaluatedReceiver, evaluatedArgs);
          },
          visit: function(visitor) {
            return visitor.visitSafeMethodCall(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("SafeMethodCall", SafeMethodCall);
      FunctionCall = (function($__super) {
        function FunctionCall(target, args) {
          $traceurRuntime.superConstructor(FunctionCall).call(this);
          this.target = target;
          this.args = args;
        }
        return ($traceurRuntime.createClass)(FunctionCall, {
          eval: function(context, locals) {
            var obj = this.target.eval(context, locals);
            if (!(obj instanceof Function)) {
              throw new BaseException((obj + " is not a function"));
            }
            return FunctionWrapper.apply(obj, evalList(context, locals, this.args));
          },
          visit: function(visitor) {
            return visitor.visitFunctionCall(this);
          }
        }, {}, $__super);
      }(AST));
      $__export("FunctionCall", FunctionCall);
      ASTWithSource = (function($__super) {
        function ASTWithSource(ast, source, location) {
          $traceurRuntime.superConstructor(ASTWithSource).call(this);
          this.ast = ast;
          this.source = source;
          this.location = location;
        }
        return ($traceurRuntime.createClass)(ASTWithSource, {
          eval: function(context, locals) {
            return this.ast.eval(context, locals);
          },
          get isAssignable() {
            return this.ast.isAssignable;
          },
          assign: function(context, locals, value) {
            return this.ast.assign(context, locals, value);
          },
          visit: function(visitor) {
            return this.ast.visit(visitor);
          },
          toString: function() {
            return (this.source + " in " + this.location);
          }
        }, {}, $__super);
      }(AST));
      $__export("ASTWithSource", ASTWithSource);
      TemplateBinding = (function() {
        function TemplateBinding(key, keyIsVar, name, expression) {
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(TemplateBinding, {}, {});
      }());
      $__export("TemplateBinding", TemplateBinding);
      AstTransformer = (function() {
        function AstTransformer() {}
        return ($traceurRuntime.createClass)(AstTransformer, {
          visitImplicitReceiver: function(ast) {
            return ast;
          },
          visitInterpolation: function(ast) {
            return new Interpolation(ast.strings, this.visitAll(ast.expressions));
          },
          visitLiteralPrimitive: function(ast) {
            return new LiteralPrimitive(ast.value);
          },
          visitAccessMember: function(ast) {
            return new AccessMember(ast.receiver.visit(this), ast.name, ast.getter, ast.setter);
          },
          visitSafeAccessMember: function(ast) {
            return new SafeAccessMember(ast.receiver.visit(this), ast.name, ast.getter, ast.setter);
          },
          visitMethodCall: function(ast) {
            return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
          },
          visitSafeMethodCall: function(ast) {
            return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
          },
          visitFunctionCall: function(ast) {
            return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
          },
          visitLiteralArray: function(ast) {
            return new LiteralArray(this.visitAll(ast.expressions));
          },
          visitLiteralMap: function(ast) {
            return new LiteralMap(ast.keys, this.visitAll(ast.values));
          },
          visitBinary: function(ast) {
            return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
          },
          visitPrefixNot: function(ast) {
            return new PrefixNot(ast.expression.visit(this));
          },
          visitConditional: function(ast) {
            return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
          },
          visitPipe: function(ast) {
            return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
          },
          visitKeyedAccess: function(ast) {
            return new KeyedAccess(ast.obj.visit(this), ast.key.visit(this));
          },
          visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          visitChain: function(ast) {
            return new Chain(this.visitAll(ast.expressions));
          },
          visitAssignment: function(ast) {
            return new Assignment(ast.target.visit(this), ast.value.visit(this));
          },
          visitIf: function(ast) {
            var falseExp = isPresent(ast.falseExp) ? ast.falseExp.visit(this) : null;
            return new If(ast.condition.visit(this), ast.trueExp.visit(this), falseExp);
          }
        }, {});
      }());
      $__export("AstTransformer", AstTransformer);
      _evalListCache = [[], [0], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
    }
  };
});

System.register("angular2/src/change_detection/dynamic_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/dynamic_change_detector";
  var isPresent,
      isBlank,
      BaseException,
      FunctionWrapper,
      ListWrapper,
      AbstractChangeDetector,
      ChangeDetectionUtil,
      RecordType,
      DynamicChangeDetector;
  function isSame(a, b) {
    if (a === b)
      return true;
    if (a instanceof String && b instanceof String && a == b)
      return true;
    if ((a !== a) && (b !== b))
      return true;
    return false;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      FunctionWrapper = $__m.FunctionWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      RecordType = $__m.RecordType;
    }],
    execute: function() {
      DynamicChangeDetector = (function($__super) {
        function DynamicChangeDetector(id, changeControlStrategy, dispatcher, protos, directiveRecords) {
          $traceurRuntime.superConstructor(DynamicChangeDetector).call(this, id, dispatcher);
          this.changeControlStrategy = changeControlStrategy;
          this.protos = protos;
          this.directiveRecords = directiveRecords;
          this.locals = null;
          this.directives = null;
          this.alreadyChecked = false;
          this.pipes = null;
          this.values = ListWrapper.createFixedSize(protos.length + 1);
          this.localPipes = ListWrapper.createFixedSize(protos.length + 1);
          this.prevContexts = ListWrapper.createFixedSize(protos.length + 1);
          this.changes = ListWrapper.createFixedSize(protos.length + 1);
          this.values[0] = null;
          ListWrapper.fill(this.values, ChangeDetectionUtil.uninitialized, 1);
          ListWrapper.fill(this.localPipes, null);
          ListWrapper.fill(this.prevContexts, ChangeDetectionUtil.uninitialized);
          ListWrapper.fill(this.changes, false);
        }
        return ($traceurRuntime.createClass)(DynamicChangeDetector, {
          hydrate: function(context, locals, directives, pipes) {
            this.mode = ChangeDetectionUtil.changeDetectionMode(this.changeControlStrategy);
            this.values[0] = context;
            this.locals = locals;
            this.directives = directives;
            this.alreadyChecked = false;
            this.pipes = pipes;
          },
          dehydrate: function() {
            this._destroyPipes();
            this.values[0] = null;
            ListWrapper.fill(this.values, ChangeDetectionUtil.uninitialized, 1);
            ListWrapper.fill(this.changes, false);
            ListWrapper.fill(this.localPipes, null);
            ListWrapper.fill(this.prevContexts, ChangeDetectionUtil.uninitialized);
            this.locals = null;
            this.pipes = null;
          },
          _destroyPipes: function() {
            for (var i = 0; i < this.localPipes.length; ++i) {
              if (isPresent(this.localPipes[i])) {
                this.localPipes[i].onDestroy();
              }
            }
          },
          hydrated: function() {
            return this.values[0] !== null;
          },
          checkNoChanges: function() {
            this.runDetectChanges(true);
          },
          detectChangesInRecords: function(throwOnChange) {
            if (!this.hydrated()) {
              ChangeDetectionUtil.throwDehydrated();
            }
            var protos = this.protos;
            var changes = null;
            var isChanged = false;
            for (var i = 0; i < protos.length; ++i) {
              var proto = protos[i];
              var bindingRecord = proto.bindingRecord;
              var directiveRecord = bindingRecord.directiveRecord;
              if (proto.isLifeCycleRecord()) {
                if (proto.name === "onCheck" && !throwOnChange) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onCheck();
                } else if (proto.name === "onInit" && !throwOnChange && !this.alreadyChecked) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
                } else if (proto.name === "onChange" && isPresent(changes) && !throwOnChange) {
                  this._getDirectiveFor(directiveRecord.directiveIndex).onChange(changes);
                }
              } else {
                var change = this._check(proto, throwOnChange);
                if (isPresent(change)) {
                  this._updateDirectiveOrElement(change, bindingRecord);
                  isChanged = true;
                  changes = this._addChange(bindingRecord, change, changes);
                }
              }
              if (proto.lastInDirective) {
                changes = null;
                if (isChanged && bindingRecord.isOnPushChangeDetection()) {
                  this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
                }
                isChanged = false;
              }
            }
            this.alreadyChecked = true;
          },
          callOnAllChangesDone: function() {
            this.dispatcher.notifyOnAllChangesDone();
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                this._getDirectiveFor(dir.directiveIndex).onAllChangesDone();
              }
            }
          },
          _updateDirectiveOrElement: function(change, bindingRecord) {
            if (isBlank(bindingRecord.directiveRecord)) {
              this.dispatcher.notifyOnBinding(bindingRecord, change.currentValue);
            } else {
              var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
              bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
            }
          },
          _addChange: function(bindingRecord, change, changes) {
            if (bindingRecord.callOnChange()) {
              return ChangeDetectionUtil.addChange(changes, bindingRecord.propertyName, change);
            } else {
              return changes;
            }
          },
          _getDirectiveFor: function(directiveIndex) {
            return this.directives.getDirectiveFor(directiveIndex);
          },
          _getDetectorFor: function(directiveIndex) {
            return this.directives.getDetectorFor(directiveIndex);
          },
          _check: function(proto, throwOnChange) {
            try {
              if (proto.isPipeRecord()) {
                return this._pipeCheck(proto, throwOnChange);
              } else {
                return this._referenceCheck(proto, throwOnChange);
              }
            } catch (e) {
              this.throwError(proto, e, e.stack);
            }
          },
          _referenceCheck: function(proto, throwOnChange) {
            if (this._pureFuncAndArgsDidNotChange(proto)) {
              this._setChanged(proto, false);
              return null;
            }
            var prevValue = this._readSelf(proto);
            var currValue = this._calculateCurrValue(proto);
            if (!isSame(prevValue, currValue)) {
              if (proto.lastInBinding) {
                var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                if (throwOnChange)
                  ChangeDetectionUtil.throwOnChange(proto, change);
                this._writeSelf(proto, currValue);
                this._setChanged(proto, true);
                return change;
              } else {
                this._writeSelf(proto, currValue);
                this._setChanged(proto, true);
                return null;
              }
            } else {
              this._setChanged(proto, false);
              return null;
            }
          },
          _calculateCurrValue: function(proto) {
            switch (proto.mode) {
              case RecordType.SELF:
                return this._readContext(proto);
              case RecordType.CONST:
                return proto.funcOrValue;
              case RecordType.PROPERTY:
                var context = this._readContext(proto);
                return proto.funcOrValue(context);
              case RecordType.SAFE_PROPERTY:
                var context = this._readContext(proto);
                return isBlank(context) ? null : proto.funcOrValue(context);
              case RecordType.LOCAL:
                return this.locals.get(proto.name);
              case RecordType.INVOKE_METHOD:
                var context = this._readContext(proto);
                var args = this._readArgs(proto);
                return proto.funcOrValue(context, args);
              case RecordType.SAFE_INVOKE_METHOD:
                var context = this._readContext(proto);
                if (isBlank(context)) {
                  return null;
                }
                var args = this._readArgs(proto);
                return proto.funcOrValue(context, args);
              case RecordType.KEYED_ACCESS:
                var arg = this._readArgs(proto)[0];
                return this._readContext(proto)[arg];
              case RecordType.INVOKE_CLOSURE:
                return FunctionWrapper.apply(this._readContext(proto), this._readArgs(proto));
              case RecordType.INTERPOLATE:
              case RecordType.PRIMITIVE_OP:
                return FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto));
              default:
                throw new BaseException(("Unknown operation " + proto.mode));
            }
          },
          _pipeCheck: function(proto, throwOnChange) {
            var context = this._readContext(proto);
            var args = this._readArgs(proto);
            var pipe = this._pipeFor(proto, context);
            var prevValue = this._readSelf(proto);
            var currValue = pipe.transform(context, args);
            if (!isSame(prevValue, currValue)) {
              currValue = ChangeDetectionUtil.unwrapValue(currValue);
              if (proto.lastInBinding) {
                var change = ChangeDetectionUtil.simpleChange(prevValue, currValue);
                if (throwOnChange)
                  ChangeDetectionUtil.throwOnChange(proto, change);
                this._writeSelf(proto, currValue);
                this._setChanged(proto, true);
                return change;
              } else {
                this._writeSelf(proto, currValue);
                this._setChanged(proto, true);
                return null;
              }
            } else {
              this._setChanged(proto, false);
              return null;
            }
          },
          _pipeFor: function(proto, context) {
            var storedPipe = this._readPipe(proto);
            if (isPresent(storedPipe) && storedPipe.supports(context)) {
              return storedPipe;
            }
            if (isPresent(storedPipe)) {
              storedPipe.onDestroy();
            }
            var pipe = this.pipes.get(proto.name, context, this.ref);
            this._writePipe(proto, pipe);
            return pipe;
          },
          _readContext: function(proto) {
            if (proto.contextIndex == -1) {
              return this._getDirectiveFor(proto.directiveIndex);
            } else {
              return this.values[proto.contextIndex];
            }
            return this.values[proto.contextIndex];
          },
          _readSelf: function(proto) {
            return this.values[proto.selfIndex];
          },
          _writeSelf: function(proto, value) {
            this.values[proto.selfIndex] = value;
          },
          _readPipe: function(proto) {
            return this.localPipes[proto.selfIndex];
          },
          _writePipe: function(proto, value) {
            this.localPipes[proto.selfIndex] = value;
          },
          _setChanged: function(proto, value) {
            this.changes[proto.selfIndex] = value;
          },
          _pureFuncAndArgsDidNotChange: function(proto) {
            return proto.isPureFunction() && !this._argsChanged(proto);
          },
          _argsChanged: function(proto) {
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              if (this.changes[args[i]]) {
                return true;
              }
            }
            return false;
          },
          _readArgs: function(proto) {
            var res = ListWrapper.createFixedSize(proto.args.length);
            var args = proto.args;
            for (var i = 0; i < args.length; ++i) {
              res[i] = this.values[args[i]];
            }
            return res;
          }
        }, {}, $__super);
      }(AbstractChangeDetector));
      $__export("DynamicChangeDetector", DynamicChangeDetector);
    }
  };
});

System.register("angular2/src/change_detection/directive_record", ["angular2/src/change_detection/constants", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/directive_record";
  var ON_PUSH,
      StringWrapper,
      normalizeBool,
      DirectiveIndex,
      DirectiveRecord;
  return {
    setters: [function($__m) {
      ON_PUSH = $__m.ON_PUSH;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      normalizeBool = $__m.normalizeBool;
    }],
    execute: function() {
      DirectiveIndex = (function() {
        function DirectiveIndex(elementIndex, directiveIndex) {
          this.elementIndex = elementIndex;
          this.directiveIndex = directiveIndex;
        }
        return ($traceurRuntime.createClass)(DirectiveIndex, {get name() {
            return (this.elementIndex + "_" + this.directiveIndex);
          }}, {});
      }());
      $__export("DirectiveIndex", DirectiveIndex);
      DirectiveRecord = (function() {
        function DirectiveRecord() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              directiveIndex = $__1.directiveIndex,
              callOnAllChangesDone = $__1.callOnAllChangesDone,
              callOnChange = $__1.callOnChange,
              callOnCheck = $__1.callOnCheck,
              callOnInit = $__1.callOnInit,
              changeDetection = $__1.changeDetection;
          this.directiveIndex = directiveIndex;
          this.callOnAllChangesDone = normalizeBool(callOnAllChangesDone);
          this.callOnChange = normalizeBool(callOnChange);
          this.callOnCheck = normalizeBool(callOnCheck);
          this.callOnInit = normalizeBool(callOnInit);
          this.changeDetection = changeDetection;
        }
        return ($traceurRuntime.createClass)(DirectiveRecord, {isOnPushChangeDetection: function() {
            return StringWrapper.equals(this.changeDetection, ON_PUSH);
          }}, {});
      }());
      $__export("DirectiveRecord", DirectiveRecord);
    }
  };
});

System.register("angular2/src/change_detection/pregen_proto_change_detector", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pregen_proto_change_detector";
  var BaseException,
      PregenProtoChangeDetector;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      $__export("PregenProtoChangeDetectorFactory", Function);
      PregenProtoChangeDetector = (function() {
        function PregenProtoChangeDetector() {}
        return ($traceurRuntime.createClass)(PregenProtoChangeDetector, {instantiate: function(dispatcher) {
            throw new BaseException('Pregen change detection not supported in Js');
          }}, {isSupported: function() {
            return false;
          }});
      }());
      $__export("PregenProtoChangeDetector", PregenProtoChangeDetector);
    }
  };
});

System.register("angular2/src/change_detection/pipes/pipes", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/pipes";
  var __decorate,
      __metadata,
      ListWrapper,
      StringMapWrapper,
      isBlank,
      isPresent,
      BaseException,
      CONST,
      Injectable,
      UnboundedMetadata,
      OptionalMetadata,
      Binding,
      Pipes;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      Injectable = $__m.Injectable;
      UnboundedMetadata = $__m.UnboundedMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      Binding = $__m.Binding;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Pipes = (($traceurRuntime.createClass)(function(config) {
        this.config = config;
      }, {
        get: function(type, obj, cdRef, existingPipe) {
          if (isPresent(existingPipe) && existingPipe.supports(obj))
            return existingPipe;
          if (isPresent(existingPipe))
            existingPipe.onDestroy();
          var factories = this._getListOfFactories(type, obj);
          var factory = this._getMatchingFactory(factories, type, obj);
          return factory.create(cdRef);
        },
        _getListOfFactories: function(type, obj) {
          var listOfFactories = this.config[type];
          if (isBlank(listOfFactories)) {
            throw new BaseException(("Cannot find '" + type + "' pipe supporting object '" + obj + "'"));
          }
          return listOfFactories;
        },
        _getMatchingFactory: function(listOfFactories, type, obj) {
          var matchingFactory = ListWrapper.find(listOfFactories, (function(pipeFactory) {
            return pipeFactory.supports(obj);
          }));
          if (isBlank(matchingFactory)) {
            throw new BaseException(("Cannot find '" + type + "' pipe supporting object '" + obj + "'"));
          }
          return matchingFactory;
        }
      }, {
        extend: function(config) {
          return new Binding(Pipes, {
            toFactory: (function(pipes) {
              if (isBlank(pipes)) {
                throw new BaseException('Cannot extend Pipes without a parent injector');
              }
              return Pipes.create(config, pipes);
            }),
            deps: [[Pipes, new UnboundedMetadata(), new OptionalMetadata()]]
          });
        },
        create: function(config) {
          var pipes = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isPresent(pipes)) {
            StringMapWrapper.forEach(pipes.config, (function(v, k) {
              if (StringMapWrapper.contains(config, k)) {
                var configFactories = config[k];
                config[k] = configFactories.concat(v);
              } else {
                config[k] = ListWrapper.clone(v);
              }
            }));
          }
          return new Pipes(config);
        }
      }));
      $__export("Pipes", Pipes);
      $__export("Pipes", Pipes = __decorate([Injectable(), CONST(), __metadata('design:paramtypes', [Object])], Pipes));
    }
  };
});

System.register("angular2/src/change_detection/pipes/iterable_changes", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/iterable_changes";
  var __decorate,
      __metadata,
      CONST,
      isListLikeIterable,
      iterateListLike,
      MapWrapper,
      isBlank,
      isPresent,
      stringify,
      getMapKey,
      looseIdentical,
      isArray,
      WrappedValue,
      BasePipe,
      IterableChangesFactory,
      IterableChanges,
      CollectionChangeRecord,
      _DuplicateItemRecordList,
      _DuplicateMap;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      stringify = $__m.stringify;
      getMapKey = $__m.getMapKey;
      looseIdentical = $__m.looseIdentical;
      isArray = $__m.isArray;
    }, function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
      iterateListLike = $__m.iterateListLike;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      IterableChangesFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return IterableChanges.supportsObj(obj);
        },
        create: function(cdRef) {
          return new IterableChanges();
        }
      }, {}));
      $__export("IterableChangesFactory", IterableChangesFactory);
      $__export("IterableChangesFactory", IterableChangesFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], IterableChangesFactory));
      IterableChanges = (function($__super) {
        function IterableChanges() {
          $traceurRuntime.superConstructor(IterableChanges).call(this);
          this._collection = null;
          this._length = null;
          this._linkedRecords = null;
          this._unlinkedRecords = null;
          this._previousItHead = null;
          this._itHead = null;
          this._itTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._movesHead = null;
          this._movesTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(IterableChanges, {
          supports: function(obj) {
            return IterableChanges.supportsObj(obj);
          },
          get collection() {
            return this._collection;
          },
          get length() {
            return this._length;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._itHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachMovedItem: function(fn) {
            var record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          transform: function(collection) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            if (this.check(collection)) {
              return WrappedValue.wrap(this);
            } else {
              return null;
            }
          },
          check: function(collection) {
            var $__0 = this;
            this._reset();
            var record = this._itHead;
            var mayBeDirty = false;
            var index;
            var item;
            if (isArray(collection)) {
              var list = collection;
              this._length = collection.length;
              for (index = 0; index < this._length; index++) {
                item = list[index];
                if (record === null || !looseIdentical(record.item, item)) {
                  record = this._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = this._verifyReinsertion(record, item, index);
                }
                record = record._next;
              }
            } else {
              index = 0;
              iterateListLike(collection, (function(item) {
                if (record === null || !looseIdentical(record.item, item)) {
                  record = $__0._mismatch(record, item, index);
                  mayBeDirty = true;
                } else if (mayBeDirty) {
                  record = $__0._verifyReinsertion(record, item, index);
                }
                record = record._next;
                index++;
              }));
              this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
          },
          get isDirty() {
            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              var nextRecord;
              for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                record.previousIndex = record.currentIndex;
              }
              this._additionsHead = this._additionsTail = null;
              for (record = this._movesHead; record !== null; record = nextRecord) {
                record.previousIndex = record.currentIndex;
                nextRecord = record._nextMoved;
              }
              this._movesHead = this._movesTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _mismatch: function(record, item, index) {
            var previousRecord;
            if (record === null) {
              previousRecord = this._itTail;
            } else {
              previousRecord = record._prev;
              this._remove(record);
            }
            record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
            if (record !== null) {
              this._moveAfter(record, previousRecord, index);
            } else {
              record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
              if (record !== null) {
                this._reinsertAfter(record, previousRecord, index);
              } else {
                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
              }
            }
            return record;
          },
          _verifyReinsertion: function(record, item, index) {
            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
            if (reinsertRecord !== null) {
              record = this._reinsertAfter(reinsertRecord, record._prev, index);
            } else if (record.currentIndex != index) {
              record.currentIndex = index;
              this._addToMoves(record, index);
            }
            return record;
          },
          _truncate: function(record) {
            while (record !== null) {
              var nextRecord = record._next;
              this._addToRemovals(this._unlink(record));
              record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
              this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
              this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
              this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
              this._removalsTail._nextRemoved = null;
            }
          },
          _reinsertAfter: function(record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.remove(record);
            }
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _moveAfter: function(record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
          },
          _addAfter: function(record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
              this._additionsTail = this._additionsHead = record;
            } else {
              this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
          },
          _insertAfter: function(record, prevRecord, index) {
            var next = prevRecord === null ? this._itHead : prevRecord._next;
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
              this._itTail = record;
            } else {
              next._prev = record;
            }
            if (prevRecord === null) {
              this._itHead = record;
            } else {
              prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
              this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
          },
          _remove: function(record) {
            return this._addToRemovals(this._unlink(record));
          },
          _unlink: function(record) {
            if (this._linkedRecords !== null) {
              this._linkedRecords.remove(record);
            }
            var prev = record._prev;
            var next = record._next;
            if (prev === null) {
              this._itHead = next;
            } else {
              prev._next = next;
            }
            if (next === null) {
              this._itTail = prev;
            } else {
              next._prev = prev;
            }
            return record;
          },
          _addToMoves: function(record, toIndex) {
            if (record.previousIndex === toIndex) {
              return record;
            }
            if (this._movesTail === null) {
              this._movesTail = this._movesHead = record;
            } else {
              this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
          },
          _addToRemovals: function(record) {
            if (this._unlinkedRecords === null) {
              this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
              this._removalsTail = this._removalsHead = record;
              record._prevRemoved = null;
            } else {
              record._prevRemoved = this._removalsTail;
              this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
          },
          toString: function() {
            var record;
            var list = [];
            for (record = this._itHead; record !== null; record = record._next) {
              list.push(record);
            }
            var previous = [];
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              previous.push(record);
            }
            var additions = [];
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              additions.push(record);
            }
            var moves = [];
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
              moves.push(record);
            }
            var removals = [];
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              removals.push(record);
            }
            return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          }
        }, {supportsObj: function(obj) {
            return isListLikeIterable(obj);
          }}, $__super);
      }(BasePipe));
      $__export("IterableChanges", IterableChanges);
      CollectionChangeRecord = (function() {
        function CollectionChangeRecord(item) {
          this.item = item;
          this.currentIndex = null;
          this.previousIndex = null;
          this._nextPrevious = null;
          this._prev = null;
          this._next = null;
          this._prevDup = null;
          this._nextDup = null;
          this._prevRemoved = null;
          this._nextRemoved = null;
          this._nextAdded = null;
          this._nextMoved = null;
        }
        return ($traceurRuntime.createClass)(CollectionChangeRecord, {toString: function() {
            return this.previousIndex === this.currentIndex ? stringify(this.item) : stringify(this.item) + '[' + stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
          }}, {});
      }());
      $__export("CollectionChangeRecord", CollectionChangeRecord);
      _DuplicateItemRecordList = (function() {
        function _DuplicateItemRecordList() {
          this._head = null;
          this._tail = null;
        }
        return ($traceurRuntime.createClass)(_DuplicateItemRecordList, {
          add: function(record) {
            if (this._head === null) {
              this._head = this._tail = record;
              record._nextDup = null;
              record._prevDup = null;
            } else {
              this._tail._nextDup = record;
              record._prevDup = this._tail;
              record._nextDup = null;
              this._tail = record;
            }
          },
          get: function(item, afterIndex) {
            var record;
            for (record = this._head; record !== null; record = record._nextDup) {
              if ((afterIndex === null || afterIndex < record.currentIndex) && looseIdentical(record.item, item)) {
                return record;
              }
            }
            return null;
          },
          remove: function(record) {
            var prev = record._prevDup;
            var next = record._nextDup;
            if (prev === null) {
              this._head = next;
            } else {
              prev._nextDup = next;
            }
            if (next === null) {
              this._tail = prev;
            } else {
              next._prevDup = prev;
            }
            return this._head === null;
          }
        }, {});
      }());
      _DuplicateMap = (function() {
        function _DuplicateMap() {
          this.map = new Map();
        }
        return ($traceurRuntime.createClass)(_DuplicateMap, {
          put: function(record) {
            var key = getMapKey(record.item);
            var duplicates = this.map.get(key);
            if (!isPresent(duplicates)) {
              duplicates = new _DuplicateItemRecordList();
              this.map.set(key, duplicates);
            }
            duplicates.add(record);
          },
          get: function(value) {
            var afterIndex = arguments[1] !== (void 0) ? arguments[1] : null;
            var key = getMapKey(value);
            var recordList = this.map.get(key);
            return isBlank(recordList) ? null : recordList.get(value, afterIndex);
          },
          remove: function(record) {
            var key = getMapKey(record.item);
            var recordList = this.map.get(key);
            if (recordList.remove(record)) {
              MapWrapper.delete(this.map, key);
            }
            return record;
          },
          get isEmpty() {
            return MapWrapper.size(this.map) === 0;
          },
          clear: function() {
            this.map.clear();
          },
          toString: function() {
            return '_DuplicateMap(' + stringify(this.map) + ')';
          }
        }, {});
      }());
    }
  };
});

System.register("angular2/src/change_detection/pipes/keyvalue_changes", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/keyvalue_changes";
  var __decorate,
      __metadata,
      MapWrapper,
      StringMapWrapper,
      stringify,
      looseIdentical,
      isJsObject,
      CONST,
      WrappedValue,
      BasePipe,
      KeyValueChangesFactory,
      KeyValueChanges,
      KVChangeRecord;
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      looseIdentical = $__m.looseIdentical;
      isJsObject = $__m.isJsObject;
      CONST = $__m.CONST;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      KeyValueChangesFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return KeyValueChanges.supportsObj(obj);
        },
        create: function(cdRef) {
          return new KeyValueChanges();
        }
      }, {}));
      $__export("KeyValueChangesFactory", KeyValueChangesFactory);
      $__export("KeyValueChangesFactory", KeyValueChangesFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], KeyValueChangesFactory));
      KeyValueChanges = (function($__super) {
        function KeyValueChanges() {
          var $__4;
          for (var args = [],
              $__3 = 0; $__3 < arguments.length; $__3++)
            args[$__3] = arguments[$__3];
          ($__4 = $traceurRuntime.superConstructor(KeyValueChanges)).call.apply($__4, $traceurRuntime.spread([this], args));
          this._records = new Map();
          this._mapHead = null;
          this._previousMapHead = null;
          this._changesHead = null;
          this._changesTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
        }
        return ($traceurRuntime.createClass)(KeyValueChanges, {
          supports: function(obj) {
            return KeyValueChanges.supportsObj(obj);
          },
          transform: function(map) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            if (this.check(map)) {
              return WrappedValue.wrap(this);
            } else {
              return null;
            }
          },
          get isDirty() {
            return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
          },
          forEachItem: function(fn) {
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              fn(record);
            }
          },
          forEachPreviousItem: function(fn) {
            var record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              fn(record);
            }
          },
          forEachChangedItem: function(fn) {
            var record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              fn(record);
            }
          },
          forEachAddedItem: function(fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
            }
          },
          forEachRemovedItem: function(fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
            }
          },
          check: function(map) {
            var $__0 = this;
            this._reset();
            var records = this._records;
            var oldSeqRecord = this._mapHead;
            var lastOldSeqRecord = null;
            var lastNewSeqRecord = null;
            var seqChanged = false;
            this._forEach(map, (function(value, key) {
              var newSeqRecord;
              if (oldSeqRecord !== null && key === oldSeqRecord.key) {
                newSeqRecord = oldSeqRecord;
                if (!looseIdentical(value, oldSeqRecord.currentValue)) {
                  oldSeqRecord.previousValue = oldSeqRecord.currentValue;
                  oldSeqRecord.currentValue = value;
                  $__0._addToChanges(oldSeqRecord);
                }
              } else {
                seqChanged = true;
                if (oldSeqRecord !== null) {
                  oldSeqRecord._next = null;
                  $__0._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                  $__0._addToRemovals(oldSeqRecord);
                }
                if (records.has(key)) {
                  newSeqRecord = records.get(key);
                } else {
                  newSeqRecord = new KVChangeRecord(key);
                  records.set(key, newSeqRecord);
                  newSeqRecord.currentValue = value;
                  $__0._addToAdditions(newSeqRecord);
                }
              }
              if (seqChanged) {
                if ($__0._isInRemovals(newSeqRecord)) {
                  $__0._removeFromRemovals(newSeqRecord);
                }
                if (lastNewSeqRecord == null) {
                  $__0._mapHead = newSeqRecord;
                } else {
                  lastNewSeqRecord._next = newSeqRecord;
                }
              }
              lastOldSeqRecord = oldSeqRecord;
              lastNewSeqRecord = newSeqRecord;
              oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
            }));
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
          },
          _reset: function() {
            if (this.isDirty) {
              var record;
              for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                record._nextPrevious = record._next;
              }
              for (record = this._changesHead; record !== null; record = record._nextChanged) {
                record.previousValue = record.currentValue;
              }
              for (record = this._additionsHead; record != null; record = record._nextAdded) {
                record.previousValue = record.currentValue;
              }
              this._changesHead = this._changesTail = null;
              this._additionsHead = this._additionsTail = null;
              this._removalsHead = this._removalsTail = null;
            }
          },
          _truncate: function(lastRecord, record) {
            while (record !== null) {
              if (lastRecord === null) {
                this._mapHead = null;
              } else {
                lastRecord._next = null;
              }
              var nextRecord = record._next;
              this._addToRemovals(record);
              lastRecord = record;
              record = nextRecord;
            }
            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
              rec.previousValue = rec.currentValue;
              rec.currentValue = null;
              MapWrapper.delete(this._records, rec.key);
            }
          },
          _isInRemovals: function(record) {
            return record === this._removalsHead || record._nextRemoved !== null || record._prevRemoved !== null;
          },
          _addToRemovals: function(record) {
            if (this._removalsHead === null) {
              this._removalsHead = this._removalsTail = record;
            } else {
              this._removalsTail._nextRemoved = record;
              record._prevRemoved = this._removalsTail;
              this._removalsTail = record;
            }
          },
          _removeFromSeq: function(prev, record) {
            var next = record._next;
            if (prev === null) {
              this._mapHead = next;
            } else {
              prev._next = next;
            }
          },
          _removeFromRemovals: function(record) {
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
              this._removalsHead = next;
            } else {
              prev._nextRemoved = next;
            }
            if (next === null) {
              this._removalsTail = prev;
            } else {
              next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
          },
          _addToAdditions: function(record) {
            if (this._additionsHead === null) {
              this._additionsHead = this._additionsTail = record;
            } else {
              this._additionsTail._nextAdded = record;
              this._additionsTail = record;
            }
          },
          _addToChanges: function(record) {
            if (this._changesHead === null) {
              this._changesHead = this._changesTail = record;
            } else {
              this._changesTail._nextChanged = record;
              this._changesTail = record;
            }
          },
          toString: function() {
            var items = [];
            var previous = [];
            var changes = [];
            var additions = [];
            var removals = [];
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
              items.push(stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              previous.push(stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
              changes.push(stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              additions.push(stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              removals.push(stringify(record));
            }
            return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" + "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" + "removals: " + removals.join(', ') + "\n";
          },
          _forEach: function(obj, fn) {
            if (obj instanceof Map) {
              MapWrapper.forEach(obj, fn);
            } else {
              StringMapWrapper.forEach(obj, fn);
            }
          }
        }, {supportsObj: function(obj) {
            return obj instanceof Map || isJsObject(obj);
          }}, $__super);
      }(BasePipe));
      $__export("KeyValueChanges", KeyValueChanges);
      KVChangeRecord = (function() {
        function KVChangeRecord(key) {
          this.key = key;
          this.previousValue = null;
          this.currentValue = null;
          this._nextPrevious = null;
          this._next = null;
          this._nextAdded = null;
          this._nextRemoved = null;
          this._prevRemoved = null;
          this._nextChanged = null;
        }
        return ($traceurRuntime.createClass)(KVChangeRecord, {toString: function() {
            return looseIdentical(this.previousValue, this.currentValue) ? stringify(this.key) : (stringify(this.key) + '[' + stringify(this.previousValue) + '->' + stringify(this.currentValue) + ']');
          }}, {});
      }());
      $__export("KVChangeRecord", KVChangeRecord);
    }
  };
});

System.register("angular2/src/change_detection/pipes/observable_pipe", ["angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/observable_pipe";
  var __decorate,
      __metadata,
      ObservableWrapper,
      isBlank,
      isPresent,
      CONST,
      WrappedValue,
      ObservablePipe,
      ObservablePipeFactory;
  return {
    setters: [function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      CONST = $__m.CONST;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ObservablePipe = (function() {
        function ObservablePipe(_ref) {
          this._ref = _ref;
          this._latestValue = null;
          this._latestReturnedValue = null;
          this._subscription = null;
          this._observable = null;
        }
        return ($traceurRuntime.createClass)(ObservablePipe, {
          supports: function(obs) {
            return ObservableWrapper.isObservable(obs);
          },
          onDestroy: function() {
            if (isPresent(this._subscription)) {
              this._dispose();
            }
          },
          transform: function(obs) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isBlank(this._subscription)) {
              this._subscribe(obs);
              return null;
            }
            if (obs !== this._observable) {
              this._dispose();
              return this.transform(obs);
            }
            if (this._latestValue === this._latestReturnedValue) {
              return this._latestReturnedValue;
            } else {
              this._latestReturnedValue = this._latestValue;
              return WrappedValue.wrap(this._latestValue);
            }
          },
          _subscribe: function(obs) {
            var $__0 = this;
            this._observable = obs;
            this._subscription = ObservableWrapper.subscribe(obs, (function(value) {
              return $__0._updateLatestValue(value);
            }), (function(e) {
              throw e;
            }));
          },
          _dispose: function() {
            ObservableWrapper.dispose(this._subscription);
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._observable = null;
          },
          _updateLatestValue: function(value) {
            this._latestValue = value;
            this._ref.requestCheck();
          }
        }, {});
      }());
      $__export("ObservablePipe", ObservablePipe);
      ObservablePipeFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obs) {
          return ObservableWrapper.isObservable(obs);
        },
        create: function(cdRef) {
          return new ObservablePipe(cdRef);
        }
      }, {}));
      $__export("ObservablePipeFactory", ObservablePipeFactory);
      $__export("ObservablePipeFactory", ObservablePipeFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], ObservablePipeFactory));
    }
  };
});

System.register("angular2/src/change_detection/pipes/promise_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/promise_pipe";
  var __decorate,
      __metadata,
      isBlank,
      isPresent,
      isPromise,
      CONST,
      WrappedValue,
      PromisePipe,
      PromisePipeFactory;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      isPromise = $__m.isPromise;
      CONST = $__m.CONST;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      PromisePipe = (function() {
        function PromisePipe(_ref) {
          this._ref = _ref;
          this._latestValue = null;
          this._latestReturnedValue = null;
        }
        return ($traceurRuntime.createClass)(PromisePipe, {
          supports: function(promise) {
            return isPromise(promise);
          },
          onDestroy: function() {
            if (isPresent(this._sourcePromise)) {
              this._latestValue = null;
              this._latestReturnedValue = null;
              this._sourcePromise = null;
            }
          },
          transform: function(promise) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            var $__0 = this;
            if (isBlank(this._sourcePromise)) {
              this._sourcePromise = promise;
              promise.then((function(val) {
                if ($__0._sourcePromise === promise) {
                  $__0._updateLatestValue(val);
                }
              }));
              return null;
            }
            if (promise !== this._sourcePromise) {
              this._sourcePromise = null;
              return this.transform(promise);
            }
            if (this._latestValue === this._latestReturnedValue) {
              return this._latestReturnedValue;
            } else {
              this._latestReturnedValue = this._latestValue;
              return WrappedValue.wrap(this._latestValue);
            }
          },
          _updateLatestValue: function(value) {
            this._latestValue = value;
            this._ref.requestCheck();
          }
        }, {});
      }());
      $__export("PromisePipe", PromisePipe);
      PromisePipeFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(promise) {
          return isPromise(promise);
        },
        create: function(cdRef) {
          return new PromisePipe(cdRef);
        }
      }, {}));
      $__export("PromisePipeFactory", PromisePipeFactory);
      $__export("PromisePipeFactory", PromisePipeFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], PromisePipeFactory));
    }
  };
});

System.register("angular2/src/change_detection/pipes/uppercase_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/uppercase_pipe";
  var __decorate,
      __metadata,
      isString,
      StringWrapper,
      CONST,
      BasePipe,
      UpperCasePipe;
  return {
    setters: [function($__m) {
      isString = $__m.isString;
      StringWrapper = $__m.StringWrapper;
      CONST = $__m.CONST;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      UpperCasePipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {
          supports: function(str) {
            return isString(str);
          },
          transform: function(value) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            return StringWrapper.toUpperCase(value);
          },
          create: function(cdRef) {
            return this;
          }
        }, {}, $__super);
      }(BasePipe));
      $__export("UpperCasePipe", UpperCasePipe);
      $__export("UpperCasePipe", UpperCasePipe = __decorate([CONST(), __metadata('design:paramtypes', [])], UpperCasePipe));
    }
  };
});

System.register("angular2/src/change_detection/pipes/lowercase_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/lowercase_pipe";
  var __decorate,
      __metadata,
      isString,
      StringWrapper,
      CONST,
      BasePipe,
      LowerCasePipe;
  return {
    setters: [function($__m) {
      isString = $__m.isString;
      StringWrapper = $__m.StringWrapper;
      CONST = $__m.CONST;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LowerCasePipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {
          supports: function(str) {
            return isString(str);
          },
          transform: function(value) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            return StringWrapper.toLowerCase(value);
          },
          create: function(cdRef) {
            return this;
          }
        }, {}, $__super);
      }(BasePipe));
      $__export("LowerCasePipe", LowerCasePipe);
      $__export("LowerCasePipe", LowerCasePipe = __decorate([CONST(), __metadata('design:paramtypes', [])], LowerCasePipe));
    }
  };
});

System.register("angular2/src/change_detection/pipes/json_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/json_pipe";
  var __decorate,
      __metadata,
      Json,
      CONST,
      BasePipe,
      JsonPipe;
  return {
    setters: [function($__m) {
      Json = $__m.Json;
      CONST = $__m.CONST;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      JsonPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {
          transform: function(value) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            return Json.stringify(value);
          },
          create: function(cdRef) {
            return this;
          }
        }, {}, $__super);
      }(BasePipe));
      $__export("JsonPipe", JsonPipe);
      $__export("JsonPipe", JsonPipe = __decorate([CONST(), __metadata('design:paramtypes', [])], JsonPipe));
    }
  };
});

System.register("angular2/src/facade/math", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/math";
  var global,
      Math,
      NaN;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      Math = global.Math;
      $__export("Math", Math);
      NaN = typeof NaN;
      $__export("NaN", NaN);
    }
  };
});

System.register("angular2/src/facade/intl", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/intl";
  var NumberFormatStyle,
      NumberFormatter,
      dateFormatterCache,
      DateFormatter;
  function digitCondition(len) {
    return len == 2 ? '2-digit' : 'numeric';
  }
  function nameCondition(len) {
    return len < 4 ? 'short' : 'long';
  }
  function extractComponents(pattern) {
    var ret = {};
    var i = 0,
        j;
    while (i < pattern.length) {
      j = i;
      while (j < pattern.length && pattern[j] == pattern[i])
        j++;
      var len = j - i;
      switch (pattern[i]) {
        case 'G':
          ret.era = nameCondition(len);
          break;
        case 'y':
          ret.year = digitCondition(len);
          break;
        case 'M':
          if (len >= 3)
            ret.month = nameCondition(len);
          else
            ret.month = digitCondition(len);
          break;
        case 'd':
          ret.day = digitCondition(len);
          break;
        case 'E':
          ret.weekday = nameCondition(len);
          break;
        case 'j':
          ret.hour = digitCondition(len);
          break;
        case 'h':
          ret.hour = digitCondition(len);
          ret.hour12 = true;
          break;
        case 'H':
          ret.hour = digitCondition(len);
          ret.hour12 = false;
          break;
        case 'm':
          ret.minute = digitCondition(len);
          break;
        case 's':
          ret.second = digitCondition(len);
          break;
        case 'z':
          ret.timeZoneName = 'long';
          break;
        case 'Z':
          ret.timeZoneName = 'short';
          break;
      }
      i = j;
    }
    return ret;
  }
  return {
    setters: [],
    execute: function() {
      $__export("NumberFormatStyle", NumberFormatStyle);
      (function(NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle["DECIMAL"] = 0] = "DECIMAL";
        NumberFormatStyle[NumberFormatStyle["PERCENT"] = 1] = "PERCENT";
        NumberFormatStyle[NumberFormatStyle["CURRENCY"] = 2] = "CURRENCY";
      })(NumberFormatStyle || ($__export("NumberFormatStyle", NumberFormatStyle = {})));
      NumberFormatter = (function() {
        function NumberFormatter() {}
        return ($traceurRuntime.createClass)(NumberFormatter, {}, {format: function(number, locale, style) {
            var $__2,
                $__3,
                $__4,
                $__5;
            var $__1 = arguments[3] !== (void 0) ? arguments[3] : {},
                minimumIntegerDigits = ($__2 = $__1.minimumIntegerDigits) === void 0 ? 1 : $__2,
                minimumFractionDigits = ($__3 = $__1.minimumFractionDigits) === void 0 ? 0 : $__3,
                maximumFractionDigits = ($__4 = $__1.maximumFractionDigits) === void 0 ? 3 : $__4,
                currency = $__1.currency,
                currencyAsSymbol = ($__5 = $__1.currencyAsSymbol) === void 0 ? false : $__5;
            var intlOptions = {
              minimumIntegerDigits: minimumIntegerDigits,
              minimumFractionDigits: minimumFractionDigits,
              maximumFractionDigits: maximumFractionDigits
            };
            intlOptions.style = NumberFormatStyle[style].toLowerCase();
            if (style == NumberFormatStyle.CURRENCY) {
              intlOptions.currency = currency;
              intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
            }
            return new Intl.NumberFormat(locale, intlOptions).format(number);
          }});
      }());
      $__export("NumberFormatter", NumberFormatter);
      dateFormatterCache = new Map();
      DateFormatter = (function() {
        function DateFormatter() {}
        return ($traceurRuntime.createClass)(DateFormatter, {}, {format: function(date, locale, pattern) {
            var key = locale + pattern;
            if (dateFormatterCache.has(key)) {
              return dateFormatterCache.get(key).format(date);
            }
            var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
            dateFormatterCache.set(key, formatter);
            return formatter.format(date);
          }});
      }());
      $__export("DateFormatter", DateFormatter);
    }
  };
});

System.register("angular2/src/change_detection/pipes/number_pipe", ["angular2/src/facade/lang", "angular2/src/facade/intl", "angular2/src/facade/collection", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/number_pipe";
  var __decorate,
      __metadata,
      isNumber,
      isPresent,
      isBlank,
      NumberWrapper,
      RegExpWrapper,
      BaseException,
      CONST,
      NumberFormatter,
      NumberFormatStyle,
      ListWrapper,
      BasePipe,
      defaultLocale,
      _re,
      NumberPipe,
      DecimalPipe,
      PercentPipe,
      CurrencyPipe;
  return {
    setters: [function($__m) {
      isNumber = $__m.isNumber;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      NumberWrapper = $__m.NumberWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      NumberFormatter = $__m.NumberFormatter;
      NumberFormatStyle = $__m.NumberFormatStyle;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      defaultLocale = 'en-US';
      _re = RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
      NumberPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {
          supports: function(obj) {
            return isNumber(obj);
          },
          create: function(cdRef) {
            return this;
          }
        }, {_format: function(value, style, digits) {
            var currency = arguments[3] !== (void 0) ? arguments[3] : null;
            var currencyAsSymbol = arguments[4] !== (void 0) ? arguments[4] : false;
            var minInt = 1,
                minFraction = 0,
                maxFraction = 3;
            if (isPresent(digits)) {
              var parts = RegExpWrapper.firstMatch(_re, digits);
              if (isBlank(parts)) {
                throw new BaseException((digits + " is not a valid digit info for number pipes"));
              }
              if (isPresent(parts[1])) {
                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
              }
              if (isPresent(parts[3])) {
                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
              }
              if (isPresent(parts[5])) {
                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
              }
            }
            return NumberFormatter.format(value, defaultLocale, style, {
              minimumIntegerDigits: minInt,
              minimumFractionDigits: minFraction,
              maximumFractionDigits: maxFraction,
              currency: currency,
              currencyAsSymbol: currencyAsSymbol
            });
          }}, $__super);
      }(BasePipe));
      $__export("NumberPipe", NumberPipe);
      $__export("NumberPipe", NumberPipe = __decorate([CONST(), __metadata('design:paramtypes', [])], NumberPipe));
      DecimalPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var digits = ListWrapper.first(args);
            return NumberPipe._format(value, NumberFormatStyle.DECIMAL, digits);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("DecimalPipe", DecimalPipe);
      $__export("DecimalPipe", DecimalPipe = __decorate([CONST(), __metadata('design:paramtypes', [])], DecimalPipe));
      PercentPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var digits = ListWrapper.first(args);
            return NumberPipe._format(value, NumberFormatStyle.PERCENT, digits);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("PercentPipe", PercentPipe);
      $__export("PercentPipe", PercentPipe = __decorate([CONST(), __metadata('design:paramtypes', [])], PercentPipe));
      CurrencyPipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {transform: function(value, args) {
            var currencyCode = isPresent(args) && args.length > 0 ? args[0] : 'USD';
            var symbolDisplay = isPresent(args) && args.length > 1 ? args[1] : false;
            var digits = isPresent(args) && args.length > 2 ? args[2] : null;
            return NumberPipe._format(value, NumberFormatStyle.CURRENCY, digits, currencyCode, symbolDisplay);
          }}, {}, $__super);
      }(NumberPipe));
      $__export("CurrencyPipe", CurrencyPipe);
      $__export("CurrencyPipe", CurrencyPipe = __decorate([CONST(), __metadata('design:paramtypes', [])], CurrencyPipe));
    }
  };
});

System.register("angular2/src/change_detection/pipes/null_pipe", ["angular2/src/facade/lang", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/null_pipe";
  var __decorate,
      __metadata,
      isBlank,
      CONST,
      BasePipe,
      WrappedValue,
      NullPipeFactory,
      NullPipe;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      CONST = $__m.CONST;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
      WrappedValue = $__m.WrappedValue;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NullPipeFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return NullPipe.supportsObj(obj);
        },
        create: function(cdRef) {
          return new NullPipe();
        }
      }, {}));
      $__export("NullPipeFactory", NullPipeFactory);
      $__export("NullPipeFactory", NullPipeFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], NullPipeFactory));
      NullPipe = (function($__super) {
        function NullPipe() {
          var $__3;
          for (var args = [],
              $__2 = 0; $__2 < arguments.length; $__2++)
            args[$__2] = arguments[$__2];
          ($__3 = $traceurRuntime.superConstructor(NullPipe)).call.apply($__3, $traceurRuntime.spread([this], args));
          this.called = false;
        }
        return ($traceurRuntime.createClass)(NullPipe, {
          supports: function(obj) {
            return NullPipe.supportsObj(obj);
          },
          transform: function(value) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            if (!this.called) {
              this.called = true;
              return WrappedValue.wrap(null);
            } else {
              return null;
            }
          }
        }, {supportsObj: function(obj) {
            return isBlank(obj);
          }}, $__super);
      }(BasePipe));
      $__export("NullPipe", NullPipe);
    }
  };
});

System.register("angular2/src/change_detection/interfaces", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/interfaces";
  var __decorate,
      __metadata,
      CONST,
      ChangeDetection,
      ChangeDetectorDefinition;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ChangeDetection = (($traceurRuntime.createClass)(function() {}, {createProtoChangeDetector: function(definition) {
          return null;
        }}, {}));
      $__export("ChangeDetection", ChangeDetection);
      $__export("ChangeDetection", ChangeDetection = __decorate([CONST(), __metadata('design:paramtypes', [])], ChangeDetection));
      ChangeDetectorDefinition = (function() {
        function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, directiveRecords, generateCheckNoChanges) {
          this.id = id;
          this.strategy = strategy;
          this.variableNames = variableNames;
          this.bindingRecords = bindingRecords;
          this.directiveRecords = directiveRecords;
          this.generateCheckNoChanges = generateCheckNoChanges;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorDefinition, {}, {});
      }());
      $__export("ChangeDetectorDefinition", ChangeDetectorDefinition);
    }
  };
});

System.register("angular2/src/change_detection/parser/lexer", ["angular2/src/di/decorators", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/lexer";
  var __decorate,
      __metadata,
      Injectable,
      SetWrapper,
      NumberWrapper,
      StringJoiner,
      StringWrapper,
      BaseException,
      isPresent,
      TokenType,
      Lexer,
      Token,
      EOF,
      $EOF,
      $TAB,
      $LF,
      $VTAB,
      $FF,
      $CR,
      $SPACE,
      $BANG,
      $DQ,
      $HASH,
      $$,
      $PERCENT,
      $AMPERSAND,
      $SQ,
      $LPAREN,
      $RPAREN,
      $STAR,
      $PLUS,
      $COMMA,
      $MINUS,
      $PERIOD,
      $SLASH,
      $COLON,
      $SEMICOLON,
      $LT,
      $EQ,
      $GT,
      $QUESTION,
      $0,
      $9,
      $A,
      $E,
      $Z,
      $LBRACKET,
      $BACKSLASH,
      $RBRACKET,
      $CARET,
      $_,
      $a,
      $e,
      $f,
      $n,
      $r,
      $t,
      $u,
      $v,
      $z,
      $LBRACE,
      $BAR,
      $RBRACE,
      $NBSP,
      ScannerError,
      _Scanner,
      OPERATORS,
      KEYWORDS;
  function newCharacterToken(index, code) {
    return new Token(index, TokenType.CHARACTER, code, StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
    return new Token(index, TokenType.IDENTIFIER, 0, text);
  }
  function newKeywordToken(index, text) {
    return new Token(index, TokenType.KEYWORD, 0, text);
  }
  function newOperatorToken(index, text) {
    return new Token(index, TokenType.OPERATOR, 0, text);
  }
  function newStringToken(index, text) {
    return new Token(index, TokenType.STRING, 0, text);
  }
  function newNumberToken(index, n) {
    return new Token(index, TokenType.NUMBER, n, "");
  }
  function isWhitespace(code) {
    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isIdentifierStart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == $$);
  }
  function isIdentifierPart(code) {
    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) || (code == $_) || (code == $$);
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      NumberWrapper = $__m.NumberWrapper;
      StringJoiner = $__m.StringJoiner;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      $__export("TokenType", TokenType);
      (function(TokenType) {
        TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
        TokenType[TokenType["IDENTIFIER"] = 1] = "IDENTIFIER";
        TokenType[TokenType["KEYWORD"] = 2] = "KEYWORD";
        TokenType[TokenType["STRING"] = 3] = "STRING";
        TokenType[TokenType["OPERATOR"] = 4] = "OPERATOR";
        TokenType[TokenType["NUMBER"] = 5] = "NUMBER";
      })(TokenType || ($__export("TokenType", TokenType = {})));
      Lexer = (($traceurRuntime.createClass)(function() {}, {tokenize: function(text) {
          var scanner = new _Scanner(text);
          var tokens = [];
          var token = scanner.scanToken();
          while (token != null) {
            tokens.push(token);
            token = scanner.scanToken();
          }
          return tokens;
        }}, {}));
      $__export("Lexer", Lexer);
      $__export("Lexer", Lexer = __decorate([Injectable(), __metadata('design:paramtypes', [])], Lexer));
      Token = (function() {
        function Token(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this.numValue = numValue;
          this.strValue = strValue;
        }
        return ($traceurRuntime.createClass)(Token, {
          isCharacter: function(code) {
            return (this.type == TokenType.CHARACTER && this.numValue == code);
          },
          isNumber: function() {
            return (this.type == TokenType.NUMBER);
          },
          isString: function() {
            return (this.type == TokenType.STRING);
          },
          isOperator: function(operater) {
            return (this.type == TokenType.OPERATOR && this.strValue == operater);
          },
          isIdentifier: function() {
            return (this.type == TokenType.IDENTIFIER);
          },
          isKeyword: function() {
            return (this.type == TokenType.KEYWORD);
          },
          isKeywordVar: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "var");
          },
          isKeywordNull: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "null");
          },
          isKeywordUndefined: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "undefined");
          },
          isKeywordTrue: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "true");
          },
          isKeywordIf: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "if");
          },
          isKeywordElse: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "else");
          },
          isKeywordFalse: function() {
            return (this.type == TokenType.KEYWORD && this.strValue == "false");
          },
          toNumber: function() {
            return (this.type == TokenType.NUMBER) ? this.numValue : -1;
          },
          toString: function() {
            switch (this.type) {
              case TokenType.CHARACTER:
              case TokenType.STRING:
              case TokenType.IDENTIFIER:
              case TokenType.KEYWORD:
                return this.strValue;
              case TokenType.NUMBER:
                return this.numValue.toString();
              default:
                return null;
            }
          }
        }, {});
      }());
      $__export("Token", Token);
      EOF = new Token(-1, TokenType.CHARACTER, 0, "");
      $__export("EOF", EOF);
      $EOF = 0;
      $__export("$EOF", $EOF);
      $TAB = 9;
      $__export("$TAB", $TAB);
      $LF = 10;
      $__export("$LF", $LF);
      $VTAB = 11;
      $__export("$VTAB", $VTAB);
      $FF = 12;
      $__export("$FF", $FF);
      $CR = 13;
      $__export("$CR", $CR);
      $SPACE = 32;
      $__export("$SPACE", $SPACE);
      $BANG = 33;
      $__export("$BANG", $BANG);
      $DQ = 34;
      $__export("$DQ", $DQ);
      $HASH = 35;
      $__export("$HASH", $HASH);
      $$ = 36;
      $__export("$$", $$);
      $PERCENT = 37;
      $__export("$PERCENT", $PERCENT);
      $AMPERSAND = 38;
      $__export("$AMPERSAND", $AMPERSAND);
      $SQ = 39;
      $__export("$SQ", $SQ);
      $LPAREN = 40;
      $__export("$LPAREN", $LPAREN);
      $RPAREN = 41;
      $__export("$RPAREN", $RPAREN);
      $STAR = 42;
      $__export("$STAR", $STAR);
      $PLUS = 43;
      $__export("$PLUS", $PLUS);
      $COMMA = 44;
      $__export("$COMMA", $COMMA);
      $MINUS = 45;
      $__export("$MINUS", $MINUS);
      $PERIOD = 46;
      $__export("$PERIOD", $PERIOD);
      $SLASH = 47;
      $__export("$SLASH", $SLASH);
      $COLON = 58;
      $__export("$COLON", $COLON);
      $SEMICOLON = 59;
      $__export("$SEMICOLON", $SEMICOLON);
      $LT = 60;
      $__export("$LT", $LT);
      $EQ = 61;
      $__export("$EQ", $EQ);
      $GT = 62;
      $__export("$GT", $GT);
      $QUESTION = 63;
      $__export("$QUESTION", $QUESTION);
      $0 = 48;
      $9 = 57;
      $A = 65, $E = 69, $Z = 90;
      $LBRACKET = 91;
      $__export("$LBRACKET", $LBRACKET);
      $BACKSLASH = 92;
      $__export("$BACKSLASH", $BACKSLASH);
      $RBRACKET = 93;
      $__export("$RBRACKET", $RBRACKET);
      $CARET = 94;
      $_ = 95;
      $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
      $LBRACE = 123;
      $__export("$LBRACE", $LBRACE);
      $BAR = 124;
      $__export("$BAR", $BAR);
      $RBRACE = 125;
      $__export("$RBRACE", $RBRACE);
      $NBSP = 160;
      ScannerError = (function($__super) {
        function ScannerError(message) {
          $traceurRuntime.superConstructor(ScannerError).call(this);
          this.message = message;
        }
        return ($traceurRuntime.createClass)(ScannerError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("ScannerError", ScannerError);
      _Scanner = (function() {
        function _Scanner(input) {
          this.input = input;
          this.peek = 0;
          this.index = -1;
          this.length = input.length;
          this.advance();
        }
        return ($traceurRuntime.createClass)(_Scanner, {
          advance: function() {
            this.peek = ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
          },
          scanToken: function() {
            var input = this.input,
                length = this.length,
                peek = this.peek,
                index = this.index;
            while (peek <= $SPACE) {
              if (++index >= length) {
                peek = $EOF;
                break;
              } else {
                peek = StringWrapper.charCodeAt(input, index);
              }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
              return null;
            }
            if (isIdentifierStart(peek))
              return this.scanIdentifier();
            if (isDigit(peek))
              return this.scanNumber(index);
            var start = index;
            switch (peek) {
              case $PERIOD:
                this.advance();
                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                return this.scanString();
              case $HASH:
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
                return this.scanOperator(start, StringWrapper.fromCharCode(peek));
              case $QUESTION:
                return this.scanComplexOperator(start, '?', $PERIOD, '.');
              case $LT:
              case $GT:
                return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=');
              case $BANG:
              case $EQ:
                return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=', $EQ, '=');
              case $AMPERSAND:
                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
              case $BAR:
                return this.scanComplexOperator(start, '|', $BAR, '|');
              case $NBSP:
                while (isWhitespace(this.peek))
                  this.advance();
                return this.scanToken();
            }
            this.error(("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]"), 0);
            return null;
          },
          scanCharacter: function(start, code) {
            assert(this.peek == code);
            this.advance();
            return newCharacterToken(start, code);
          },
          scanOperator: function(start, str) {
            assert(this.peek == StringWrapper.charCodeAt(str, 0));
            assert(SetWrapper.has(OPERATORS, str));
            this.advance();
            return newOperatorToken(start, str);
          },
          scanComplexOperator: function(start, one, twoCode, two, threeCode, three) {
            assert(this.peek == StringWrapper.charCodeAt(one, 0));
            this.advance();
            var str = one;
            if (this.peek == twoCode) {
              this.advance();
              str += two;
            }
            if (isPresent(threeCode) && this.peek == threeCode) {
              this.advance();
              str += three;
            }
            assert(SetWrapper.has(OPERATORS, str));
            return newOperatorToken(start, str);
          },
          scanIdentifier: function() {
            assert(isIdentifierStart(this.peek));
            var start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
              this.advance();
            var str = this.input.substring(start, this.index);
            if (SetWrapper.has(KEYWORDS, str)) {
              return newKeywordToken(start, str);
            } else {
              return newIdentifierToken(start, str);
            }
          },
          scanNumber: function(start) {
            assert(isDigit(this.peek));
            var simple = (this.index === start);
            this.advance();
            while (true) {
              if (isDigit(this.peek)) {} else if (this.peek == $PERIOD) {
                simple = false;
              } else if (isExponentStart(this.peek)) {
                this.advance();
                if (isExponentSign(this.peek))
                  this.advance();
                if (!isDigit(this.peek))
                  this.error('Invalid exponent', -1);
                simple = false;
              } else {
                break;
              }
              this.advance();
            }
            var str = this.input.substring(start, this.index);
            var value = simple ? NumberWrapper.parseIntAutoRadix(str) : NumberWrapper.parseFloat(str);
            return newNumberToken(start, value);
          },
          scanString: function() {
            assert(this.peek == $SQ || this.peek == $DQ);
            var start = this.index;
            var quote = this.peek;
            this.advance();
            var buffer;
            var marker = this.index;
            var input = this.input;
            while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                if (buffer == null)
                  buffer = new StringJoiner();
                buffer.add(input.substring(marker, this.index));
                this.advance();
                var unescapedCode = void 0;
                if (this.peek == $u) {
                  var hex = input.substring(this.index + 1, this.index + 5);
                  try {
                    unescapedCode = NumberWrapper.parseInt(hex, 16);
                  } catch (e) {
                    this.error(("Invalid unicode escape [\\u" + hex + "]"), 0);
                  }
                  for (var i = 0; i < 5; i++) {
                    this.advance();
                  }
                } else {
                  unescapedCode = unescape(this.peek);
                  this.advance();
                }
                buffer.add(StringWrapper.fromCharCode(unescapedCode));
                marker = this.index;
              } else if (this.peek == $EOF) {
                this.error('Unterminated quote', 0);
              } else {
                this.advance();
              }
            }
            var last = input.substring(marker, this.index);
            this.advance();
            var unescaped = last;
            if (buffer != null) {
              buffer.add(last);
              unescaped = buffer.toString();
            }
            return newStringToken(start, unescaped);
          },
          error: function(message, offset) {
            var position = this.index + offset;
            throw new ScannerError(("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]"));
          }
        }, {});
      }());
      OPERATORS = SetWrapper.createFromList(['+', '-', '*', '/', '%', '^', '=', '==', '!=', '===', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?', '#', '?.']);
      KEYWORDS = SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);
    }
  };
});

System.register("angular2/src/change_detection/parser/parser", ["angular2/src/di/decorators", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/lexer", "angular2/src/reflection/reflection", "angular2/src/change_detection/parser/ast"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/parser";
  var __decorate,
      __metadata,
      Injectable,
      isBlank,
      isPresent,
      BaseException,
      StringWrapper,
      ListWrapper,
      Lexer,
      EOF,
      $PERIOD,
      $COLON,
      $SEMICOLON,
      $LBRACKET,
      $RBRACKET,
      $COMMA,
      $LBRACE,
      $RBRACE,
      $LPAREN,
      $RPAREN,
      reflector,
      Reflector,
      EmptyExpr,
      ImplicitReceiver,
      AccessMember,
      SafeAccessMember,
      LiteralPrimitive,
      Binary,
      PrefixNot,
      Conditional,
      If,
      BindingPipe,
      Assignment,
      Chain,
      KeyedAccess,
      LiteralArray,
      LiteralMap,
      Interpolation,
      MethodCall,
      SafeMethodCall,
      FunctionCall,
      TemplateBinding,
      ASTWithSource,
      _implicitReceiver,
      INTERPOLATION_REGEXP,
      Parser,
      _ParseAST,
      SimpleExpressionChecker;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Lexer = $__m.Lexer;
      EOF = $__m.EOF;
      $PERIOD = $__m.$PERIOD;
      $COLON = $__m.$COLON;
      $SEMICOLON = $__m.$SEMICOLON;
      $LBRACKET = $__m.$LBRACKET;
      $RBRACKET = $__m.$RBRACKET;
      $COMMA = $__m.$COMMA;
      $LBRACE = $__m.$LBRACE;
      $RBRACE = $__m.$RBRACE;
      $LPAREN = $__m.$LPAREN;
      $RPAREN = $__m.$RPAREN;
    }, function($__m) {
      reflector = $__m.reflector;
      Reflector = $__m.Reflector;
    }, function($__m) {
      EmptyExpr = $__m.EmptyExpr;
      ImplicitReceiver = $__m.ImplicitReceiver;
      AccessMember = $__m.AccessMember;
      SafeAccessMember = $__m.SafeAccessMember;
      LiteralPrimitive = $__m.LiteralPrimitive;
      Binary = $__m.Binary;
      PrefixNot = $__m.PrefixNot;
      Conditional = $__m.Conditional;
      If = $__m.If;
      BindingPipe = $__m.BindingPipe;
      Assignment = $__m.Assignment;
      Chain = $__m.Chain;
      KeyedAccess = $__m.KeyedAccess;
      LiteralArray = $__m.LiteralArray;
      LiteralMap = $__m.LiteralMap;
      Interpolation = $__m.Interpolation;
      MethodCall = $__m.MethodCall;
      SafeMethodCall = $__m.SafeMethodCall;
      FunctionCall = $__m.FunctionCall;
      TemplateBinding = $__m.TemplateBinding;
      ASTWithSource = $__m.ASTWithSource;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _implicitReceiver = new ImplicitReceiver();
      INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
      Parser = (($traceurRuntime.createClass)(function(_lexer) {
        var providedReflector = arguments[1] !== (void 0) ? arguments[1] : null;
        this._lexer = _lexer;
        this._reflector = isPresent(providedReflector) ? providedReflector : reflector;
      }, {
        parseAction: function(input, location) {
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
          return new ASTWithSource(ast, input, location);
        },
        parseBinding: function(input, location) {
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
          return new ASTWithSource(ast, input, location);
        },
        parseSimpleBinding: function(input, location) {
          var tokens = this._lexer.tokenize(input);
          var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
          return new ASTWithSource(ast, input, location);
        },
        parseTemplateBindings: function(input, location) {
          var tokens = this._lexer.tokenize(input);
          return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
        },
        parseInterpolation: function(input, location) {
          var parts = StringWrapper.split(input, INTERPOLATION_REGEXP);
          if (parts.length <= 1) {
            return null;
          }
          var strings = [];
          var expressions = [];
          for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (i % 2 === 0) {
              strings.push(part);
            } else {
              var tokens = this._lexer.tokenize(part);
              var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
              expressions.push(ast);
            }
          }
          return new ASTWithSource(new Interpolation(strings, expressions), input, location);
        },
        wrapLiteralPrimitive: function(input, location) {
          return new ASTWithSource(new LiteralPrimitive(input), input, location);
        }
      }, {}));
      $__export("Parser", Parser);
      $__export("Parser", Parser = __decorate([Injectable(), __metadata('design:paramtypes', [Lexer, Reflector])], Parser));
      _ParseAST = (function() {
        function _ParseAST(input, location, tokens, reflector, parseAction) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.reflector = reflector;
          this.parseAction = parseAction;
          this.index = 0;
        }
        return ($traceurRuntime.createClass)(_ParseAST, {
          peek: function(offset) {
            var i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
          },
          get next() {
            return this.peek(0);
          },
          get inputIndex() {
            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
          },
          advance: function() {
            this.index++;
          },
          optionalCharacter: function(code) {
            if (this.next.isCharacter(code)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          optionalKeywordVar: function() {
            if (this.peekKeywordVar()) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          peekKeywordVar: function() {
            return this.next.isKeywordVar() || this.next.isOperator('#');
          },
          expectCharacter: function(code) {
            if (this.optionalCharacter(code))
              return ;
            this.error(("Missing expected " + StringWrapper.fromCharCode(code)));
          },
          optionalOperator: function(op) {
            if (this.next.isOperator(op)) {
              this.advance();
              return true;
            } else {
              return false;
            }
          },
          expectOperator: function(operator) {
            if (this.optionalOperator(operator))
              return ;
            this.error(("Missing expected operator " + operator));
          },
          expectIdentifierOrKeyword: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
              this.error(("Unexpected token " + n + ", expected identifier or keyword"));
            }
            this.advance();
            return n.toString();
          },
          expectIdentifierOrKeywordOrString: function() {
            var n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error(("Unexpected token " + n + ", expected identifier, keyword, or string"));
            }
            this.advance();
            return n.toString();
          },
          parseChain: function() {
            var exprs = [];
            while (this.index < this.tokens.length) {
              var expr = this.parsePipe();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                if (!this.parseAction) {
                  this.error("Binding expression cannot contain chained expression");
                }
                while (this.optionalCharacter($SEMICOLON)) {}
              } else if (this.index < this.tokens.length) {
                this.error(("Unexpected token '" + this.next + "'"));
              }
            }
            if (exprs.length == 0)
              return new EmptyExpr();
            if (exprs.length == 1)
              return exprs[0];
            return new Chain(exprs);
          },
          parseSimpleBinding: function() {
            var ast = this.parseChain();
            if (!SimpleExpressionChecker.check(ast)) {
              this.error("Simple binding expression can only contain field access and constants'");
            }
            return ast;
          },
          parsePipe: function() {
            var result = this.parseExpression();
            if (this.optionalOperator("|")) {
              if (this.parseAction) {
                this.error("Cannot have a pipe in an action expression");
              }
              do {
                var name = this.expectIdentifierOrKeyword();
                var args = [];
                while (this.optionalCharacter($COLON)) {
                  args.push(this.parsePipe());
                }
                result = new BindingPipe(result, name, args);
              } while (this.optionalOperator("|"));
            }
            return result;
          },
          parseExpression: function() {
            var start = this.inputIndex;
            var result = this.parseConditional();
            while (this.next.isOperator('=')) {
              if (!result.isAssignable) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error(("Expression " + expression + " is not assignable"));
              }
              if (!this.parseAction) {
                this.error("Binding expression cannot contain assignments");
              }
              this.expectOperator('=');
              result = new Assignment(result, this.parseConditional());
            }
            return result;
          },
          parseConditional: function() {
            var start = this.inputIndex;
            var result = this.parseLogicalOr();
            if (this.optionalOperator('?')) {
              var yes = this.parsePipe();
              if (!this.optionalCharacter($COLON)) {
                var end = this.inputIndex;
                var expression = this.input.substring(start, end);
                this.error(("Conditional expression " + expression + " requires all 3 expressions"));
              }
              var no = this.parsePipe();
              return new Conditional(result, yes, no);
            } else {
              return result;
            }
          },
          parseLogicalOr: function() {
            var result = this.parseLogicalAnd();
            while (this.optionalOperator('||')) {
              result = new Binary('||', result, this.parseLogicalAnd());
            }
            return result;
          },
          parseLogicalAnd: function() {
            var result = this.parseEquality();
            while (this.optionalOperator('&&')) {
              result = new Binary('&&', result, this.parseEquality());
            }
            return result;
          },
          parseEquality: function() {
            var result = this.parseRelational();
            while (true) {
              if (this.optionalOperator('==')) {
                result = new Binary('==', result, this.parseRelational());
              } else if (this.optionalOperator('===')) {
                result = new Binary('===', result, this.parseRelational());
              } else if (this.optionalOperator('!=')) {
                result = new Binary('!=', result, this.parseRelational());
              } else if (this.optionalOperator('!==')) {
                result = new Binary('!==', result, this.parseRelational());
              } else {
                return result;
              }
            }
          },
          parseRelational: function() {
            var result = this.parseAdditive();
            while (true) {
              if (this.optionalOperator('<')) {
                result = new Binary('<', result, this.parseAdditive());
              } else if (this.optionalOperator('>')) {
                result = new Binary('>', result, this.parseAdditive());
              } else if (this.optionalOperator('<=')) {
                result = new Binary('<=', result, this.parseAdditive());
              } else if (this.optionalOperator('>=')) {
                result = new Binary('>=', result, this.parseAdditive());
              } else {
                return result;
              }
            }
          },
          parseAdditive: function() {
            var result = this.parseMultiplicative();
            while (true) {
              if (this.optionalOperator('+')) {
                result = new Binary('+', result, this.parseMultiplicative());
              } else if (this.optionalOperator('-')) {
                result = new Binary('-', result, this.parseMultiplicative());
              } else {
                return result;
              }
            }
          },
          parseMultiplicative: function() {
            var result = this.parsePrefix();
            while (true) {
              if (this.optionalOperator('*')) {
                result = new Binary('*', result, this.parsePrefix());
              } else if (this.optionalOperator('%')) {
                result = new Binary('%', result, this.parsePrefix());
              } else if (this.optionalOperator('/')) {
                result = new Binary('/', result, this.parsePrefix());
              } else {
                return result;
              }
            }
          },
          parsePrefix: function() {
            if (this.optionalOperator('+')) {
              return this.parsePrefix();
            } else if (this.optionalOperator('-')) {
              return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
            } else if (this.optionalOperator('!')) {
              return new PrefixNot(this.parsePrefix());
            } else {
              return this.parseCallChain();
            }
          },
          parseCallChain: function() {
            var result = this.parsePrimary();
            while (true) {
              if (this.optionalCharacter($PERIOD)) {
                result = this.parseAccessMemberOrMethodCall(result, false);
              } else if (this.optionalOperator('?.')) {
                result = this.parseAccessMemberOrMethodCall(result, true);
              } else if (this.optionalCharacter($LBRACKET)) {
                var key = this.parsePipe();
                this.expectCharacter($RBRACKET);
                result = new KeyedAccess(result, key);
              } else if (this.optionalCharacter($LPAREN)) {
                var args = this.parseCallArguments();
                this.expectCharacter($RPAREN);
                result = new FunctionCall(result, args);
              } else {
                return result;
              }
            }
          },
          parsePrimary: function() {
            if (this.optionalCharacter($LPAREN)) {
              var result = this.parsePipe();
              this.expectCharacter($RPAREN);
              return result;
            } else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(null);
            } else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(true);
            } else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(false);
            } else if (this.parseAction && this.next.isKeywordIf()) {
              this.advance();
              this.expectCharacter($LPAREN);
              var condition = this.parseExpression();
              this.expectCharacter($RPAREN);
              var ifExp = this.parseExpressionOrBlock();
              var elseExp;
              if (this.next.isKeywordElse()) {
                this.advance();
                elseExp = this.parseExpressionOrBlock();
              }
              return new If(condition, ifExp, elseExp);
            } else if (this.optionalCharacter($LBRACKET)) {
              var elements = this.parseExpressionList($RBRACKET);
              this.expectCharacter($RBRACKET);
              return new LiteralArray(elements);
            } else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
            } else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
            } else if (this.next.isNumber()) {
              var value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(value);
            } else if (this.next.isString()) {
              var literalValue = this.next.toString();
              this.advance();
              return new LiteralPrimitive(literalValue);
            } else if (this.index >= this.tokens.length) {
              this.error(("Unexpected end of expression: " + this.input));
            } else {
              this.error(("Unexpected token " + this.next));
            }
            throw new BaseException("Fell through all cases in parsePrimary");
          },
          parseExpressionList: function(terminator) {
            var result = [];
            if (!this.next.isCharacter(terminator)) {
              do {
                result.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
            }
            return result;
          },
          parseLiteralMap: function() {
            var keys = [];
            var values = [];
            this.expectCharacter($LBRACE);
            if (!this.optionalCharacter($RBRACE)) {
              do {
                var key = this.expectIdentifierOrKeywordOrString();
                keys.push(key);
                this.expectCharacter($COLON);
                values.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
              this.expectCharacter($RBRACE);
            }
            return new LiteralMap(keys, values);
          },
          parseAccessMemberOrMethodCall: function(receiver) {
            var isSafe = arguments[1] !== (void 0) ? arguments[1] : false;
            var id = this.expectIdentifierOrKeyword();
            if (this.optionalCharacter($LPAREN)) {
              var args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              var fn = this.reflector.method(id);
              return isSafe ? new SafeMethodCall(receiver, id, fn, args) : new MethodCall(receiver, id, fn, args);
            } else {
              var getter = this.reflector.getter(id);
              var setter = this.reflector.setter(id);
              return isSafe ? new SafeAccessMember(receiver, id, getter, setter) : new AccessMember(receiver, id, getter, setter);
            }
          },
          parseCallArguments: function() {
            if (this.next.isCharacter($RPAREN))
              return [];
            var positionals = [];
            do {
              positionals.push(this.parsePipe());
            } while (this.optionalCharacter($COMMA));
            return positionals;
          },
          parseExpressionOrBlock: function() {
            if (this.optionalCharacter($LBRACE)) {
              var block = this.parseBlockContent();
              this.expectCharacter($RBRACE);
              return block;
            }
            return this.parseExpression();
          },
          parseBlockContent: function() {
            if (!this.parseAction) {
              this.error("Binding expression cannot contain chained expression");
            }
            var exprs = [];
            while (this.index < this.tokens.length && !this.next.isCharacter($RBRACE)) {
              var expr = this.parseExpression();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                while (this.optionalCharacter($SEMICOLON)) {}
              }
            }
            if (exprs.length == 0)
              return new EmptyExpr();
            if (exprs.length == 1)
              return exprs[0];
            return new Chain(exprs);
          },
          expectTemplateBindingKey: function() {
            var result = '';
            var operatorFound = false;
            do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                result += '-';
              }
            } while (operatorFound);
            return result.toString();
          },
          parseTemplateBindings: function() {
            var bindings = [];
            var prefix = null;
            while (this.index < this.tokens.length) {
              var keyIsVar = this.optionalKeywordVar();
              var key = this.expectTemplateBindingKey();
              if (!keyIsVar) {
                if (prefix == null) {
                  prefix = key;
                } else {
                  key = prefix + '-' + key;
                }
              }
              this.optionalCharacter($COLON);
              var name = null;
              var expression = null;
              if (keyIsVar) {
                if (this.optionalOperator("=")) {
                  name = this.expectTemplateBindingKey();
                } else {
                  name = '\$implicit';
                }
              } else if (this.next !== EOF && !this.peekKeywordVar()) {
                var start = this.inputIndex;
                var ast = this.parsePipe();
                var source = this.input.substring(start, this.inputIndex);
                expression = new ASTWithSource(ast, source, this.location);
              }
              bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
              if (!this.optionalCharacter($SEMICOLON)) {
                this.optionalCharacter($COMMA);
              }
            }
            return bindings;
          },
          error: function(message) {
            var index = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isBlank(index))
              index = this.index;
            var location = (index < this.tokens.length) ? ("at column " + (this.tokens[index].index + 1) + " in") : "at the end of the expression";
            throw new BaseException(("Parser Error: " + message + " " + location + " [" + this.input + "] in " + this.location));
          }
        }, {});
      }());
      $__export("_ParseAST", _ParseAST);
      SimpleExpressionChecker = (function() {
        function SimpleExpressionChecker() {
          this.simple = true;
        }
        return ($traceurRuntime.createClass)(SimpleExpressionChecker, {
          visitImplicitReceiver: function(ast) {},
          visitInterpolation: function(ast) {
            this.simple = false;
          },
          visitLiteralPrimitive: function(ast) {},
          visitAccessMember: function(ast) {},
          visitSafeAccessMember: function(ast) {
            this.simple = false;
          },
          visitMethodCall: function(ast) {
            this.simple = false;
          },
          visitSafeMethodCall: function(ast) {
            this.simple = false;
          },
          visitFunctionCall: function(ast) {
            this.simple = false;
          },
          visitLiteralArray: function(ast) {
            this.visitAll(ast.expressions);
          },
          visitLiteralMap: function(ast) {
            this.visitAll(ast.values);
          },
          visitBinary: function(ast) {
            this.simple = false;
          },
          visitPrefixNot: function(ast) {
            this.simple = false;
          },
          visitConditional: function(ast) {
            this.simple = false;
          },
          visitPipe: function(ast) {
            this.simple = false;
          },
          visitKeyedAccess: function(ast) {
            this.simple = false;
          },
          visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          visitChain: function(ast) {
            this.simple = false;
          },
          visitAssignment: function(ast) {
            this.simple = false;
          },
          visitIf: function(ast) {
            this.simple = false;
          }
        }, {check: function(ast) {
            var s = new SimpleExpressionChecker();
            ast.visit(s);
            return s.simple;
          }});
      }());
    }
  };
});

System.register("angular2/src/change_detection/parser/locals", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/parser/locals";
  var isPresent,
      BaseException,
      MapWrapper,
      Locals;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      Locals = (function() {
        function Locals(parent, current) {
          this.parent = parent;
          this.current = current;
        }
        return ($traceurRuntime.createClass)(Locals, {
          contains: function(name) {
            if (this.current.has(name)) {
              return true;
            }
            if (isPresent(this.parent)) {
              return this.parent.contains(name);
            }
            return false;
          },
          get: function(name) {
            if (this.current.has(name)) {
              return this.current.get(name);
            }
            if (isPresent(this.parent)) {
              return this.parent.get(name);
            }
            throw new BaseException(("Cannot find '" + name + "'"));
          },
          set: function(name, value) {
            if (this.current.has(name)) {
              this.current.set(name, value);
            } else {
              throw new BaseException(("Setting of new keys post-construction is not supported. Key: " + name + "."));
            }
          },
          clearValues: function() {
            MapWrapper.clearValues(this.current);
          }
        }, {});
      }());
      $__export("Locals", Locals);
    }
  };
});

System.register("angular2/src/change_detection/binding_record", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/binding_record";
  var isPresent,
      DIRECTIVE,
      DIRECTIVE_LIFECYCLE,
      ELEMENT_PROPERTY,
      ELEMENT_ATTRIBUTE,
      ELEMENT_CLASS,
      ELEMENT_STYLE,
      TEXT_NODE,
      BindingRecord;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      DIRECTIVE = "directive";
      DIRECTIVE_LIFECYCLE = "directiveLifecycle";
      ELEMENT_PROPERTY = "elementProperty";
      ELEMENT_ATTRIBUTE = "elementAttribute";
      ELEMENT_CLASS = "elementClass";
      ELEMENT_STYLE = "elementStyle";
      TEXT_NODE = "textNode";
      BindingRecord = (function() {
        function BindingRecord(mode, implicitReceiver, ast, elementIndex, propertyName, propertyUnit, setter, lifecycleEvent, directiveRecord) {
          this.mode = mode;
          this.implicitReceiver = implicitReceiver;
          this.ast = ast;
          this.elementIndex = elementIndex;
          this.propertyName = propertyName;
          this.propertyUnit = propertyUnit;
          this.setter = setter;
          this.lifecycleEvent = lifecycleEvent;
          this.directiveRecord = directiveRecord;
        }
        return ($traceurRuntime.createClass)(BindingRecord, {
          callOnChange: function() {
            return isPresent(this.directiveRecord) && this.directiveRecord.callOnChange;
          },
          isOnPushChangeDetection: function() {
            return isPresent(this.directiveRecord) && this.directiveRecord.isOnPushChangeDetection();
          },
          isDirective: function() {
            return this.mode === DIRECTIVE;
          },
          isDirectiveLifecycle: function() {
            return this.mode === DIRECTIVE_LIFECYCLE;
          },
          isElementProperty: function() {
            return this.mode === ELEMENT_PROPERTY;
          },
          isElementAttribute: function() {
            return this.mode === ELEMENT_ATTRIBUTE;
          },
          isElementClass: function() {
            return this.mode === ELEMENT_CLASS;
          },
          isElementStyle: function() {
            return this.mode === ELEMENT_STYLE;
          },
          isTextNode: function() {
            return this.mode === TEXT_NODE;
          }
        }, {
          createForDirective: function(ast, propertyName, setter, directiveRecord) {
            return new BindingRecord(DIRECTIVE, 0, ast, 0, propertyName, null, setter, null, directiveRecord);
          },
          createDirectiveOnCheck: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, null, "onCheck", directiveRecord);
          },
          createDirectiveOnInit: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, null, "onInit", directiveRecord);
          },
          createDirectiveOnChange: function(directiveRecord) {
            return new BindingRecord(DIRECTIVE_LIFECYCLE, 0, null, 0, null, null, null, "onChange", directiveRecord);
          },
          createForElementProperty: function(ast, elementIndex, propertyName) {
            return new BindingRecord(ELEMENT_PROPERTY, 0, ast, elementIndex, propertyName, null, null, null, null);
          },
          createForElementAttribute: function(ast, elementIndex, attributeName) {
            return new BindingRecord(ELEMENT_ATTRIBUTE, 0, ast, elementIndex, attributeName, null, null, null, null);
          },
          createForElementClass: function(ast, elementIndex, className) {
            return new BindingRecord(ELEMENT_CLASS, 0, ast, elementIndex, className, null, null, null, null);
          },
          createForElementStyle: function(ast, elementIndex, styleName, unit) {
            return new BindingRecord(ELEMENT_STYLE, 0, ast, elementIndex, styleName, unit, null, null, null);
          },
          createForHostProperty: function(directiveIndex, ast, propertyName) {
            return new BindingRecord(ELEMENT_PROPERTY, directiveIndex, ast, directiveIndex.elementIndex, propertyName, null, null, null, null);
          },
          createForHostAttribute: function(directiveIndex, ast, attributeName) {
            return new BindingRecord(ELEMENT_ATTRIBUTE, directiveIndex, ast, directiveIndex.elementIndex, attributeName, null, null, null, null);
          },
          createForHostClass: function(directiveIndex, ast, className) {
            return new BindingRecord(ELEMENT_CLASS, directiveIndex, ast, directiveIndex.elementIndex, className, null, null, null, null);
          },
          createForHostStyle: function(directiveIndex, ast, styleName, unit) {
            return new BindingRecord(ELEMENT_STYLE, directiveIndex, ast, directiveIndex.elementIndex, styleName, unit, null, null, null);
          },
          createForTextNode: function(ast, elementIndex) {
            return new BindingRecord(TEXT_NODE, 0, ast, elementIndex, null, null, null, null, null);
          }
        });
      }());
      $__export("BindingRecord", BindingRecord);
    }
  };
});

System.register("angular2/src/core/compiler/element_binder", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_binder";
  var isBlank,
      isPresent,
      BaseException,
      ElementBinder;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ElementBinder = (function() {
        function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective) {
          this.index = index;
          this.parent = parent;
          this.distanceToParent = distanceToParent;
          this.protoElementInjector = protoElementInjector;
          this.componentDirective = componentDirective;
          this.nestedProtoView = null;
          this.hostListeners = null;
          if (isBlank(index)) {
            throw new BaseException('null index not allowed.');
          }
        }
        return ($traceurRuntime.createClass)(ElementBinder, {
          hasStaticComponent: function() {
            return isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          },
          hasEmbeddedProtoView: function() {
            return !isPresent(this.componentDirective) && isPresent(this.nestedProtoView);
          }
        }, {});
      }());
      $__export("ElementBinder", ElementBinder);
    }
  };
});

System.register("angular2/src/core/compiler/view_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_ref";
  var isPresent,
      ViewRef,
      ProtoViewRef;
  function internalView(viewRef) {
    return viewRef._view;
  }
  function internalProtoView(protoViewRef) {
    return isPresent(protoViewRef) ? protoViewRef._protoView : null;
  }
  $__export("internalView", internalView);
  $__export("internalProtoView", internalProtoView);
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      ViewRef = (function() {
        function ViewRef(_view) {
          this._view = _view;
        }
        return ($traceurRuntime.createClass)(ViewRef, {
          get render() {
            return this._view.render;
          },
          get renderFragment() {
            return this._view.renderFragment;
          },
          setLocal: function(contextName, value) {
            this._view.setLocal(contextName, value);
          }
        }, {});
      }());
      $__export("ViewRef", ViewRef);
      ProtoViewRef = (function() {
        function ProtoViewRef(_protoView) {
          this._protoView = _protoView;
        }
        return ($traceurRuntime.createClass)(ProtoViewRef, {}, {});
      }());
      $__export("ProtoViewRef", ProtoViewRef);
    }
  };
});

System.register("angular2/src/core/annotations_impl/di", ["angular2/src/facade/lang", "angular2/src/di/metadata", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/di";
  var __decorate,
      __metadata,
      CONST,
      stringify,
      StringWrapper,
      isString,
      DependencyMetadata,
      resolveForwardRef,
      Attribute,
      Query,
      ViewQuery;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      stringify = $__m.stringify;
      StringWrapper = $__m.StringWrapper;
      isString = $__m.isString;
    }, function($__m) {
      DependencyMetadata = $__m.DependencyMetadata;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Attribute = (function($__super) {
        function $__0(attributeName) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.attributeName = attributeName;
        }
        return ($traceurRuntime.createClass)($__0, {
          get token() {
            return this;
          },
          toString: function() {
            return ("@Attribute(" + stringify(this.attributeName) + ")");
          }
        }, {}, $__super);
      }(DependencyMetadata));
      $__export("Attribute", Attribute);
      $__export("Attribute", Attribute = __decorate([CONST(), __metadata('design:paramtypes', [String])], Attribute));
      Query = (function($__super) {
        function $__0(_selector) {
          var $__3;
          var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
              descendants = ($__3 = $__2.descendants) === void 0 ? false : $__3;
          $traceurRuntime.superConstructor($__0).call(this);
          this._selector = _selector;
          this.descendants = descendants;
        }
        return ($traceurRuntime.createClass)($__0, {
          get isViewQuery() {
            return false;
          },
          get selector() {
            return resolveForwardRef(this._selector);
          },
          get isVarBindingQuery() {
            return isString(this.selector);
          },
          get varBindings() {
            return StringWrapper.split(this.selector, new RegExp(","));
          },
          toString: function() {
            return ("@Query(" + stringify(this.selector) + ")");
          }
        }, {}, $__super);
      }(DependencyMetadata));
      $__export("Query", Query);
      $__export("Query", Query = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], Query));
      ViewQuery = (function($__super) {
        function $__0(_selector) {
          var $__3;
          var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
              descendants = ($__3 = $__2.descendants) === void 0 ? false : $__3;
          $traceurRuntime.superConstructor($__0).call(this, _selector, {descendants: descendants});
        }
        return ($traceurRuntime.createClass)($__0, {
          get isViewQuery() {
            return true;
          },
          toString: function() {
            return ("@ViewQuery(" + stringify(this.selector) + ")");
          }
        }, {}, $__super);
      }(Query));
      $__export("ViewQuery", ViewQuery);
      $__export("ViewQuery", ViewQuery = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], ViewQuery));
    }
  };
});

System.register("angular2/src/render/api", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/api";
  var isPresent,
      isBlank,
      RegExpWrapper,
      Map,
      MapWrapper,
      EventBinding,
      PropertyBindingType,
      ElementPropertyBinding,
      ElementBinder,
      DirectiveBinder,
      ViewType,
      ProtoViewDto,
      DirectiveMetadata,
      RenderProtoViewRef,
      RenderFragmentRef,
      RenderViewRef,
      ViewEncapsulation,
      ViewDefinition,
      RenderProtoViewMergeMapping,
      RenderCompiler,
      RenderViewWithFragments,
      Renderer;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }],
    execute: function() {
      EventBinding = (function() {
        function EventBinding(fullName, source) {
          this.fullName = fullName;
          this.source = source;
        }
        return ($traceurRuntime.createClass)(EventBinding, {}, {});
      }());
      $__export("EventBinding", EventBinding);
      $__export("PropertyBindingType", PropertyBindingType);
      (function(PropertyBindingType) {
        PropertyBindingType[PropertyBindingType["PROPERTY"] = 0] = "PROPERTY";
        PropertyBindingType[PropertyBindingType["ATTRIBUTE"] = 1] = "ATTRIBUTE";
        PropertyBindingType[PropertyBindingType["CLASS"] = 2] = "CLASS";
        PropertyBindingType[PropertyBindingType["STYLE"] = 3] = "STYLE";
      })(PropertyBindingType || ($__export("PropertyBindingType", PropertyBindingType = {})));
      ElementPropertyBinding = (function() {
        function ElementPropertyBinding(type, astWithSource, property) {
          var unit = arguments[3] !== (void 0) ? arguments[3] : null;
          this.type = type;
          this.astWithSource = astWithSource;
          this.property = property;
          this.unit = unit;
        }
        return ($traceurRuntime.createClass)(ElementPropertyBinding, {}, {});
      }());
      $__export("ElementPropertyBinding", ElementPropertyBinding);
      ElementBinder = (function() {
        function ElementBinder() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              index = $__1.index,
              parentIndex = $__1.parentIndex,
              distanceToParent = $__1.distanceToParent,
              directives = $__1.directives,
              nestedProtoView = $__1.nestedProtoView,
              propertyBindings = $__1.propertyBindings,
              variableBindings = $__1.variableBindings,
              eventBindings = $__1.eventBindings,
              readAttributes = $__1.readAttributes;
          this.index = index;
          this.parentIndex = parentIndex;
          this.distanceToParent = distanceToParent;
          this.directives = directives;
          this.nestedProtoView = nestedProtoView;
          this.propertyBindings = propertyBindings;
          this.variableBindings = variableBindings;
          this.eventBindings = eventBindings;
          this.readAttributes = readAttributes;
        }
        return ($traceurRuntime.createClass)(ElementBinder, {}, {});
      }());
      $__export("ElementBinder", ElementBinder);
      DirectiveBinder = (function() {
        function DirectiveBinder($__1) {
          var $__2 = $__1,
              directiveIndex = $__2.directiveIndex,
              propertyBindings = $__2.propertyBindings,
              eventBindings = $__2.eventBindings,
              hostPropertyBindings = $__2.hostPropertyBindings;
          this.directiveIndex = directiveIndex;
          this.propertyBindings = propertyBindings;
          this.eventBindings = eventBindings;
          this.hostPropertyBindings = hostPropertyBindings;
        }
        return ($traceurRuntime.createClass)(DirectiveBinder, {}, {});
      }());
      $__export("DirectiveBinder", DirectiveBinder);
      $__export("ViewType", ViewType);
      (function(ViewType) {
        ViewType[ViewType["HOST"] = 0] = "HOST";
        ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
        ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
      })(ViewType || ($__export("ViewType", ViewType = {})));
      ProtoViewDto = (function() {
        function ProtoViewDto($__1) {
          var $__2 = $__1,
              render = $__2.render,
              elementBinders = $__2.elementBinders,
              variableBindings = $__2.variableBindings,
              type = $__2.type,
              textBindings = $__2.textBindings,
              transitiveNgContentCount = $__2.transitiveNgContentCount;
          this.render = render;
          this.elementBinders = elementBinders;
          this.variableBindings = variableBindings;
          this.type = type;
          this.textBindings = textBindings;
          this.transitiveNgContentCount = transitiveNgContentCount;
        }
        return ($traceurRuntime.createClass)(ProtoViewDto, {}, {});
      }());
      $__export("ProtoViewDto", ProtoViewDto);
      DirectiveMetadata = (function() {
        function DirectiveMetadata($__1) {
          var $__2 = $__1,
              id = $__2.id,
              selector = $__2.selector,
              compileChildren = $__2.compileChildren,
              events = $__2.events,
              hostListeners = $__2.hostListeners,
              hostProperties = $__2.hostProperties,
              hostAttributes = $__2.hostAttributes,
              hostActions = $__2.hostActions,
              properties = $__2.properties,
              readAttributes = $__2.readAttributes,
              type = $__2.type,
              callOnDestroy = $__2.callOnDestroy,
              callOnChange = $__2.callOnChange,
              callOnCheck = $__2.callOnCheck,
              callOnInit = $__2.callOnInit,
              callOnAllChangesDone = $__2.callOnAllChangesDone,
              changeDetection = $__2.changeDetection,
              exportAs = $__2.exportAs;
          this.id = id;
          this.selector = selector;
          this.compileChildren = isPresent(compileChildren) ? compileChildren : true;
          this.events = events;
          this.hostListeners = hostListeners;
          this.hostAttributes = hostAttributes;
          this.hostProperties = hostProperties;
          this.hostActions = hostActions;
          this.properties = properties;
          this.readAttributes = readAttributes;
          this.type = type;
          this.callOnDestroy = callOnDestroy;
          this.callOnChange = callOnChange;
          this.callOnCheck = callOnCheck;
          this.callOnInit = callOnInit;
          this.callOnAllChangesDone = callOnAllChangesDone;
          this.changeDetection = changeDetection;
          this.exportAs = exportAs;
        }
        return ($traceurRuntime.createClass)(DirectiveMetadata, {}, {
          get DIRECTIVE_TYPE() {
            return 0;
          },
          get COMPONENT_TYPE() {
            return 1;
          },
          create: function($__1) {
            var $__2 = $__1,
                id = $__2.id,
                selector = $__2.selector,
                compileChildren = $__2.compileChildren,
                events = $__2.events,
                host = $__2.host,
                properties = $__2.properties,
                readAttributes = $__2.readAttributes,
                type = $__2.type,
                callOnDestroy = $__2.callOnDestroy,
                callOnChange = $__2.callOnChange,
                callOnCheck = $__2.callOnCheck,
                callOnInit = $__2.callOnInit,
                callOnAllChangesDone = $__2.callOnAllChangesDone,
                changeDetection = $__2.changeDetection,
                exportAs = $__2.exportAs;
            var hostListeners = new Map();
            var hostProperties = new Map();
            var hostAttributes = new Map();
            var hostActions = new Map();
            if (isPresent(host)) {
              MapWrapper.forEach(host, (function(value, key) {
                var matches = RegExpWrapper.firstMatch(DirectiveMetadata._hostRegExp, key);
                if (isBlank(matches)) {
                  hostAttributes.set(key, value);
                } else if (isPresent(matches[1])) {
                  hostProperties.set(matches[1], value);
                } else if (isPresent(matches[2])) {
                  hostListeners.set(matches[2], value);
                } else if (isPresent(matches[3])) {
                  hostActions.set(matches[3], value);
                }
              }));
            }
            return new DirectiveMetadata({
              id: id,
              selector: selector,
              compileChildren: compileChildren,
              events: events,
              hostListeners: hostListeners,
              hostProperties: hostProperties,
              hostAttributes: hostAttributes,
              hostActions: hostActions,
              properties: properties,
              readAttributes: readAttributes,
              type: type,
              callOnDestroy: callOnDestroy,
              callOnChange: callOnChange,
              callOnCheck: callOnCheck,
              callOnInit: callOnInit,
              callOnAllChangesDone: callOnAllChangesDone,
              changeDetection: changeDetection,
              exportAs: exportAs
            });
          }
        });
      }());
      $__export("DirectiveMetadata", DirectiveMetadata);
      DirectiveMetadata._hostRegExp = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\))|(?:@(.+)))$/g;
      RenderProtoViewRef = (function() {
        function RenderProtoViewRef() {}
        return ($traceurRuntime.createClass)(RenderProtoViewRef, {}, {});
      }());
      $__export("RenderProtoViewRef", RenderProtoViewRef);
      RenderFragmentRef = (function() {
        function RenderFragmentRef() {}
        return ($traceurRuntime.createClass)(RenderFragmentRef, {}, {});
      }());
      $__export("RenderFragmentRef", RenderFragmentRef);
      RenderViewRef = (function() {
        function RenderViewRef() {}
        return ($traceurRuntime.createClass)(RenderViewRef, {}, {});
      }());
      $__export("RenderViewRef", RenderViewRef);
      $__export("ViewEncapsulation", ViewEncapsulation);
      (function(ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["EMULATED"] = 0] = "EMULATED";
        ViewEncapsulation[ViewEncapsulation["NATIVE"] = 1] = "NATIVE";
        ViewEncapsulation[ViewEncapsulation["NONE"] = 2] = "NONE";
      })(ViewEncapsulation || ($__export("ViewEncapsulation", ViewEncapsulation = {})));
      ViewDefinition = (function() {
        function ViewDefinition() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              componentId = $__1.componentId,
              templateAbsUrl = $__1.templateAbsUrl,
              template = $__1.template,
              styleAbsUrls = $__1.styleAbsUrls,
              styles = $__1.styles,
              directives = $__1.directives,
              encapsulation = $__1.encapsulation;
          this.componentId = componentId;
          this.templateAbsUrl = templateAbsUrl;
          this.template = template;
          this.styleAbsUrls = styleAbsUrls;
          this.styles = styles;
          this.directives = directives;
          this.encapsulation = isPresent(encapsulation) ? encapsulation : ViewEncapsulation.EMULATED;
        }
        return ($traceurRuntime.createClass)(ViewDefinition, {}, {});
      }());
      $__export("ViewDefinition", ViewDefinition);
      RenderProtoViewMergeMapping = (function() {
        function RenderProtoViewMergeMapping(mergedProtoViewRef, fragmentCount, mappedElementIndices, mappedElementCount, mappedTextIndices, hostElementIndicesByViewIndex, nestedViewCountByViewIndex) {
          this.mergedProtoViewRef = mergedProtoViewRef;
          this.fragmentCount = fragmentCount;
          this.mappedElementIndices = mappedElementIndices;
          this.mappedElementCount = mappedElementCount;
          this.mappedTextIndices = mappedTextIndices;
          this.hostElementIndicesByViewIndex = hostElementIndicesByViewIndex;
          this.nestedViewCountByViewIndex = nestedViewCountByViewIndex;
        }
        return ($traceurRuntime.createClass)(RenderProtoViewMergeMapping, {}, {});
      }());
      $__export("RenderProtoViewMergeMapping", RenderProtoViewMergeMapping);
      RenderCompiler = (function() {
        function RenderCompiler() {}
        return ($traceurRuntime.createClass)(RenderCompiler, {
          compileHost: function(directiveMetadata) {
            return null;
          },
          compile: function(view) {
            return null;
          },
          mergeProtoViewsRecursively: function(protoViewRefs) {
            return null;
          }
        }, {});
      }());
      $__export("RenderCompiler", RenderCompiler);
      RenderViewWithFragments = (function() {
        function RenderViewWithFragments(viewRef, fragmentRefs) {
          this.viewRef = viewRef;
          this.fragmentRefs = fragmentRefs;
        }
        return ($traceurRuntime.createClass)(RenderViewWithFragments, {}, {});
      }());
      $__export("RenderViewWithFragments", RenderViewWithFragments);
      Renderer = (function() {
        function Renderer() {}
        return ($traceurRuntime.createClass)(Renderer, {
          createRootHostView: function(hostProtoViewRef, fragmentCount, hostElementSelector) {
            return null;
          },
          createView: function(protoViewRef, fragmentCount) {
            return null;
          },
          destroyView: function(viewRef) {},
          attachFragmentAfterFragment: function(previousFragmentRef, fragmentRef) {},
          attachFragmentAfterElement: function(elementRef, fragmentRef) {},
          detachFragment: function(fragmentRef) {},
          hydrateView: function(viewRef) {},
          dehydrateView: function(viewRef) {},
          getNativeElementSync: function(location) {
            return null;
          },
          setElementProperty: function(location, propertyName, propertyValue) {},
          setElementAttribute: function(location, attributeName, attributeValue) {},
          setElementClass: function(location, className, isAdd) {},
          setElementStyle: function(location, styleName, styleValue) {},
          invokeElementMethod: function(location, methodName, args) {},
          setText: function(viewRef, textNodeIndex, text) {},
          setEventDispatcher: function(viewRef, dispatcher) {}
        }, {});
      }());
      $__export("Renderer", Renderer);
    }
  };
});

System.register("angular2/src/core/compiler/element_ref", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_ref";
  var BaseException,
      ElementRef;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ElementRef = (function() {
        function ElementRef(parentView, boundElementIndex, renderBoundElementIndex, _renderer) {
          this._renderer = _renderer;
          this.parentView = parentView;
          this.boundElementIndex = boundElementIndex;
          this.renderBoundElementIndex = renderBoundElementIndex;
        }
        return ($traceurRuntime.createClass)(ElementRef, {
          get renderView() {
            return this.parentView.render;
          },
          set renderView(viewRef) {
            throw new BaseException('Abstract setter');
          },
          get nativeElement() {
            return this._renderer.getNativeElementSync(this);
          }
        }, {});
      }());
      $__export("ElementRef", ElementRef);
    }
  };
});

System.register("angular2/src/core/compiler/template_ref", ["angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/template_ref";
  var internalView,
      TemplateRef;
  return {
    setters: [function($__m) {
      internalView = $__m.internalView;
    }],
    execute: function() {
      TemplateRef = (function() {
        function TemplateRef(elementRef) {
          this.elementRef = elementRef;
        }
        return ($traceurRuntime.createClass)(TemplateRef, {
          _getProtoView: function() {
            var parentView = internalView(this.elementRef.parentView);
            return parentView.proto.elementBinders[this.elementRef.boundElementIndex - parentView.elementOffset].nestedProtoView;
          },
          get protoViewRef() {
            return this._getProtoView().ref;
          },
          hasLocal: function(name) {
            return this._getProtoView().protoLocals.has(name);
          }
        }, {});
      }());
      $__export("TemplateRef", TemplateRef);
    }
  };
});

System.register("angular2/src/core/compiler/view_pool", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_pool";
  var __decorate,
      __metadata,
      __param,
      Inject,
      Injectable,
      OpaqueToken,
      ListWrapper,
      Map,
      isPresent,
      isBlank,
      CONST_EXPR,
      APP_VIEW_POOL_CAPACITY,
      AppViewPool;
  return {
    setters: [function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      APP_VIEW_POOL_CAPACITY = CONST_EXPR(new OpaqueToken('AppViewPool.viewPoolCapacity'));
      $__export("APP_VIEW_POOL_CAPACITY", APP_VIEW_POOL_CAPACITY);
      AppViewPool = (($traceurRuntime.createClass)(function(poolCapacityPerProtoView) {
        this._pooledViewsPerProtoView = new Map();
        this._poolCapacityPerProtoView = poolCapacityPerProtoView;
      }, {
        getView: function(protoView) {
          var pooledViews = this._pooledViewsPerProtoView.get(protoView);
          if (isPresent(pooledViews) && pooledViews.length > 0) {
            return ListWrapper.removeLast(pooledViews);
          }
          return null;
        },
        returnView: function(view) {
          var protoView = view.proto;
          var pooledViews = this._pooledViewsPerProtoView.get(protoView);
          if (isBlank(pooledViews)) {
            pooledViews = [];
            this._pooledViewsPerProtoView.set(protoView, pooledViews);
          }
          var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
          if (haveRemainingCapacity) {
            pooledViews.push(view);
          }
          return haveRemainingCapacity;
        }
      }, {}));
      $__export("AppViewPool", AppViewPool);
      $__export("AppViewPool", AppViewPool = __decorate([Injectable(), __param(0, Inject(APP_VIEW_POOL_CAPACITY)), __metadata('design:paramtypes', [Object])], AppViewPool));
    }
  };
});

System.register("angular2/src/core/compiler/view_listener", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_listener";
  var __decorate,
      __metadata,
      Injectable,
      AppViewListener;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewListener = (($traceurRuntime.createClass)(function() {}, {
        viewCreated: function(view) {},
        viewDestroyed: function(view) {}
      }, {}));
      $__export("AppViewListener", AppViewListener);
      $__export("AppViewListener", AppViewListener = __decorate([Injectable(), __metadata('design:paramtypes', [])], AppViewListener));
    }
  };
});

System.register("angular2/src/core/compiler/view_container_ref", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_container_ref";
  var ListWrapper,
      isPresent,
      internalView,
      ViewContainerRef;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      internalView = $__m.internalView;
    }],
    execute: function() {
      ViewContainerRef = (function() {
        function ViewContainerRef(viewManager, element) {
          this.viewManager = viewManager;
          this.element = element;
        }
        return ($traceurRuntime.createClass)(ViewContainerRef, {
          _getViews: function() {
            var vc = internalView(this.element.parentView).viewContainers[this.element.boundElementIndex];
            return isPresent(vc) ? vc.views : [];
          },
          clear: function() {
            for (var i = this.length - 1; i >= 0; i--) {
              this.remove(i);
            }
          },
          get: function(index) {
            return this._getViews()[index].ref;
          },
          get length() {
            return this._getViews().length;
          },
          createEmbeddedView: function(templateRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.createEmbeddedViewInContainer(this.element, atIndex, templateRef);
          },
          createHostView: function() {
            var protoViewRef = arguments[0] !== (void 0) ? arguments[0] : null;
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            var dynamicallyCreatedBindings = arguments[2] !== (void 0) ? arguments[2] : null;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.createHostViewInContainer(this.element, atIndex, protoViewRef, dynamicallyCreatedBindings);
          },
          insert: function(viewRef) {
            var atIndex = arguments[1] !== (void 0) ? arguments[1] : -1;
            if (atIndex == -1)
              atIndex = this.length;
            return this.viewManager.attachViewInContainer(this.element, atIndex, viewRef);
          },
          indexOf: function(viewRef) {
            return ListWrapper.indexOf(this._getViews(), internalView(viewRef));
          },
          remove: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            this.viewManager.destroyViewInContainer(this.element, atIndex);
          },
          detach: function() {
            var atIndex = arguments[0] !== (void 0) ? arguments[0] : -1;
            if (atIndex == -1)
              atIndex = this.length - 1;
            return this.viewManager.detachViewInContainer(this.element, atIndex);
          }
        }, {});
      }());
      $__export("ViewContainerRef", ViewContainerRef);
    }
  };
});

System.register("angular2/src/core/compiler/directive_lifecycle_reflector", ["angular2/src/facade/lang", "angular2/src/core/annotations_impl/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_lifecycle_reflector";
  var Type,
      isPresent,
      LifecycleEvent;
  function hasLifecycleHook(e, type, annotation) {
    if (isPresent(annotation.lifecycle)) {
      return annotation.lifecycle.indexOf(e) !== -1;
    } else {
      if (!(type instanceof Type))
        return false;
      var proto = type.prototype;
      switch (e) {
        case LifecycleEvent.onAllChangesDone:
          return !!proto.onAllChangesDone;
        case LifecycleEvent.onChange:
          return !!proto.onChange;
        case LifecycleEvent.onCheck:
          return !!proto.onCheck;
        case LifecycleEvent.onDestroy:
          return !!proto.onDestroy;
        case LifecycleEvent.onInit:
          return !!proto.onInit;
        default:
          return false;
      }
    }
  }
  $__export("hasLifecycleHook", hasLifecycleHook);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
    }, function($__m) {
      LifecycleEvent = $__m.LifecycleEvent;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/core/compiler/query_list", ["angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/query_list";
  var ListWrapper,
      QueryList;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      QueryList = (function() {
        var $__1;
        function QueryList() {
          this._results = [];
          this._callbacks = [];
          this._dirty = false;
        }
        return ($traceurRuntime.createClass)(QueryList, ($__1 = {}, Object.defineProperty($__1, "reset", {
          value: function(newList) {
            this._results = newList;
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "add", {
          value: function(obj) {
            this._results.push(obj);
            this._dirty = true;
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "fireCallbacks", {
          value: function() {
            if (this._dirty) {
              ListWrapper.forEach(this._callbacks, (function(c) {
                return c();
              }));
              this._dirty = false;
            }
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "onChange", {
          value: function(callback) {
            this._callbacks.push(callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "removeCallback", {
          value: function(callback) {
            ListWrapper.remove(this._callbacks, callback);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, "length", {
          get: function() {
            return this._results.length;
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "first", {
          get: function() {
            return ListWrapper.first(this._results);
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "last", {
          get: function() {
            return ListWrapper.last(this._results);
          },
          configurable: true,
          enumerable: true
        }), Object.defineProperty($__1, "map", {
          value: function(fn) {
            return this._results.map(fn);
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), Object.defineProperty($__1, Symbol.iterator, {
          value: function() {
            return this._results[Symbol.iterator]();
          },
          configurable: true,
          enumerable: true,
          writable: true
        }), $__1), {});
      }());
      $__export("QueryList", QueryList);
    }
  };
});

System.register("angular2/src/core/annotations_impl/view", ["angular2/src/facade/lang", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/view";
  var __decorate,
      __metadata,
      CONST,
      View;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      View = (($traceurRuntime.createClass)(function() {
        var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
            templateUrl = $__2.templateUrl,
            template = $__2.template,
            directives = $__2.directives,
            encapsulation = $__2.encapsulation,
            styles = $__2.styles,
            styleUrls = $__2.styleUrls;
        this.templateUrl = templateUrl;
        this.template = template;
        this.styleUrls = styleUrls;
        this.styles = styles;
        this.directives = directives;
        this.encapsulation = encapsulation;
      }, {}, {}));
      $__export("View", View);
      $__export("View", View = __decorate([CONST(), __metadata('design:paramtypes', [Object])], View));
    }
  };
});

System.register("angular2/src/core/compiler/component_url_mapper", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/component_url_mapper";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      Map,
      ComponentUrlMapper,
      RuntimeComponentUrlMapper;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Map = $__m.Map;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ComponentUrlMapper = (($traceurRuntime.createClass)(function() {}, {getUrl: function(component) {
          return './';
        }}, {}));
      $__export("ComponentUrlMapper", ComponentUrlMapper);
      $__export("ComponentUrlMapper", ComponentUrlMapper = __decorate([Injectable(), __metadata('design:paramtypes', [])], ComponentUrlMapper));
      RuntimeComponentUrlMapper = (function($__super) {
        function RuntimeComponentUrlMapper() {
          $traceurRuntime.superConstructor(RuntimeComponentUrlMapper).call(this);
          this._componentUrls = new Map();
        }
        return ($traceurRuntime.createClass)(RuntimeComponentUrlMapper, {
          setComponentUrl: function(component, url) {
            this._componentUrls.set(component, url);
          },
          getUrl: function(component) {
            var url = this._componentUrls.get(component);
            if (isPresent(url))
              return url;
            return $traceurRuntime.superGet(this, RuntimeComponentUrlMapper.prototype, "getUrl").call(this, component);
          }
        }, {}, $__super);
      }(ComponentUrlMapper));
      $__export("RuntimeComponentUrlMapper", RuntimeComponentUrlMapper);
    }
  };
});

System.register("angular2/src/core/compiler/proto_view_factory", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/reflection/reflection", "angular2/src/change_detection/change_detection", "angular2/src/render/api", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/proto_view_factory";
  var __decorate,
      __metadata,
      Injectable,
      ListWrapper,
      MapWrapper,
      isPresent,
      isBlank,
      BaseException,
      assertionsEnabled,
      reflector,
      ChangeDetection,
      DirectiveIndex,
      BindingRecord,
      DirectiveRecord,
      DEFAULT,
      ChangeDetectorDefinition,
      renderApi,
      AppProtoView,
      ProtoElementInjector,
      BindingRecordsCreator,
      ProtoViewFactory,
      RenderProtoViewWithIndex,
      ParentProtoElementInjectorWithDistance;
  function getChangeDetectorDefinitions(hostComponentMetadata, rootRenderProtoView, allRenderDirectiveMetadata) {
    var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
    var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
    return _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
  }
  function _collectNestedProtoViews(renderProtoView) {
    var parentIndex = arguments[1] !== (void 0) ? arguments[1] : null;
    var boundElementIndex = arguments[2] !== (void 0) ? arguments[2] : null;
    var result = arguments[3] !== (void 0) ? arguments[3] : null;
    if (isBlank(result)) {
      result = [];
    }
    result.push(new RenderProtoViewWithIndex(renderProtoView, result.length, parentIndex, boundElementIndex));
    var currentIndex = result.length - 1;
    var childBoundElementIndex = 0;
    ListWrapper.forEach(renderProtoView.elementBinders, (function(elementBinder) {
      if (isPresent(elementBinder.nestedProtoView)) {
        _collectNestedProtoViews(elementBinder.nestedProtoView, currentIndex, childBoundElementIndex, result);
      }
      childBoundElementIndex++;
    }));
    return result;
  }
  function _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata) {
    return ListWrapper.map(nestedPvsWithIndex, (function(pvWithIndex) {
      var elementBinders = pvWithIndex.renderProtoView.elementBinders;
      var bindingRecordsCreator = new BindingRecordsCreator();
      var bindingRecords = bindingRecordsCreator.getBindingRecords(pvWithIndex.renderProtoView.textBindings, elementBinders, allRenderDirectiveMetadata);
      var directiveRecords = bindingRecordsCreator.getDirectiveRecords(elementBinders, allRenderDirectiveMetadata);
      var strategyName = DEFAULT;
      var typeString;
      if (pvWithIndex.renderProtoView.type === renderApi.ViewType.COMPONENT) {
        strategyName = hostComponentMetadata.changeDetection;
        typeString = 'comp';
      } else if (pvWithIndex.renderProtoView.type === renderApi.ViewType.HOST) {
        typeString = 'host';
      } else {
        typeString = 'embedded';
      }
      var id = (hostComponentMetadata.id + "_" + typeString + "_" + pvWithIndex.index);
      var variableNames = nestedPvVariableNames[pvWithIndex.index];
      return new ChangeDetectorDefinition(id, strategyName, variableNames, bindingRecords, directiveRecords, assertionsEnabled());
    }));
  }
  function _createAppProtoView(renderProtoView, protoChangeDetector, variableBindings, allDirectives) {
    var elementBinders = renderProtoView.elementBinders;
    var protoView = new AppProtoView(renderProtoView.type, renderProtoView.transitiveNgContentCount > 0, renderProtoView.render, protoChangeDetector, variableBindings, createVariableLocations(elementBinders), renderProtoView.textBindings.length);
    _createElementBinders(protoView, elementBinders, allDirectives);
    _bindDirectiveEvents(protoView, elementBinders);
    return protoView;
  }
  function _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex) {
    return ListWrapper.map(nestedPvsWithIndex, (function(pvWithIndex) {
      return _createVariableBindings(pvWithIndex.renderProtoView);
    }));
  }
  function _createVariableBindings(renderProtoView) {
    var variableBindings = new Map();
    MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
      variableBindings.set(varName, mappedName);
    }));
    return variableBindings;
  }
  function _collectNestedProtoViewsVariableNames(nestedPvsWithIndex) {
    var nestedPvVariableNames = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
    ListWrapper.forEach(nestedPvsWithIndex, (function(pvWithIndex) {
      var parentVariableNames = isPresent(pvWithIndex.parentIndex) ? nestedPvVariableNames[pvWithIndex.parentIndex] : null;
      nestedPvVariableNames[pvWithIndex.index] = _createVariableNames(parentVariableNames, pvWithIndex.renderProtoView);
    }));
    return nestedPvVariableNames;
  }
  function _createVariableNames(parentVariableNames, renderProtoView) {
    var res = isBlank(parentVariableNames) ? [] : ListWrapper.clone(parentVariableNames);
    MapWrapper.forEach(renderProtoView.variableBindings, (function(mappedName, varName) {
      res.push(mappedName);
    }));
    ListWrapper.forEach(renderProtoView.elementBinders, (function(binder) {
      MapWrapper.forEach(binder.variableBindings, (function(mappedName, varName) {
        res.push(mappedName);
      }));
    }));
    return res;
  }
  function createVariableLocations(elementBinders) {
    var variableLocations = new Map();
    for (var i = 0; i < elementBinders.length; i++) {
      var binder = elementBinders[i];
      MapWrapper.forEach(binder.variableBindings, (function(mappedName, varName) {
        variableLocations.set(mappedName, i);
      }));
    }
    return variableLocations;
  }
  function _createElementBinders(protoView, elementBinders, allDirectiveBindings) {
    for (var i = 0; i < elementBinders.length; i++) {
      var renderElementBinder = elementBinders[i];
      var dirs = elementBinders[i].directives;
      var parentPeiWithDistance = _findParentProtoElementInjectorWithDistance(i, protoView.elementBinders, elementBinders);
      var directiveBindings = ListWrapper.map(dirs, (function(dir) {
        return allDirectiveBindings[dir.directiveIndex];
      }));
      var componentDirectiveBinding = null;
      if (directiveBindings.length > 0) {
        if (directiveBindings[0].metadata.type === renderApi.DirectiveMetadata.COMPONENT_TYPE) {
          componentDirectiveBinding = directiveBindings[0];
        }
      }
      var protoElementInjector = _createProtoElementInjector(i, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings);
      _createElementBinder(protoView, i, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings);
    }
  }
  function _findParentProtoElementInjectorWithDistance(binderIndex, elementBinders, renderElementBinders) {
    var distance = 0;
    do {
      var renderElementBinder = renderElementBinders[binderIndex];
      binderIndex = renderElementBinder.parentIndex;
      if (binderIndex !== -1) {
        distance += renderElementBinder.distanceToParent;
        var elementBinder = elementBinders[binderIndex];
        if (isPresent(elementBinder.protoElementInjector)) {
          return new ParentProtoElementInjectorWithDistance(elementBinder.protoElementInjector, distance);
        }
      }
    } while (binderIndex !== -1);
    return new ParentProtoElementInjectorWithDistance(null, 0);
  }
  function _createProtoElementInjector(binderIndex, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings) {
    var protoElementInjector = null;
    var hasVariables = MapWrapper.size(renderElementBinder.variableBindings) > 0;
    if (directiveBindings.length > 0 || hasVariables) {
      var directiveVariableBindings = createDirectiveVariableBindings(renderElementBinder, directiveBindings);
      protoElementInjector = ProtoElementInjector.create(parentPeiWithDistance.protoElementInjector, binderIndex, directiveBindings, isPresent(componentDirectiveBinding), parentPeiWithDistance.distance, directiveVariableBindings);
      protoElementInjector.attributes = renderElementBinder.readAttributes;
    }
    return protoElementInjector;
  }
  function _createElementBinder(protoView, boundElementIndex, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings) {
    var parent = null;
    if (renderElementBinder.parentIndex !== -1) {
      parent = protoView.elementBinders[renderElementBinder.parentIndex];
    }
    var elBinder = protoView.bindElement(parent, renderElementBinder.distanceToParent, protoElementInjector, componentDirectiveBinding);
    protoView.bindEvent(renderElementBinder.eventBindings, boundElementIndex, -1);
    MapWrapper.forEach(renderElementBinder.variableBindings, (function(mappedName, varName) {
      protoView.protoLocals.set(mappedName, null);
    }));
    return elBinder;
  }
  function createDirectiveVariableBindings(renderElementBinder, directiveBindings) {
    var directiveVariableBindings = new Map();
    MapWrapper.forEach(renderElementBinder.variableBindings, (function(templateName, exportAs) {
      var dirIndex = _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs);
      directiveVariableBindings.set(templateName, dirIndex);
    }));
    return directiveVariableBindings;
  }
  function _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs) {
    var matchedDirectiveIndex = null;
    var matchedDirective;
    for (var i = 0; i < directiveBindings.length; ++i) {
      var directive = directiveBindings[i];
      if (_directiveExportAs(directive) == exportAs) {
        if (isPresent(matchedDirective)) {
          throw new BaseException(("More than one directive have exportAs = '" + exportAs + "'. Directives: [" + matchedDirective.displayName + ", " + directive.displayName + "]"));
        }
        matchedDirectiveIndex = i;
        matchedDirective = directive;
      }
    }
    if (isBlank(matchedDirective) && exportAs !== "$implicit") {
      throw new BaseException(("Cannot find directive with exportAs = '" + exportAs + "'"));
    }
    return matchedDirectiveIndex;
  }
  function _directiveExportAs(directive) {
    var directiveExportAs = directive.metadata.exportAs;
    if (isBlank(directiveExportAs) && directive.metadata.type === renderApi.DirectiveMetadata.COMPONENT_TYPE) {
      return "$implicit";
    } else {
      return directiveExportAs;
    }
  }
  function _bindDirectiveEvents(protoView, elementBinders) {
    for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; ++boundElementIndex) {
      var dirs = elementBinders[boundElementIndex].directives;
      for (var i = 0; i < dirs.length; i++) {
        var directiveBinder = dirs[i];
        protoView.bindEvent(directiveBinder.eventBindings, boundElementIndex, i);
      }
    }
  }
  $__export("getChangeDetectorDefinitions", getChangeDetectorDefinitions);
  $__export("createVariableLocations", createVariableLocations);
  $__export("createDirectiveVariableBindings", createDirectiveVariableBindings);
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      assertionsEnabled = $__m.assertionsEnabled;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      DirectiveIndex = $__m.DirectiveIndex;
      BindingRecord = $__m.BindingRecord;
      DirectiveRecord = $__m.DirectiveRecord;
      DEFAULT = $__m.DEFAULT;
      ChangeDetectorDefinition = $__m.ChangeDetectorDefinition;
    }, function($__m) {
      renderApi = $__m;
    }, function($__m) {
      AppProtoView = $__m.AppProtoView;
    }, function($__m) {
      ProtoElementInjector = $__m.ProtoElementInjector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      BindingRecordsCreator = (function() {
        function BindingRecordsCreator() {
          this._directiveRecordsMap = new Map();
        }
        return ($traceurRuntime.createClass)(BindingRecordsCreator, {
          getBindingRecords: function(textBindings, elementBinders, allDirectiveMetadatas) {
            var bindings = [];
            this._createTextNodeRecords(bindings, textBindings);
            for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
              var renderElementBinder = elementBinders[boundElementIndex];
              this._createElementPropertyRecords(bindings, boundElementIndex, renderElementBinder);
              this._createDirectiveRecords(bindings, boundElementIndex, renderElementBinder.directives, allDirectiveMetadatas);
            }
            return bindings;
          },
          getDirectiveRecords: function(elementBinders, allDirectiveMetadatas) {
            var directiveRecords = [];
            for (var elementIndex = 0; elementIndex < elementBinders.length; ++elementIndex) {
              var dirs = elementBinders[elementIndex].directives;
              for (var dirIndex = 0; dirIndex < dirs.length; ++dirIndex) {
                directiveRecords.push(this._getDirectiveRecord(elementIndex, dirIndex, allDirectiveMetadatas[dirs[dirIndex].directiveIndex]));
              }
            }
            return directiveRecords;
          },
          _createTextNodeRecords: function(bindings, textBindings) {
            for (var i = 0; i < textBindings.length; i++) {
              bindings.push(BindingRecord.createForTextNode(textBindings[i], i));
            }
          },
          _createElementPropertyRecords: function(bindings, boundElementIndex, renderElementBinder) {
            ListWrapper.forEach(renderElementBinder.propertyBindings, (function(binding) {
              if (binding.type === renderApi.PropertyBindingType.PROPERTY) {
                bindings.push(BindingRecord.createForElementProperty(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === renderApi.PropertyBindingType.ATTRIBUTE) {
                bindings.push(BindingRecord.createForElementAttribute(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === renderApi.PropertyBindingType.CLASS) {
                bindings.push(BindingRecord.createForElementClass(binding.astWithSource, boundElementIndex, binding.property));
              } else if (binding.type === renderApi.PropertyBindingType.STYLE) {
                bindings.push(BindingRecord.createForElementStyle(binding.astWithSource, boundElementIndex, binding.property, binding.unit));
              }
            }));
          },
          _createDirectiveRecords: function(bindings, boundElementIndex, directiveBinders, allDirectiveMetadatas) {
            for (var i = 0; i < directiveBinders.length; i++) {
              var directiveBinder = directiveBinders[i];
              var directiveMetadata = allDirectiveMetadatas[directiveBinder.directiveIndex];
              var directiveRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
              MapWrapper.forEach(directiveBinder.propertyBindings, (function(astWithSource, propertyName) {
                var setter = reflector.setter(propertyName);
                bindings.push(BindingRecord.createForDirective(astWithSource, propertyName, setter, directiveRecord));
              }));
              if (directiveRecord.callOnChange) {
                bindings.push(BindingRecord.createDirectiveOnChange(directiveRecord));
              }
              if (directiveRecord.callOnInit) {
                bindings.push(BindingRecord.createDirectiveOnInit(directiveRecord));
              }
              if (directiveRecord.callOnCheck) {
                bindings.push(BindingRecord.createDirectiveOnCheck(directiveRecord));
              }
            }
            for (var i = 0; i < directiveBinders.length; i++) {
              var directiveBinder = directiveBinders[i];
              ListWrapper.forEach(directiveBinder.hostPropertyBindings, (function(binding) {
                var dirIndex = new DirectiveIndex(boundElementIndex, i);
                if (binding.type === renderApi.PropertyBindingType.PROPERTY) {
                  bindings.push(BindingRecord.createForHostProperty(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === renderApi.PropertyBindingType.ATTRIBUTE) {
                  bindings.push(BindingRecord.createForHostAttribute(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === renderApi.PropertyBindingType.CLASS) {
                  bindings.push(BindingRecord.createForHostClass(dirIndex, binding.astWithSource, binding.property));
                } else if (binding.type === renderApi.PropertyBindingType.STYLE) {
                  bindings.push(BindingRecord.createForHostStyle(dirIndex, binding.astWithSource, binding.property, binding.unit));
                }
              }));
            }
          },
          _getDirectiveRecord: function(boundElementIndex, directiveIndex, directiveMetadata) {
            var id = boundElementIndex * 100 + directiveIndex;
            if (!this._directiveRecordsMap.has(id)) {
              this._directiveRecordsMap.set(id, new DirectiveRecord({
                directiveIndex: new DirectiveIndex(boundElementIndex, directiveIndex),
                callOnAllChangesDone: directiveMetadata.callOnAllChangesDone,
                callOnChange: directiveMetadata.callOnChange,
                callOnCheck: directiveMetadata.callOnCheck,
                callOnInit: directiveMetadata.callOnInit,
                changeDetection: directiveMetadata.changeDetection
              }));
            }
            return this._directiveRecordsMap.get(id);
          }
        }, {});
      }());
      ProtoViewFactory = (($traceurRuntime.createClass)(function(_changeDetection) {
        this._changeDetection = _changeDetection;
      }, {createAppProtoViews: function(hostComponentBinding, rootRenderProtoView, allDirectives) {
          var $__0 = this;
          var allRenderDirectiveMetadata = ListWrapper.map(allDirectives, (function(directiveBinding) {
            return directiveBinding.metadata;
          }));
          var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
          var nestedPvVariableBindings = _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex);
          var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
          var changeDetectorDefs = _getChangeDetectorDefinitions(hostComponentBinding.metadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
          var protoChangeDetectors = ListWrapper.map(changeDetectorDefs, (function(changeDetectorDef) {
            return $__0._changeDetection.createProtoChangeDetector(changeDetectorDef);
          }));
          var appProtoViews = ListWrapper.createFixedSize(nestedPvsWithIndex.length);
          ListWrapper.forEach(nestedPvsWithIndex, (function(pvWithIndex) {
            var appProtoView = _createAppProtoView(pvWithIndex.renderProtoView, protoChangeDetectors[pvWithIndex.index], nestedPvVariableBindings[pvWithIndex.index], allDirectives);
            if (isPresent(pvWithIndex.parentIndex)) {
              var parentView = appProtoViews[pvWithIndex.parentIndex];
              parentView.elementBinders[pvWithIndex.boundElementIndex].nestedProtoView = appProtoView;
            }
            appProtoViews[pvWithIndex.index] = appProtoView;
          }));
          return appProtoViews;
        }}, {}));
      $__export("ProtoViewFactory", ProtoViewFactory);
      $__export("ProtoViewFactory", ProtoViewFactory = __decorate([Injectable(), __metadata('design:paramtypes', [ChangeDetection])], ProtoViewFactory));
      RenderProtoViewWithIndex = (function() {
        function RenderProtoViewWithIndex(renderProtoView, index, parentIndex, boundElementIndex) {
          this.renderProtoView = renderProtoView;
          this.index = index;
          this.parentIndex = parentIndex;
          this.boundElementIndex = boundElementIndex;
        }
        return ($traceurRuntime.createClass)(RenderProtoViewWithIndex, {}, {});
      }());
      ParentProtoElementInjectorWithDistance = (function() {
        function ParentProtoElementInjectorWithDistance(protoElementInjector, distance) {
          this.protoElementInjector = protoElementInjector;
          this.distance = distance;
        }
        return ($traceurRuntime.createClass)(ParentProtoElementInjectorWithDistance, {}, {});
      }());
    }
  };
});

System.register("angular2/src/services/url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/url_resolver";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      RegExpWrapper,
      ListWrapper,
      UrlResolver,
      _splitRe,
      _ComponentIndex;
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (isPresent(opt_scheme)) {
      out.push(opt_scheme + ':');
    }
    if (isPresent(opt_domain)) {
      out.push('//');
      if (isPresent(opt_userInfo)) {
        out.push(opt_userInfo + '@');
      }
      out.push(opt_domain);
      if (isPresent(opt_port)) {
        out.push(':' + opt_port);
      }
    }
    if (isPresent(opt_path)) {
      out.push(opt_path);
    }
    if (isPresent(opt_queryData)) {
      out.push('?' + opt_queryData);
    }
    if (isPresent(opt_fragment)) {
      out.push('#' + opt_fragment);
    }
    return out.join('');
  }
  function _split(uri) {
    return RegExpWrapper.firstMatch(_splitRe, uri);
  }
  function _removeDotSegments(path) {
    if (path == '/')
      return '/';
    var leadingSlash = path[0] == '/' ? '/' : '';
    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length > 0) {
            ListWrapper.removeAt(out, out.length - 1);
          } else {
            up++;
          }
          break;
        default:
          out.push(segment);
      }
    }
    if (leadingSlash == '') {
      while (up-- > 0) {
        ListWrapper.insert(out, 0, '..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function _joinAndCanonicalizePath(parts) {
    var path = parts[_ComponentIndex.PATH];
    path = isBlank(path) ? '' : _removeDotSegments(path);
    parts[_ComponentIndex.PATH] = path;
    return _buildFromEncodedParts(parts[_ComponentIndex.SCHEME], parts[_ComponentIndex.USER_INFO], parts[_ComponentIndex.DOMAIN], parts[_ComponentIndex.PORT], path, parts[_ComponentIndex.QUERY_DATA], parts[_ComponentIndex.FRAGMENT]);
  }
  function _resolveUrl(base, url) {
    var parts = _split(url);
    var baseParts = _split(base);
    if (isPresent(parts[_ComponentIndex.SCHEME])) {
      return _joinAndCanonicalizePath(parts);
    } else {
      parts[_ComponentIndex.SCHEME] = baseParts[_ComponentIndex.SCHEME];
    }
    for (var i = _ComponentIndex.SCHEME; i <= _ComponentIndex.PORT; i++) {
      if (isBlank(parts[i])) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[_ComponentIndex.PATH][0] == '/') {
      return _joinAndCanonicalizePath(parts);
    }
    var path = baseParts[_ComponentIndex.PATH];
    if (isBlank(path))
      path = '/';
    var index = path.lastIndexOf('/');
    path = path.substring(0, index + 1) + parts[_ComponentIndex.PATH];
    parts[_ComponentIndex.PATH] = path;
    return _joinAndCanonicalizePath(parts);
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      UrlResolver = (($traceurRuntime.createClass)(function() {}, {resolve: function(baseUrl, url) {
          return _resolveUrl(baseUrl, url);
        }}, {}));
      $__export("UrlResolver", UrlResolver);
      $__export("UrlResolver", UrlResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], UrlResolver));
      _splitRe = RegExpWrapper.create('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
      (function(_ComponentIndex) {
        _ComponentIndex[_ComponentIndex["SCHEME"] = 1] = "SCHEME";
        _ComponentIndex[_ComponentIndex["USER_INFO"] = 2] = "USER_INFO";
        _ComponentIndex[_ComponentIndex["DOMAIN"] = 3] = "DOMAIN";
        _ComponentIndex[_ComponentIndex["PORT"] = 4] = "PORT";
        _ComponentIndex[_ComponentIndex["PATH"] = 5] = "PATH";
        _ComponentIndex[_ComponentIndex["QUERY_DATA"] = 6] = "QUERY_DATA";
        _ComponentIndex[_ComponentIndex["FRAGMENT"] = 7] = "FRAGMENT";
      })(_ComponentIndex || (_ComponentIndex = {}));
    }
  };
});

System.register("angular2/src/services/app_root_url", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/app_root_url";
  var __decorate,
      __metadata,
      Injectable,
      AppRootUrl;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppRootUrl = (($traceurRuntime.createClass)(function(value) {
        this._value = value;
      }, {
        get value() {
          return this._value;
        },
        set value(value) {
          this._value = value;
        }
      }, {}));
      $__export("AppRootUrl", AppRootUrl);
      $__export("AppRootUrl", AppRootUrl = __decorate([Injectable(), __metadata('design:paramtypes', [String])], AppRootUrl));
    }
  };
});

System.register("angular2/src/core/exception_handler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/exception_handler";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      isListLikeIterable,
      _ArrayLogger,
      ExceptionHandler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _ArrayLogger = (function() {
        function _ArrayLogger() {
          this.res = [];
        }
        return ($traceurRuntime.createClass)(_ArrayLogger, {
          log: function(s) {
            this.res.push(s);
          },
          logGroup: function(s) {
            this.res.push(s);
          },
          logGroupEnd: function() {}
        }, {});
      }());
      ExceptionHandler = (($traceurRuntime.createClass)(function(logger) {
        var rethrowException = arguments[1] !== (void 0) ? arguments[1] : true;
        this.logger = logger;
        this.rethrowException = rethrowException;
      }, {
        call: function(exception) {
          var stackTrace = arguments[1] !== (void 0) ? arguments[1] : null;
          var reason = arguments[2] !== (void 0) ? arguments[2] : null;
          var originalException = this._findOriginalException(exception);
          var originalStack = this._findOriginalStack(exception);
          var context = this._findContext(exception);
          this.logger.logGroup(("EXCEPTION: " + exception));
          if (isPresent(stackTrace) && isBlank(originalStack)) {
            this.logger.log("STACKTRACE:");
            this.logger.log(this._longStackTrace(stackTrace));
          }
          if (isPresent(reason)) {
            this.logger.log(("REASON: " + reason));
          }
          if (isPresent(originalException)) {
            this.logger.log(("ORIGINAL EXCEPTION: " + originalException));
          }
          if (isPresent(originalStack)) {
            this.logger.log("ORIGINAL STACKTRACE:");
            this.logger.log(this._longStackTrace(originalStack));
          }
          if (isPresent(context)) {
            this.logger.log("ERROR CONTEXT:");
            this.logger.log(context);
          }
          this.logger.logGroupEnd();
          if (this.rethrowException)
            throw exception;
        },
        _longStackTrace: function(stackTrace) {
          return isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") : stackTrace.toString();
        },
        _findContext: function(exception) {
          try {
            if (!(exception instanceof BaseException))
              return null;
            return isPresent(exception.context) ? exception.context : this._findContext(exception.originalException);
          } catch (e) {
            return null;
          }
        },
        _findOriginalException: function(exception) {
          if (!(exception instanceof BaseException))
            return null;
          var e = exception.originalException;
          while (e instanceof BaseException && isPresent(e.originalException)) {
            e = e.originalException;
          }
          return e;
        },
        _findOriginalStack: function(exception) {
          if (!(exception instanceof BaseException))
            return null;
          var e = exception;
          var stack = exception.originalStack;
          while (e instanceof BaseException && isPresent(e.originalException)) {
            e = e.originalException;
            if (e instanceof BaseException && isPresent(e.originalException)) {
              stack = e.originalStack;
            }
          }
          return stack;
        }
      }, {exceptionToString: function(exception) {
          var stackTrace = arguments[1] !== (void 0) ? arguments[1] : null;
          var reason = arguments[2] !== (void 0) ? arguments[2] : null;
          var l = new _ArrayLogger();
          var e = new ExceptionHandler(l, false);
          e.call(exception, stackTrace, reason);
          return l.res.join("\n");
        }}));
      $__export("ExceptionHandler", ExceptionHandler);
      $__export("ExceptionHandler", ExceptionHandler = __decorate([Injectable(), __metadata('design:paramtypes', [Object, Boolean])], ExceptionHandler));
    }
  };
});

System.register("angular2/src/render/xhr", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/xhr";
  var XHR;
  return {
    setters: [],
    execute: function() {
      XHR = (function() {
        function XHR() {}
        return ($traceurRuntime.createClass)(XHR, {get: function(url) {
            return null;
          }}, {});
      }());
      $__export("XHR", XHR);
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_url_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/services/url_resolver"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_url_resolver";
  var __decorate,
      __metadata,
      Injectable,
      StringWrapper,
      UrlResolver,
      StyleUrlResolver,
      _cssUrlRe,
      _cssImportRe,
      _quoteRe;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      StyleUrlResolver = (($traceurRuntime.createClass)(function(_resolver) {
        this._resolver = _resolver;
      }, {
        resolveUrls: function(cssText, baseUrl) {
          cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
          cssText = this._replaceUrls(cssText, _cssImportRe, baseUrl);
          return cssText;
        },
        _replaceUrls: function(cssText, re, baseUrl) {
          var $__0 = this;
          return StringWrapper.replaceAllMapped(cssText, re, (function(m) {
            var pre = m[1];
            var url = StringWrapper.replaceAll(m[2], _quoteRe, '');
            var post = m[3];
            var resolvedUrl = $__0._resolver.resolve(baseUrl, url);
            return pre + "'" + resolvedUrl + "'" + post;
          }));
        }
      }, {}));
      $__export("StyleUrlResolver", StyleUrlResolver);
      $__export("StyleUrlResolver", StyleUrlResolver = __decorate([Injectable(), __metadata('design:paramtypes', [UrlResolver])], StyleUrlResolver));
      _cssUrlRe = /(url\()([^)]*)(\))/g;
      _cssImportRe = /(@import[\s]+(?!url\())['"]([^'"]*)['"](.*;)/g;
      _quoteRe = /['"]/g;
    }
  };
});

System.register("angular2/src/core/zone/ng_zone", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/zone/ng_zone";
  var ListWrapper,
      StringMapWrapper,
      normalizeBlank,
      isPresent,
      global,
      NgZone;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      normalizeBlank = $__m.normalizeBlank;
      isPresent = $__m.isPresent;
      global = $__m.global;
    }],
    execute: function() {
      NgZone = (function() {
        function NgZone($__3) {
          var enableLongStackTrace = $__3.enableLongStackTrace;
          this._inVmTurnDone = false;
          this._pendingTimeouts = [];
          this._onTurnStart = null;
          this._onTurnDone = null;
          this._onEventDone = null;
          this._onErrorHandler = null;
          this._pendingMicrotasks = 0;
          this._hasExecutedCodeInInnerZone = false;
          this._nestedRun = 0;
          if (global.zone) {
            this._disabled = false;
            this._mountZone = global.zone;
            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
          } else {
            this._disabled = true;
            this._mountZone = null;
          }
        }
        return ($traceurRuntime.createClass)(NgZone, {
          overrideOnTurnStart: function(onTurnStartFn) {
            this._onTurnStart = normalizeBlank(onTurnStartFn);
          },
          overrideOnTurnDone: function(onTurnDoneFn) {
            this._onTurnDone = normalizeBlank(onTurnDoneFn);
          },
          overrideOnEventDone: function(onEventDoneFn, opt_waitForAsync) {
            var $__0 = this;
            var normalizedOnEventDone = normalizeBlank(onEventDoneFn);
            if (opt_waitForAsync) {
              this._onEventDone = (function() {
                if (!$__0._pendingTimeouts.length) {
                  normalizedOnEventDone();
                }
              });
            } else {
              this._onEventDone = normalizedOnEventDone;
            }
          },
          overrideOnErrorHandler: function(errorHandlingFn) {
            this._onErrorHandler = normalizeBlank(errorHandlingFn);
          },
          run: function(fn) {
            if (this._disabled) {
              return fn();
            } else {
              return this._innerZone.run(fn);
            }
          },
          runOutsideAngular: function(fn) {
            if (this._disabled) {
              return fn();
            } else {
              return this._mountZone.run(fn);
            }
          },
          _createInnerZone: function(zone, enableLongStackTrace) {
            var ngZone = this;
            var errorHandling;
            if (enableLongStackTrace) {
              errorHandling = StringMapWrapper.merge(Zone.longStackTraceZone, {onError: function(e) {
                  ngZone._onError(this, e);
                }});
            } else {
              errorHandling = {onError: function(e) {
                  ngZone._onError(this, e);
                }};
            }
            return zone.fork(errorHandling).fork({
              '$run': function(parentRun) {
                return function() {
                  try {
                    ngZone._nestedRun++;
                    if (!ngZone._hasExecutedCodeInInnerZone) {
                      ngZone._hasExecutedCodeInInnerZone = true;
                      if (ngZone._onTurnStart) {
                        parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
                      }
                    }
                    return parentRun.apply(this, arguments);
                  } finally {
                    ngZone._nestedRun--;
                    if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 && !this._inVmTurnDone) {
                      if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
                        try {
                          this._inVmTurnDone = true;
                          parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
                          if (ngZone._pendingMicrotasks === 0 && isPresent(ngZone._onEventDone)) {
                            ngZone.runOutsideAngular(ngZone._onEventDone);
                          }
                        } finally {
                          this._inVmTurnDone = false;
                          ngZone._hasExecutedCodeInInnerZone = false;
                        }
                      }
                    }
                  }
                };
              },
              '$scheduleMicrotask': function(parentScheduleMicrotask) {
                return function(fn) {
                  ngZone._pendingMicrotasks++;
                  var microtask = function() {
                    try {
                      fn();
                    } finally {
                      ngZone._pendingMicrotasks--;
                    }
                  };
                  parentScheduleMicrotask.call(this, microtask);
                };
              },
              '$setTimeout': function(parentSetTimeout) {
                return function(fn, delay) {
                  for (var args = [],
                      $__2 = 2; $__2 < arguments.length; $__2++)
                    args[$__2 - 2] = arguments[$__2];
                  var id;
                  var cb = function() {
                    fn();
                    ListWrapper.remove(ngZone._pendingTimeouts, id);
                  };
                  id = parentSetTimeout(cb, delay, args);
                  ngZone._pendingTimeouts.push(id);
                  return id;
                };
              },
              '$clearTimeout': function(parentClearTimeout) {
                return function(id) {
                  parentClearTimeout(id);
                  ListWrapper.remove(ngZone._pendingTimeouts, id);
                };
              },
              _innerZone: true
            });
          },
          _onError: function(zone, e) {
            if (isPresent(this._onErrorHandler)) {
              var trace = [normalizeBlank(e.stack)];
              while (zone && zone.constructedAtException) {
                trace.push(zone.constructedAtException.get());
                zone = zone.parent;
              }
              this._onErrorHandler(e, trace);
            } else {
              console.log('## _onError ##');
              console.log(e.stack);
              throw e;
            }
          }
        }, {});
      }());
      $__export("NgZone", NgZone);
    }
  };
});

System.register("angular2/src/core/life_cycle/life_cycle", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/life_cycle/life_cycle";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      BaseException,
      LifeCycle;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LifeCycle = (($traceurRuntime.createClass)(function() {
        var changeDetector = arguments[0] !== (void 0) ? arguments[0] : null;
        var enforceNoNewChanges = arguments[1] !== (void 0) ? arguments[1] : false;
        this._runningTick = false;
        this._changeDetector = changeDetector;
        this._enforceNoNewChanges = enforceNoNewChanges;
      }, {
        registerWith: function(zone) {
          var changeDetector = arguments[1] !== (void 0) ? arguments[1] : null;
          var $__0 = this;
          if (isPresent(changeDetector)) {
            this._changeDetector = changeDetector;
          }
          zone.overrideOnTurnDone((function() {
            return $__0.tick();
          }));
        },
        tick: function() {
          if (this._runningTick) {
            throw new BaseException("LifeCycle.tick is called recursively");
          }
          try {
            this._runningTick = true;
            this._changeDetector.detectChanges();
            if (this._enforceNoNewChanges) {
              this._changeDetector.checkNoChanges();
            }
          } finally {
            this._runningTick = false;
          }
        }
      }, {}));
      $__export("LifeCycle", LifeCycle);
      $__export("LifeCycle", LifeCycle = __decorate([Injectable(), __metadata('design:paramtypes', [Object, Boolean])], LifeCycle));
    }
  };
});

System.register("angular2/src/render/xhr_impl", ["angular2/di", "angular2/src/facade/async", "angular2/src/render/xhr"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/xhr_impl";
  var __decorate,
      __metadata,
      Injectable,
      PromiseWrapper,
      XHR,
      XHRImpl;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      XHR = $__m.XHR;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      XHRImpl = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {get: function(url) {
            var completer = PromiseWrapper.completer();
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'text';
            xhr.onload = function() {
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : 0;
              }
              if (200 <= status && status <= 300) {
                completer.resolve(response);
              } else {
                completer.reject(("Failed to load " + url), null);
              }
            };
            xhr.onerror = function() {
              completer.reject(("Failed to load " + url), null);
            };
            xhr.send();
            return completer.promise;
          }}, {}, $__super);
      }(XHR));
      $__export("XHRImpl", XHRImpl);
      $__export("XHRImpl", XHRImpl = __decorate([Injectable(), __metadata('design:paramtypes', [])], XHRImpl));
    }
  };
});

System.register("angular2/src/render/dom/events/event_manager", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/event_manager";
  var BaseException,
      StringWrapper,
      DOM,
      BUBBLE_SYMBOL,
      EventManager,
      EventManagerPlugin,
      DomEventsPlugin;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      BUBBLE_SYMBOL = '^';
      EventManager = (function() {
        function EventManager(_plugins, _zone) {
          this._plugins = _plugins;
          this._zone = _zone;
          for (var i = 0; i < _plugins.length; i++) {
            _plugins[i].manager = this;
          }
        }
        return ($traceurRuntime.createClass)(EventManager, {
          addEventListener: function(element, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            plugin.addEventListener(element, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          addGlobalEventListener: function(target, eventName, handler) {
            var withoutBubbleSymbol = this._removeBubbleSymbol(eventName);
            var plugin = this._findPluginFor(withoutBubbleSymbol);
            return plugin.addGlobalEventListener(target, withoutBubbleSymbol, handler, withoutBubbleSymbol != eventName);
          },
          getZone: function() {
            return this._zone;
          },
          _findPluginFor: function(eventName) {
            var plugins = this._plugins;
            for (var i = 0; i < plugins.length; i++) {
              var plugin = plugins[i];
              if (plugin.supports(eventName)) {
                return plugin;
              }
            }
            throw new BaseException(("No event manager plugin found for event " + eventName));
          },
          _removeBubbleSymbol: function(eventName) {
            return eventName[0] == BUBBLE_SYMBOL ? StringWrapper.substring(eventName, 1) : eventName;
          }
        }, {});
      }());
      $__export("EventManager", EventManager);
      EventManagerPlugin = (function() {
        function EventManagerPlugin() {}
        return ($traceurRuntime.createClass)(EventManagerPlugin, {
          supports: function(eventName) {
            return false;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          },
          addGlobalEventListener: function(element, eventName, handler, shouldSupportBubble) {
            throw "not implemented";
          }
        }, {});
      }());
      $__export("EventManagerPlugin", EventManagerPlugin);
      DomEventsPlugin = (function($__super) {
        function DomEventsPlugin() {
          $traceurRuntime.superConstructor(DomEventsPlugin).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(DomEventsPlugin, {
          supports: function(eventName) {
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            this.manager._zone.runOutsideAngular((function() {
              DOM.on(element, eventName, outsideHandler);
            }));
          },
          addGlobalEventListener: function(target, eventName, handler, shouldSupportBubble) {
            var element = DOM.getGlobalEventTarget(target);
            var outsideHandler = this._getOutsideHandler(shouldSupportBubble, element, handler, this.manager._zone);
            return this.manager._zone.runOutsideAngular((function() {
              return DOM.onAndCancel(element, eventName, outsideHandler);
            }));
          },
          _getOutsideHandler: function(shouldSupportBubble, element, handler, zone) {
            return shouldSupportBubble ? DomEventsPlugin.bubbleCallback(element, handler, zone) : DomEventsPlugin.sameElementCallback(element, handler, zone);
          }
        }, {
          sameElementCallback: function(element, handler, zone) {
            return (function(event) {
              if (event.target === element) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          },
          bubbleCallback: function(element, handler, zone) {
            return (function(event) {
              return zone.run((function() {
                return handler(event);
              }));
            });
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("DomEventsPlugin", DomEventsPlugin);
    }
  };
});

System.register("angular2/src/render/dom/events/key_events", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/events/event_manager"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/key_events";
  var DOM,
      isPresent,
      StringWrapper,
      StringMapWrapper,
      ListWrapper,
      EventManagerPlugin,
      modifierKeys,
      modifierKeyGetters,
      KeyEventsPlugin;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }],
    execute: function() {
      modifierKeys = ['alt', 'control', 'meta', 'shift'];
      modifierKeyGetters = {
        'alt': (function(event) {
          return event.altKey;
        }),
        'control': (function(event) {
          return event.ctrlKey;
        }),
        'meta': (function(event) {
          return event.metaKey;
        }),
        'shift': (function(event) {
          return event.shiftKey;
        })
      };
      KeyEventsPlugin = (function($__super) {
        function KeyEventsPlugin() {
          $traceurRuntime.superConstructor(KeyEventsPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(KeyEventsPlugin, {
          supports: function(eventName) {
            return isPresent(KeyEventsPlugin.parseEventName(eventName));
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
            var outsideHandler = KeyEventsPlugin.eventCallback(element, shouldSupportBubble, StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
            this.manager.getZone().runOutsideAngular((function() {
              DOM.on(element, StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
            }));
          }
        }, {
          parseEventName: function(eventName) {
            var parts = eventName.toLowerCase().split('.');
            var domEventName = ListWrapper.removeAt(parts, 0);
            if ((parts.length === 0) || !(StringWrapper.equals(domEventName, 'keydown') || StringWrapper.equals(domEventName, 'keyup'))) {
              return null;
            }
            var key = KeyEventsPlugin._normalizeKey(ListWrapper.removeLast(parts));
            var fullKey = '';
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (ListWrapper.contains(parts, modifierName)) {
                ListWrapper.remove(parts, modifierName);
                fullKey += modifierName + '.';
              }
            }));
            fullKey += key;
            if (parts.length != 0 || key.length === 0) {
              return null;
            }
            var result = StringMapWrapper.create();
            StringMapWrapper.set(result, 'domEventName', domEventName);
            StringMapWrapper.set(result, 'fullKey', fullKey);
            return result;
          },
          getEventFullKey: function(event) {
            var fullKey = '';
            var key = DOM.getEventKey(event);
            key = key.toLowerCase();
            if (StringWrapper.equals(key, ' ')) {
              key = 'space';
            } else if (StringWrapper.equals(key, '.')) {
              key = 'dot';
            }
            ListWrapper.forEach(modifierKeys, (function(modifierName) {
              if (modifierName != key) {
                var modifierGetter = StringMapWrapper.get(modifierKeyGetters, modifierName);
                if (modifierGetter(event)) {
                  fullKey += modifierName + '.';
                }
              }
            }));
            fullKey += key;
            return fullKey;
          },
          eventCallback: function(element, shouldSupportBubble, fullKey, handler, zone) {
            return (function(event) {
              var correctElement = shouldSupportBubble || event.target === element;
              if (correctElement && StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                zone.run((function() {
                  return handler(event);
                }));
              }
            });
          },
          _normalizeKey: function(keyName) {
            switch (keyName) {
              case 'esc':
                return 'escape';
              default:
                return keyName;
            }
          }
        }, $__super);
      }(EventManagerPlugin));
      $__export("KeyEventsPlugin", KeyEventsPlugin);
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_common", ["angular2/src/render/dom/events/event_manager", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_common";
  var EventManagerPlugin,
      StringMapWrapper,
      _eventNames,
      HammerGesturesPluginCommon;
  return {
    setters: [function($__m) {
      EventManagerPlugin = $__m.EventManagerPlugin;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      _eventNames = {
        'pan': true,
        'panstart': true,
        'panmove': true,
        'panend': true,
        'pancancel': true,
        'panleft': true,
        'panright': true,
        'panup': true,
        'pandown': true,
        'pinch': true,
        'pinchstart': true,
        'pinchmove': true,
        'pinchend': true,
        'pinchcancel': true,
        'pinchin': true,
        'pinchout': true,
        'press': true,
        'pressup': true,
        'rotate': true,
        'rotatestart': true,
        'rotatemove': true,
        'rotateend': true,
        'rotatecancel': true,
        'swipe': true,
        'swipeleft': true,
        'swiperight': true,
        'swipeup': true,
        'swipedown': true,
        'tap': true
      };
      HammerGesturesPluginCommon = (function($__super) {
        function HammerGesturesPluginCommon() {
          $traceurRuntime.superConstructor(HammerGesturesPluginCommon).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPluginCommon, {supports: function(eventName) {
            eventName = eventName.toLowerCase();
            return StringMapWrapper.contains(_eventNames, eventName);
          }}, {}, $__super);
      }(EventManagerPlugin));
      $__export("HammerGesturesPluginCommon", HammerGesturesPluginCommon);
    }
  };
});

System.register("angular2/src/services/anchor_based_app_root_url", ["angular2/src/services/app_root_url", "angular2/src/dom/dom_adapter", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/services/anchor_based_app_root_url";
  var __decorate,
      __metadata,
      AppRootUrl,
      DOM,
      Injectable,
      AnchorBasedAppRootUrl;
  return {
    setters: [function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AnchorBasedAppRootUrl = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this, "");
          var rootUrl;
          var a = DOM.createElement('a');
          DOM.resolveAndSetHref(a, './', null);
          rootUrl = DOM.getHref(a);
          this.value = rootUrl;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(AppRootUrl));
      $__export("AnchorBasedAppRootUrl", AnchorBasedAppRootUrl);
      $__export("AnchorBasedAppRootUrl", AnchorBasedAppRootUrl = __decorate([Injectable(), __metadata('design:paramtypes', [])], AnchorBasedAppRootUrl));
    }
  };
});

System.register("angular2/src/core/compiler/dynamic_component_loader", ["angular2/di", "angular2/src/core/compiler/compiler", "angular2/src/core/compiler/view_manager"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/dynamic_component_loader";
  var __decorate,
      __metadata,
      Injectable,
      Compiler,
      AppViewManager,
      ComponentRef,
      DynamicComponentLoader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Compiler = $__m.Compiler;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ComponentRef = (function() {
        function ComponentRef(location, instance, _dispose) {
          this._dispose = _dispose;
          this.location = location;
          this.instance = instance;
        }
        return ($traceurRuntime.createClass)(ComponentRef, {
          get hostView() {
            return this.location.parentView;
          },
          dispose: function() {
            this._dispose();
          }
        }, {});
      }());
      $__export("ComponentRef", ComponentRef);
      DynamicComponentLoader = (($traceurRuntime.createClass)(function(_compiler, _viewManager) {
        this._compiler = _compiler;
        this._viewManager = _viewManager;
      }, {
        loadAsRoot: function(typeOrBinding, overrideSelector, injector) {
          var $__0 = this;
          return this._compiler.compileInHost(typeOrBinding).then((function(hostProtoViewRef) {
            var hostViewRef = $__0._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
            var newLocation = $__0._viewManager.getHostElement(hostViewRef);
            var component = $__0._viewManager.getComponent(newLocation);
            var dispose = (function() {
              $__0._viewManager.destroyRootHostView(hostViewRef);
            });
            return new ComponentRef(newLocation, component, dispose);
          }));
        },
        loadIntoLocation: function(typeOrBinding, hostLocation, anchorName) {
          var bindings = arguments[3] !== (void 0) ? arguments[3] : null;
          return this.loadNextToLocation(typeOrBinding, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), bindings);
        },
        loadNextToLocation: function(typeOrBinding, location) {
          var bindings = arguments[2] !== (void 0) ? arguments[2] : null;
          var $__0 = this;
          return this._compiler.compileInHost(typeOrBinding).then((function(hostProtoViewRef) {
            var viewContainer = $__0._viewManager.getViewContainer(location);
            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, bindings);
            var newLocation = $__0._viewManager.getHostElement(hostViewRef);
            var component = $__0._viewManager.getComponent(newLocation);
            var dispose = (function() {
              var index = viewContainer.indexOf(hostViewRef);
              if (index !== -1) {
                viewContainer.remove(index);
              }
            });
            return new ComponentRef(newLocation, component, dispose);
          }));
        }
      }, {}));
      $__export("DynamicComponentLoader", DynamicComponentLoader);
      $__export("DynamicComponentLoader", DynamicComponentLoader = __decorate([Injectable(), __metadata('design:paramtypes', [Compiler, AppViewManager])], DynamicComponentLoader));
    }
  };
});

System.register("angular2/src/core/testability/get_testability", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/get_testability";
  var global,
      PublicTestability,
      GetTestability;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      PublicTestability = (function() {
        function PublicTestability(testability) {
          this._testability = testability;
        }
        return ($traceurRuntime.createClass)(PublicTestability, {
          whenStable: function(callback) {
            this._testability.whenStable(callback);
          },
          findBindings: function(using, binding, exactMatch) {
            return this._testability.findBindings(using, binding, exactMatch);
          }
        }, {});
      }());
      GetTestability = (function() {
        function GetTestability() {}
        return ($traceurRuntime.createClass)(GetTestability, {}, {addToWindow: function(registry) {
            global.getAngularTestability = function(elem) {
              var testability = registry.findTestabilityInTree(elem);
              if (testability == null) {
                throw new Error('Could not find testability for element.');
              }
              return new PublicTestability(testability);
            };
          }});
      }());
      $__export("GetTestability", GetTestability);
    }
  };
});

System.register("angular2/src/render/dom/dom_tokens", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/dom_tokens";
  var OpaqueToken,
      bind,
      CONST_EXPR,
      StringWrapper,
      Math,
      DOCUMENT_TOKEN,
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES,
      APP_ID_TOKEN,
      APP_ID_RANDOM_BINDING;
  function randomChar() {
    return StringWrapper.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
      bind = $__m.bind;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
      StringWrapper = $__m.StringWrapper;
      Math = $__m.Math;
    }],
    execute: function() {
      DOCUMENT_TOKEN = CONST_EXPR(new OpaqueToken('DocumentToken'));
      $__export("DOCUMENT_TOKEN", DOCUMENT_TOKEN);
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES = CONST_EXPR(new OpaqueToken('DomReflectPropertiesAsAttributes'));
      $__export("DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES", DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES);
      APP_ID_TOKEN = CONST_EXPR(new OpaqueToken('AppId'));
      $__export("APP_ID_TOKEN", APP_ID_TOKEN);
      APP_ID_RANDOM_BINDING = bind(APP_ID_TOKEN).toFactory((function() {
        return ("" + randomChar() + randomChar() + randomChar());
      }), []);
      $__export("APP_ID_RANDOM_BINDING", APP_ID_RANDOM_BINDING);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_element", ["angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_element";
  var MapWrapper,
      DOM,
      isBlank,
      isPresent,
      StringJoiner,
      assertionsEnabled,
      CompileElement;
  function getElementDescription(domElement) {
    var buf = new StringJoiner();
    var atts = DOM.attributeMap(domElement);
    buf.add("<");
    buf.add(DOM.tagName(domElement).toLowerCase());
    addDescriptionAttribute(buf, "id", atts.get("id"));
    addDescriptionAttribute(buf, "class", atts.get("class"));
    MapWrapper.forEach(atts, (function(attValue, attName) {
      if (attName !== "id" && attName !== "class") {
        addDescriptionAttribute(buf, attName, attValue);
      }
    }));
    buf.add(">");
    return buf.toString();
  }
  function addDescriptionAttribute(buffer, attName, attValue) {
    if (isPresent(attValue)) {
      if (attValue.length === 0) {
        buffer.add(' ' + attName);
      } else {
        buffer.add(' ' + attName + '="' + attValue + '"');
      }
    }
  }
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      StringJoiner = $__m.StringJoiner;
      assertionsEnabled = $__m.assertionsEnabled;
    }],
    execute: function() {
      CompileElement = (function() {
        function CompileElement(element) {
          var compilationUnit = arguments[1] !== (void 0) ? arguments[1] : '';
          this.element = element;
          this._attrs = null;
          this._classList = null;
          this.isViewRoot = false;
          this.inheritedProtoView = null;
          this.distanceToInheritedBinder = 0;
          this.inheritedElementBinder = null;
          this.compileChildren = true;
          var tplDesc = assertionsEnabled() ? getElementDescription(element) : null;
          if (compilationUnit !== '') {
            this.elementDescription = compilationUnit;
            if (isPresent(tplDesc))
              this.elementDescription += ": " + tplDesc;
          } else {
            this.elementDescription = tplDesc;
          }
        }
        return ($traceurRuntime.createClass)(CompileElement, {
          isBound: function() {
            return isPresent(this.inheritedElementBinder) && this.distanceToInheritedBinder === 0;
          },
          bindElement: function() {
            if (!this.isBound()) {
              var parentBinder = this.inheritedElementBinder;
              this.inheritedElementBinder = this.inheritedProtoView.bindElement(this.element, this.elementDescription);
              if (isPresent(parentBinder)) {
                this.inheritedElementBinder.setParent(parentBinder, this.distanceToInheritedBinder);
              }
              this.distanceToInheritedBinder = 0;
            }
            return this.inheritedElementBinder;
          },
          refreshAttrs: function() {
            this._attrs = null;
          },
          attrs: function() {
            if (isBlank(this._attrs)) {
              this._attrs = DOM.attributeMap(this.element);
            }
            return this._attrs;
          },
          refreshClassList: function() {
            this._classList = null;
          },
          classList: function() {
            if (isBlank(this._classList)) {
              this._classList = [];
              var elClassList = DOM.classList(this.element);
              for (var i = 0; i < elClassList.length; i++) {
                this._classList.push(elClassList[i]);
              }
            }
            return this._classList;
          }
        }, {});
      }());
      $__export("CompileElement", CompileElement);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_control", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_control";
  var isBlank,
      CompileControl;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      CompileControl = (function() {
        function CompileControl(_steps) {
          this._steps = _steps;
          this._currentStepIndex = 0;
          this._parent = null;
          this._results = null;
          this._additionalChildren = null;
        }
        return ($traceurRuntime.createClass)(CompileControl, {
          internalProcess: function(results, startStepIndex, parent, current) {
            this._results = results;
            var previousStepIndex = this._currentStepIndex;
            var previousParent = this._parent;
            this._ignoreCurrentElement = false;
            for (var i = startStepIndex; i < this._steps.length && !this._ignoreCurrentElement; i++) {
              var step = this._steps[i];
              this._parent = parent;
              this._currentStepIndex = i;
              step.processElement(parent, current, this);
              parent = this._parent;
            }
            if (!this._ignoreCurrentElement) {
              results.push(current);
            }
            this._currentStepIndex = previousStepIndex;
            this._parent = previousParent;
            var localAdditionalChildren = this._additionalChildren;
            this._additionalChildren = null;
            return localAdditionalChildren;
          },
          addParent: function(newElement) {
            this.internalProcess(this._results, this._currentStepIndex + 1, this._parent, newElement);
            this._parent = newElement;
          },
          addChild: function(element) {
            if (isBlank(this._additionalChildren)) {
              this._additionalChildren = [];
            }
            this._additionalChildren.push(element);
          },
          ignoreCurrentElement: function() {
            this._ignoreCurrentElement = true;
          }
        }, {});
      }());
      $__export("CompileControl", CompileControl);
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view", ["angular2/src/render/api", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view";
  var RenderProtoViewRef,
      DOM,
      DomProtoViewRef,
      DomProtoView;
  function resolveInternalDomProtoView(protoViewRef) {
    return protoViewRef._protoView;
  }
  $__export("resolveInternalDomProtoView", resolveInternalDomProtoView);
  return {
    setters: [function($__m) {
      RenderProtoViewRef = $__m.RenderProtoViewRef;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      DomProtoViewRef = (function($__super) {
        function DomProtoViewRef(_protoView) {
          $traceurRuntime.superConstructor(DomProtoViewRef).call(this);
          this._protoView = _protoView;
        }
        return ($traceurRuntime.createClass)(DomProtoViewRef, {}, {}, $__super);
      }(RenderProtoViewRef));
      $__export("DomProtoViewRef", DomProtoViewRef);
      DomProtoView = (function() {
        function DomProtoView(type, rootElement, encapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment) {
          this.type = type;
          this.rootElement = rootElement;
          this.encapsulation = encapsulation;
          this.elementBinders = elementBinders;
          this.hostAttributes = hostAttributes;
          this.rootTextNodeIndices = rootTextNodeIndices;
          this.boundTextNodeCount = boundTextNodeCount;
          this.fragmentsRootNodeCount = fragmentsRootNodeCount;
          this.isSingleElementFragment = isSingleElementFragment;
        }
        return ($traceurRuntime.createClass)(DomProtoView, {}, {create: function(type, rootElement, viewEncapsulation, fragmentsRootNodeCount, rootTextNodeIndices, elementBinders, hostAttributes) {
            var boundTextNodeCount = rootTextNodeIndices.length;
            for (var i = 0; i < elementBinders.length; i++) {
              boundTextNodeCount += elementBinders[i].textNodeIndices.length;
            }
            var isSingleElementFragment = fragmentsRootNodeCount.length === 1 && fragmentsRootNodeCount[0] === 1 && DOM.isElementNode(DOM.firstChild(DOM.content(rootElement)));
            return new DomProtoView(type, rootElement, viewEncapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment);
          }});
      }());
      $__export("DomProtoView", DomProtoView);
    }
  };
});

System.register("angular2/src/render/dom/view/element_binder", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/element_binder";
  var isPresent,
      DomElementBinder,
      Event,
      HostAction;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      DomElementBinder = (function() {
        function DomElementBinder() {
          var $__1 = arguments[0] !== (void 0) ? arguments[0] : {},
              textNodeIndices = $__1.textNodeIndices,
              hasNestedProtoView = $__1.hasNestedProtoView,
              eventLocals = $__1.eventLocals,
              localEvents = $__1.localEvents,
              globalEvents = $__1.globalEvents,
              hasNativeShadowRoot = $__1.hasNativeShadowRoot;
          this.textNodeIndices = textNodeIndices;
          this.hasNestedProtoView = hasNestedProtoView;
          this.eventLocals = eventLocals;
          this.localEvents = localEvents;
          this.globalEvents = globalEvents;
          this.hasNativeShadowRoot = isPresent(hasNativeShadowRoot) ? hasNativeShadowRoot : false;
        }
        return ($traceurRuntime.createClass)(DomElementBinder, {}, {});
      }());
      $__export("DomElementBinder", DomElementBinder);
      Event = (function() {
        function Event(name, target, fullName) {
          this.name = name;
          this.target = target;
          this.fullName = fullName;
        }
        return ($traceurRuntime.createClass)(Event, {}, {});
      }());
      $__export("Event", Event);
      HostAction = (function() {
        function HostAction(actionName, actionExpression, expression) {
          this.actionName = actionName;
          this.actionExpression = actionExpression;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(HostAction, {}, {});
      }());
      $__export("HostAction", HostAction);
    }
  };
});

System.register("angular2/src/render/dom/util", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/util";
  var StringWrapper,
      isPresent,
      isBlank,
      DOM,
      ListWrapper,
      NG_BINDING_CLASS_SELECTOR,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      NG_CONTENT_ELEMENT_NAME,
      NG_SHADOW_ROOT_ELEMENT_NAME,
      CAMEL_CASE_REGEXP,
      DASH_CASE_REGEXP,
      ClonedProtoView;
  function camelCaseToDashCase(input) {
    return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, (function(m) {
      return '-' + m[1].toLowerCase();
    }));
  }
  function dashCaseToCamelCase(input) {
    return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, (function(m) {
      return m[1].toUpperCase();
    }));
  }
  function queryBoundElements(templateContent, isSingleElementChild) {
    var result;
    var dynamicElementList;
    var elementIdx = 0;
    if (isSingleElementChild) {
      var rootElement = DOM.firstChild(templateContent);
      var rootHasBinding = DOM.hasClass(rootElement, NG_BINDING_CLASS);
      dynamicElementList = DOM.getElementsByClassName(rootElement, NG_BINDING_CLASS);
      result = ListWrapper.createFixedSize(dynamicElementList.length + (rootHasBinding ? 1 : 0));
      if (rootHasBinding) {
        result[elementIdx++] = rootElement;
      }
    } else {
      dynamicElementList = DOM.querySelectorAll(templateContent, NG_BINDING_CLASS_SELECTOR);
      result = ListWrapper.createFixedSize(dynamicElementList.length);
    }
    for (var i = 0; i < dynamicElementList.length; i++) {
      result[elementIdx++] = dynamicElementList[i];
    }
    return result;
  }
  function cloneAndQueryProtoView(pv, importIntoDocument) {
    var templateContent = importIntoDocument ? DOM.importIntoDoc(DOM.content(pv.rootElement)) : DOM.clone(DOM.content(pv.rootElement));
    var boundElements = queryBoundElements(templateContent, pv.isSingleElementFragment);
    var boundTextNodes = queryBoundTextNodes(templateContent, pv.rootTextNodeIndices, boundElements, pv.elementBinders, pv.boundTextNodeCount);
    var fragments = queryFragments(templateContent, pv.fragmentsRootNodeCount);
    return new ClonedProtoView(pv, fragments, boundElements, boundTextNodes);
  }
  function queryFragments(templateContent, fragmentsRootNodeCount) {
    var fragments = ListWrapper.createGrowableSize(fragmentsRootNodeCount.length);
    var childNode = DOM.firstChild(templateContent);
    for (var fragmentIndex = 0; fragmentIndex < fragments.length; fragmentIndex++) {
      var fragment = ListWrapper.createFixedSize(fragmentsRootNodeCount[fragmentIndex]);
      fragments[fragmentIndex] = fragment;
      for (var i = 0; i < fragment.length; i++) {
        fragment[i] = childNode;
        childNode = DOM.nextSibling(childNode);
      }
    }
    return fragments;
  }
  function queryBoundTextNodes(templateContent, rootTextNodeIndices, boundElements, elementBinders, boundTextNodeCount) {
    var boundTextNodes = ListWrapper.createFixedSize(boundTextNodeCount);
    var textNodeIndex = 0;
    if (rootTextNodeIndices.length > 0) {
      var rootChildNodes = DOM.childNodes(templateContent);
      for (var i = 0; i < rootTextNodeIndices.length; i++) {
        boundTextNodes[textNodeIndex++] = rootChildNodes[rootTextNodeIndices[i]];
      }
    }
    for (var i = 0; i < elementBinders.length; i++) {
      var binder = elementBinders[i];
      var element = boundElements[i];
      if (binder.textNodeIndices.length > 0) {
        var childNodes = DOM.childNodes(element);
        for (var j = 0; j < binder.textNodeIndices.length; j++) {
          boundTextNodes[textNodeIndex++] = childNodes[binder.textNodeIndices[j]];
        }
      }
    }
    return boundTextNodes;
  }
  function isElementWithTag(node, elementName) {
    return DOM.isElementNode(node) && DOM.tagName(node).toLowerCase() == elementName.toLowerCase();
  }
  function queryBoundTextNodeIndices(parentNode, boundTextNodes, resultCallback) {
    var childNodes = DOM.childNodes(parentNode);
    for (var j = 0; j < childNodes.length; j++) {
      var node = childNodes[j];
      if (boundTextNodes.has(node)) {
        resultCallback(node, j, boundTextNodes.get(node));
      }
    }
  }
  function prependAll(parentNode, nodes) {
    var lastInsertedNode = null;
    nodes.forEach((function(node) {
      if (isBlank(lastInsertedNode)) {
        var firstChild = DOM.firstChild(parentNode);
        if (isPresent(firstChild)) {
          DOM.insertBefore(firstChild, node);
        } else {
          DOM.appendChild(parentNode, node);
        }
      } else {
        DOM.insertAfter(lastInsertedNode, node);
      }
      lastInsertedNode = node;
    }));
  }
  $__export("camelCaseToDashCase", camelCaseToDashCase);
  $__export("dashCaseToCamelCase", dashCaseToCamelCase);
  $__export("queryBoundElements", queryBoundElements);
  $__export("cloneAndQueryProtoView", cloneAndQueryProtoView);
  $__export("isElementWithTag", isElementWithTag);
  $__export("queryBoundTextNodeIndices", queryBoundTextNodeIndices);
  $__export("prependAll", prependAll);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }],
    execute: function() {
      NG_BINDING_CLASS_SELECTOR = '.ng-binding';
      $__export("NG_BINDING_CLASS_SELECTOR", NG_BINDING_CLASS_SELECTOR);
      NG_BINDING_CLASS = 'ng-binding';
      $__export("NG_BINDING_CLASS", NG_BINDING_CLASS);
      EVENT_TARGET_SEPARATOR = ':';
      $__export("EVENT_TARGET_SEPARATOR", EVENT_TARGET_SEPARATOR);
      NG_CONTENT_ELEMENT_NAME = 'ng-content';
      $__export("NG_CONTENT_ELEMENT_NAME", NG_CONTENT_ELEMENT_NAME);
      NG_SHADOW_ROOT_ELEMENT_NAME = 'shadow-root';
      $__export("NG_SHADOW_ROOT_ELEMENT_NAME", NG_SHADOW_ROOT_ELEMENT_NAME);
      CAMEL_CASE_REGEXP = /([A-Z])/g;
      DASH_CASE_REGEXP = /-([a-z])/g;
      ClonedProtoView = (function() {
        function ClonedProtoView(original, fragments, boundElements, boundTextNodes) {
          this.original = original;
          this.fragments = fragments;
          this.boundElements = boundElements;
          this.boundTextNodes = boundTextNodes;
        }
        return ($traceurRuntime.createClass)(ClonedProtoView, {}, {});
      }());
      $__export("ClonedProtoView", ClonedProtoView);
    }
  };
});

System.register("angular2/src/render/dom/compiler/property_binding_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/property_binding_parser";
  var isPresent,
      RegExpWrapper,
      StringWrapper,
      MapWrapper,
      dashCaseToCamelCase,
      BIND_NAME_REGEXP,
      PropertyBindingParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
      PropertyBindingParser = (function() {
        function PropertyBindingParser(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(PropertyBindingParser, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var newAttrs = new Map();
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              attrName = $__0._normalizeAttributeName(attrName);
              var bindParts = RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
              if (isPresent(bindParts)) {
                if (isPresent(bindParts[1])) {
                  $__0._bindProperty(bindParts[5], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[2])) {
                  var identifier = bindParts[5];
                  var value = attrValue == '' ? '\$implicit' : attrValue;
                  $__0._bindVariable(identifier, value, current, newAttrs);
                } else if (isPresent(bindParts[3])) {
                  $__0._bindEvent(bindParts[5], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[4])) {
                  $__0._bindProperty(bindParts[5], attrValue, current, newAttrs);
                  $__0._bindAssignmentEvent(bindParts[5], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[6])) {
                  $__0._bindProperty(bindParts[6], attrValue, current, newAttrs);
                  $__0._bindAssignmentEvent(bindParts[6], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[7])) {
                  $__0._bindProperty(bindParts[7], attrValue, current, newAttrs);
                } else if (isPresent(bindParts[8])) {
                  $__0._bindEvent(bindParts[8], attrValue, current, newAttrs);
                }
              } else {
                var expr = $__0._parser.parseInterpolation(attrValue, current.elementDescription);
                if (isPresent(expr)) {
                  $__0._bindPropertyAst(attrName, expr, current, newAttrs);
                }
              }
            }));
            MapWrapper.forEach(newAttrs, (function(attrValue, attrName) {
              attrs.set(attrName, attrValue);
            }));
          },
          _normalizeAttributeName: function(attrName) {
            return StringWrapper.startsWith(attrName, 'data-') ? StringWrapper.substring(attrName, 5) : attrName;
          },
          _bindVariable: function(identifier, value, current, newAttrs) {
            current.bindElement().bindVariable(dashCaseToCamelCase(identifier), value);
            newAttrs.set(identifier, value);
          },
          _bindProperty: function(name, expression, current, newAttrs) {
            this._bindPropertyAst(name, this._parser.parseBinding(expression, current.elementDescription), current, newAttrs);
          },
          _bindPropertyAst: function(name, ast, current, newAttrs) {
            var binder = current.bindElement();
            binder.bindProperty(dashCaseToCamelCase(name), ast);
            newAttrs.set(name, ast.source);
          },
          _bindAssignmentEvent: function(name, expression, current, newAttrs) {
            this._bindEvent(name, (expression + "=$event"), current, newAttrs);
          },
          _bindEvent: function(name, expression, current, newAttrs) {
            current.bindElement().bindEvent(dashCaseToCamelCase(name), this._parser.parseAction(expression, current.elementDescription));
          }
        }, {});
      }());
      $__export("PropertyBindingParser", PropertyBindingParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/text_interpolation_parser", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/text_interpolation_parser";
  var isPresent,
      DOM,
      TextInterpolationParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }],
    execute: function() {
      TextInterpolationParser = (function() {
        function TextInterpolationParser(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(TextInterpolationParser, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            if (!current.compileChildren) {
              return ;
            }
            var element = current.element;
            var childNodes = DOM.childNodes(DOM.templateAwareRoot(element));
            for (var i = 0; i < childNodes.length; i++) {
              var node = childNodes[i];
              if (DOM.isTextNode(node)) {
                var textNode = node;
                var text = DOM.nodeValue(textNode);
                var expr = this._parser.parseInterpolation(text, current.elementDescription);
                if (isPresent(expr)) {
                  DOM.setText(textNode, ' ');
                  if (current.element === current.inheritedProtoView.rootElement) {
                    current.inheritedProtoView.bindRootText(textNode, expr);
                  } else {
                    current.bindElement().bindText(textNode, expr);
                  }
                }
              }
            }
          }
        }, {});
      }());
      $__export("TextInterpolationParser", TextInterpolationParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/selector", ["angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/selector";
  var Map,
      ListWrapper,
      isPresent,
      isBlank,
      RegExpWrapper,
      RegExpMatcherWrapper,
      StringWrapper,
      BaseException,
      _EMPTY_ATTR_VALUE,
      _SELECTOR_REGEXP,
      CssSelector,
      SelectorMatcher,
      SelectorListContext,
      SelectorContext;
  return {
    setters: [function($__m) {
      Map = $__m.Map;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      _EMPTY_ATTR_VALUE = '';
      _SELECTOR_REGEXP = RegExpWrapper.create('(\\:not\\()|' + '([-\\w]+)|' + '(?:\\.([-\\w]+))|' + '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' + '(\\))|' + '(\\s*,\\s*)');
      CssSelector = (function() {
        function CssSelector() {
          this.element = null;
          this.classNames = [];
          this.attrs = [];
          this.notSelectors = [];
        }
        return ($traceurRuntime.createClass)(CssSelector, {
          isElementSelector: function() {
            return isPresent(this.element) && ListWrapper.isEmpty(this.classNames) && ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
          },
          setElement: function() {
            var element = arguments[0] !== (void 0) ? arguments[0] : null;
            if (isPresent(element)) {
              element = element.toLowerCase();
            }
            this.element = element;
          },
          addAttribute: function(name) {
            var value = arguments[1] !== (void 0) ? arguments[1] : _EMPTY_ATTR_VALUE;
            this.attrs.push(name.toLowerCase());
            if (isPresent(value)) {
              value = value.toLowerCase();
            } else {
              value = _EMPTY_ATTR_VALUE;
            }
            this.attrs.push(value);
          },
          addClassName: function(name) {
            this.classNames.push(name.toLowerCase());
          },
          toString: function() {
            var res = '';
            if (isPresent(this.element)) {
              res += this.element;
            }
            if (isPresent(this.classNames)) {
              for (var i = 0; i < this.classNames.length; i++) {
                res += '.' + this.classNames[i];
              }
            }
            if (isPresent(this.attrs)) {
              for (var i = 0; i < this.attrs.length; ) {
                var attrName = this.attrs[i++];
                var attrValue = this.attrs[i++];
                res += '[' + attrName;
                if (attrValue.length > 0) {
                  res += '=' + attrValue;
                }
                res += ']';
              }
            }
            ListWrapper.forEach(this.notSelectors, (function(notSelector) {
              res += ":not(" + notSelector.toString() + ")";
            }));
            return res;
          }
        }, {parse: function(selector) {
            var results = [];
            var _addResult = (function(res, cssSel) {
              if (cssSel.notSelectors.length > 0 && isBlank(cssSel.element) && ListWrapper.isEmpty(cssSel.classNames) && ListWrapper.isEmpty(cssSel.attrs)) {
                cssSel.element = "*";
              }
              res.push(cssSel);
            });
            var cssSelector = new CssSelector();
            var matcher = RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
            var match;
            var current = cssSelector;
            var inNot = false;
            while (isPresent(match = RegExpMatcherWrapper.next(matcher))) {
              if (isPresent(match[1])) {
                if (inNot) {
                  throw new BaseException('Nesting :not is not allowed in a selector');
                }
                inNot = true;
                current = new CssSelector();
                cssSelector.notSelectors.push(current);
              }
              if (isPresent(match[2])) {
                current.setElement(match[2]);
              }
              if (isPresent(match[3])) {
                current.addClassName(match[3]);
              }
              if (isPresent(match[4])) {
                current.addAttribute(match[4], match[5]);
              }
              if (isPresent(match[6])) {
                inNot = false;
                current = cssSelector;
              }
              if (isPresent(match[7])) {
                if (inNot) {
                  throw new BaseException('Multiple selectors in :not are not supported');
                }
                _addResult(results, cssSelector);
                cssSelector = current = new CssSelector();
              }
            }
            _addResult(results, cssSelector);
            return results;
          }});
      }());
      $__export("CssSelector", CssSelector);
      SelectorMatcher = (function() {
        function SelectorMatcher() {
          this._elementMap = new Map();
          this._elementPartialMap = new Map();
          this._classMap = new Map();
          this._classPartialMap = new Map();
          this._attrValueMap = new Map();
          this._attrValuePartialMap = new Map();
          this._listContexts = [];
        }
        return ($traceurRuntime.createClass)(SelectorMatcher, {
          addSelectables: function(cssSelectors, callbackCtxt) {
            var listContext = null;
            if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              this._listContexts.push(listContext);
            }
            for (var i = 0; i < cssSelectors.length; i++) {
              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
          },
          _addSelectable: function(cssSelector, callbackCtxt, listContext) {
            var matcher = this;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (isPresent(element)) {
              var isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                this._addTerminal(matcher._elementMap, element, selectable);
              } else {
                matcher = this._addPartial(matcher._elementPartialMap, element);
              }
            }
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
                var className = classNames[index];
                if (isTerminal) {
                  this._addTerminal(matcher._classMap, className, selectable);
                } else {
                  matcher = this._addPartial(matcher._classPartialMap, className);
                }
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var isTerminal = index === attrs.length - 2;
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                if (isTerminal) {
                  var terminalMap = matcher._attrValueMap;
                  var terminalValuesMap = terminalMap.get(attrName);
                  if (isBlank(terminalValuesMap)) {
                    terminalValuesMap = new Map();
                    terminalMap.set(attrName, terminalValuesMap);
                  }
                  this._addTerminal(terminalValuesMap, attrValue, selectable);
                } else {
                  var parttialMap = matcher._attrValuePartialMap;
                  var partialValuesMap = parttialMap.get(attrName);
                  if (isBlank(partialValuesMap)) {
                    partialValuesMap = new Map();
                    parttialMap.set(attrName, partialValuesMap);
                  }
                  matcher = this._addPartial(partialValuesMap, attrValue);
                }
              }
            }
          },
          _addTerminal: function(map, name, selectable) {
            var terminalList = map.get(name);
            if (isBlank(terminalList)) {
              terminalList = [];
              map.set(name, terminalList);
            }
            terminalList.push(selectable);
          },
          _addPartial: function(map, name) {
            var matcher = map.get(name);
            if (isBlank(matcher)) {
              matcher = new SelectorMatcher();
              map.set(name, matcher);
            }
            return matcher;
          },
          match: function(cssSelector, matchedCallback) {
            var result = false;
            var element = cssSelector.element;
            var classNames = cssSelector.classNames;
            var attrs = cssSelector.attrs;
            for (var i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
            if (isPresent(classNames)) {
              for (var index = 0; index < classNames.length; index++) {
                var className = classNames[index];
                result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
              }
            }
            if (isPresent(attrs)) {
              for (var index = 0; index < attrs.length; ) {
                var attrName = attrs[index++];
                var attrValue = attrs[index++];
                var terminalValuesMap = this._attrValueMap.get(attrName);
                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                  result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                }
                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) || result;
                var partialValuesMap = this._attrValuePartialMap.get(attrName);
                if (!StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
                  result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) || result;
                }
                result = this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
              }
            }
            return result;
          },
          _matchTerminal: function(map, name, cssSelector, matchedCallback) {
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var selectables = map.get(name);
            var starSelectables = map.get("*");
            if (isPresent(starSelectables)) {
              selectables = ListWrapper.concat(selectables, starSelectables);
            }
            if (isBlank(selectables)) {
              return false;
            }
            var selectable;
            var result = false;
            for (var index = 0; index < selectables.length; index++) {
              selectable = selectables[index];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
          },
          _matchPartial: function(map, name, cssSelector, matchedCallback) {
            if (isBlank(map) || isBlank(name)) {
              return false;
            }
            var nestedSelector = map.get(name);
            if (isBlank(nestedSelector)) {
              return false;
            }
            return nestedSelector.match(cssSelector, matchedCallback);
          }
        }, {createNotMatcher: function(notSelectors) {
            var notMatcher = new SelectorMatcher();
            notMatcher.addSelectables(notSelectors, null);
            return notMatcher;
          }});
      }());
      $__export("SelectorMatcher", SelectorMatcher);
      SelectorListContext = (function() {
        function SelectorListContext(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
        }
        return ($traceurRuntime.createClass)(SelectorListContext, {}, {});
      }());
      $__export("SelectorListContext", SelectorListContext);
      SelectorContext = (function() {
        function SelectorContext(selector, cbContext, listContext) {
          this.selector = selector;
          this.cbContext = cbContext;
          this.listContext = listContext;
          this.notSelectors = selector.notSelectors;
        }
        return ($traceurRuntime.createClass)(SelectorContext, {finalize: function(cssSelector, callback) {
            var result = true;
            if (this.notSelectors.length > 0 && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
              result = !notMatcher.match(cssSelector, null);
            }
            if (result && isPresent(callback) && (isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
              if (isPresent(this.listContext)) {
                this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
            }
            return result;
          }}, {});
      }());
      $__export("SelectorContext", SelectorContext);
    }
  };
});

System.register("angular2/src/render/dom/compiler/view_splitter", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/view_splitter";
  var isPresent,
      BaseException,
      StringWrapper,
      DOM,
      MapWrapper,
      CompileElement,
      dashCaseToCamelCase,
      ViewSplitter;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
    }],
    execute: function() {
      ViewSplitter = (function() {
        function ViewSplitter(_parser) {
          this._parser = _parser;
        }
        return ($traceurRuntime.createClass)(ViewSplitter, {
          processStyle: function(style) {
            return style;
          },
          processElement: function(parent, current, control) {
            var attrs = current.attrs();
            var templateBindings = attrs.get('template');
            var hasTemplateBinding = isPresent(templateBindings);
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              if (StringWrapper.startsWith(attrName, '*')) {
                var key = StringWrapper.substring(attrName, 1);
                if (hasTemplateBinding) {
                  throw new BaseException("Only one template directive per element is allowed: " + (templateBindings + " and " + key + " cannot be used simultaneously ") + ("in " + current.elementDescription));
                } else {
                  templateBindings = (attrValue.length == 0) ? key : key + ' ' + attrValue;
                  hasTemplateBinding = true;
                }
              }
            }));
            if (isPresent(parent)) {
              if (DOM.isTemplateElement(current.element)) {
                if (!current.isViewRoot) {
                  var viewRoot = new CompileElement(DOM.createTemplate(''));
                  viewRoot.inheritedProtoView = current.bindElement().bindNestedProtoView(viewRoot.element);
                  viewRoot.elementDescription = current.elementDescription;
                  viewRoot.isViewRoot = true;
                  this._moveChildNodes(DOM.content(current.element), DOM.content(viewRoot.element));
                  control.addChild(viewRoot);
                }
              }
              if (hasTemplateBinding) {
                var anchor = new CompileElement(DOM.createTemplate(''));
                anchor.inheritedProtoView = current.inheritedProtoView;
                anchor.inheritedElementBinder = current.inheritedElementBinder;
                anchor.distanceToInheritedBinder = current.distanceToInheritedBinder;
                anchor.elementDescription = current.elementDescription;
                var viewRoot = new CompileElement(DOM.createTemplate(''));
                viewRoot.inheritedProtoView = anchor.bindElement().bindNestedProtoView(viewRoot.element);
                viewRoot.elementDescription = current.elementDescription;
                viewRoot.isViewRoot = true;
                current.inheritedProtoView = viewRoot.inheritedProtoView;
                current.inheritedElementBinder = null;
                current.distanceToInheritedBinder = 0;
                this._parseTemplateBindings(templateBindings, anchor);
                DOM.insertBefore(current.element, anchor.element);
                control.addParent(anchor);
                DOM.appendChild(DOM.content(viewRoot.element), current.element);
                control.addParent(viewRoot);
              }
            }
          },
          _moveChildNodes: function(source, target) {
            var next = DOM.firstChild(source);
            while (isPresent(next)) {
              DOM.appendChild(target, next);
              next = DOM.firstChild(source);
            }
          },
          _parseTemplateBindings: function(templateBindings, compileElement) {
            var bindings = this._parser.parseTemplateBindings(templateBindings, compileElement.elementDescription);
            for (var i = 0; i < bindings.length; i++) {
              var binding = bindings[i];
              if (binding.keyIsVar) {
                compileElement.bindElement().bindVariable(dashCaseToCamelCase(binding.key), binding.name);
                compileElement.attrs().set(binding.key, binding.name);
              } else if (isPresent(binding.expression)) {
                compileElement.bindElement().bindProperty(dashCaseToCamelCase(binding.key), binding.expression);
                compileElement.attrs().set(binding.key, binding.expression.source);
              } else {
                DOM.setAttribute(compileElement.element, binding.key, '');
              }
            }
          }
        }, {});
      }());
      $__export("ViewSplitter", ViewSplitter);
    }
  };
});

System.register("angular2/src/render/dom/compiler/shadow_css", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/shadow_css";
  var DOM,
      ListWrapper,
      StringWrapper,
      RegExpWrapper,
      RegExpMatcherWrapper,
      isPresent,
      isBlank,
      ShadowCss,
      _cssContentNextSelectorRe,
      _cssContentRuleRe,
      _cssContentUnscopedRuleRe,
      _polyfillHost,
      _polyfillHostContext,
      _parenSuffix,
      _cssColonHostRe,
      _cssColonHostContextRe,
      _polyfillHostNoCombinator,
      _shadowDOMSelectorsRe,
      _selectorReSuffix,
      _polyfillHostRe,
      _colonHostRe,
      _colonHostContextRe;
  function _cssToRules(cssText) {
    return DOM.cssToRules(cssText);
  }
  function _withCssRules(cssText, callback) {
    if (isBlank(callback))
      return ;
    var rules = _cssToRules(cssText);
    callback(rules);
  }
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      RegExpWrapper = $__m.RegExpWrapper;
      RegExpMatcherWrapper = $__m.RegExpMatcherWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      ShadowCss = (function() {
        function ShadowCss() {
          this.strictStyling = true;
        }
        return ($traceurRuntime.createClass)(ShadowCss, {
          shimStyle: function(style, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            var cssText = DOM.getText(style);
            return this.shimCssText(cssText, selector, hostSelector);
          },
          shimCssText: function(cssText, selector) {
            var hostSelector = arguments[2] !== (void 0) ? arguments[2] : '';
            cssText = this._insertDirectives(cssText);
            return this._scopeCssText(cssText, selector, hostSelector);
          },
          _insertDirectives: function(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
          },
          _insertPolyfillDirectivesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function(m) {
              return m[1] + '{';
            });
          },
          _insertPolyfillRulesInCssText: function(cssText) {
            return StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function(m) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[1], '');
              rule = StringWrapper.replace(rule, m[2], '');
              return m[3] + rule;
            });
          },
          _scopeCssText: function(cssText, scopeSelector, hostSelector) {
            var $__0 = this;
            var unscoped = this._extractUnscopedRulesFromCssText(cssText);
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (isPresent(scopeSelector)) {
              _withCssRules(cssText, (function(rules) {
                cssText = $__0._scopeRules(rules, scopeSelector, hostSelector);
              }));
            }
            cssText = cssText + '\n' + unscoped;
            return cssText.trim();
          },
          _extractUnscopedRulesFromCssText: function(cssText) {
            var r = '',
                m;
            var matcher = RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
            while (isPresent(m = RegExpMatcherWrapper.next(matcher))) {
              var rule = m[0];
              rule = StringWrapper.replace(rule, m[2], '');
              rule = StringWrapper.replace(rule, m[1], m[3]);
              r += rule + '\n\n';
            }
            return r;
          },
          _convertColonHost: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
          },
          _convertColonHostContext: function(cssText) {
            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
          },
          _convertColonRule: function(cssText, regExp, partReplacer) {
            return StringWrapper.replaceAllMapped(cssText, regExp, function(m) {
              if (isPresent(m[2])) {
                var parts = m[2].split(','),
                    r = [];
                for (var i = 0; i < parts.length; i++) {
                  var p = parts[i];
                  if (isBlank(p))
                    break;
                  p = p.trim();
                  r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                }
                return r.join(',');
              } else {
                return _polyfillHostNoCombinator + m[3];
              }
            });
          },
          _colonHostContextPartReplacer: function(host, part, suffix) {
            if (StringWrapper.contains(part, _polyfillHost)) {
              return this._colonHostPartReplacer(host, part, suffix);
            } else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
            }
          },
          _colonHostPartReplacer: function(host, part, suffix) {
            return host + StringWrapper.replace(part, _polyfillHost, '') + suffix;
          },
          _convertShadowDOMSelectors: function(cssText) {
            for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
              cssText = StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
            }
            return cssText;
          },
          _scopeRules: function(cssRules, scopeSelector, hostSelector) {
            var cssText = '';
            if (isPresent(cssRules)) {
              for (var i = 0; i < cssRules.length; i++) {
                var rule = cssRules[i];
                if (DOM.isStyleRule(rule) || DOM.isPageRule(rule)) {
                  cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) + ' {\n';
                  cssText += this._propertiesFromRule(rule) + '\n}\n\n';
                } else if (DOM.isMediaRule(rule)) {
                  cssText += '@media ' + rule.media.mediaText + ' {\n';
                  cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
                  cssText += '\n}\n\n';
                } else {
                  try {
                    if (isPresent(rule.cssText)) {
                      cssText += rule.cssText + '\n\n';
                    }
                  } catch (x) {
                    if (DOM.isKeyframesRule(rule) && isPresent(rule.cssRules)) {
                      cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
                    }
                  }
                }
              }
            }
            return cssText;
          },
          _ieSafeCssTextFromKeyFrameRule: function(rule) {
            var cssText = '@keyframes ' + rule.name + ' {';
            for (var i = 0; i < rule.cssRules.length; i++) {
              var r = rule.cssRules[i];
              cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
            }
            cssText += ' }';
            return cssText;
          },
          _scopeSelector: function(selector, scopeSelector, hostSelector, strict) {
            var r = [],
                parts = selector.split(',');
            for (var i = 0; i < parts.length; i++) {
              var p = parts[i];
              p = p.trim();
              if (this._selectorNeedsScoping(p, scopeSelector)) {
                p = strict && !StringWrapper.contains(p, _polyfillHostNoCombinator) ? this._applyStrictSelectorScope(p, scopeSelector) : this._applySelectorScope(p, scopeSelector, hostSelector);
              }
              r.push(p);
            }
            return r.join(', ');
          },
          _selectorNeedsScoping: function(selector, scopeSelector) {
            var re = this._makeScopeMatcher(scopeSelector);
            return !isPresent(RegExpWrapper.firstMatch(re, selector));
          },
          _makeScopeMatcher: function(scopeSelector) {
            var lre = /\[/g;
            var rre = /\]/g;
            scopeSelector = StringWrapper.replaceAll(scopeSelector, lre, '\\[');
            scopeSelector = StringWrapper.replaceAll(scopeSelector, rre, '\\]');
            return RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
          },
          _applySelectorScope: function(selector, scopeSelector, hostSelector) {
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
          },
          _applySimpleSelectorScope: function(selector, scopeSelector, hostSelector) {
            if (isPresent(RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
              var replaceBy = this.strictStyling ? ("[" + hostSelector + "]") : scopeSelector;
              selector = StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
              return StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
            } else {
              return scopeSelector + ' ' + selector;
            }
          },
          _applyStrictSelectorScope: function(selector, scopeSelector) {
            var isRe = /\[is=([^\]]*)\]/g;
            scopeSelector = StringWrapper.replaceAllMapped(scopeSelector, isRe, (function(m) {
              return m[1];
            }));
            var splits = [' ', '>', '+', '~'],
                scoped = selector,
                attrName = '[' + scopeSelector + ']';
            for (var i = 0; i < splits.length; i++) {
              var sep = splits[i];
              var parts = scoped.split(sep);
              scoped = ListWrapper.map(parts, function(p) {
                var t = StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
                if (t.length > 0 && !ListWrapper.contains(splits, t) && !StringWrapper.contains(t, attrName)) {
                  var re = /([^:]*)(:*)(.*)/g;
                  var m = RegExpWrapper.firstMatch(re, t);
                  if (isPresent(m)) {
                    p = m[1] + attrName + m[2] + m[3];
                  }
                }
                return p;
              }).join(sep);
            }
            return scoped;
          },
          _insertPolyfillHostInCssText: function(selector) {
            selector = StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
            selector = StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
            return selector;
          },
          _propertiesFromRule: function(rule) {
            var cssText = rule.style.cssText;
            var attrRe = /['"]+|attr/g;
            if (rule.style.content.length > 0 && !isPresent(RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
              var contentRe = /content:[^;]*;/g;
              cssText = StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
            }
            return cssText;
          }
        }, {});
      }());
      $__export("ShadowCss", ShadowCss);
      _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
      _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
      _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
      _polyfillHost = '-shadowcsshost';
      _polyfillHostContext = '-shadowcsscontext';
      _parenSuffix = ')(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';
      _cssColonHostRe = RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
      _cssColonHostContextRe = RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
      _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
      _shadowDOMSelectorsRe = [/>>>/g, /::shadow/g, /::content/g, /\/deep\//g, /\/shadow-deep\//g, /\/shadow\//g];
      _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
      _polyfillHostRe = RegExpWrapper.create(_polyfillHost, 'im');
      _colonHostRe = /:host/gim;
      _colonHostContextRe = /:host-context/gim;
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view_merger", ["angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/element_binder", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view_merger";
  var DOM,
      isPresent,
      isBlank,
      isArray,
      ListWrapper,
      SetWrapper,
      MapWrapper,
      DomProtoView,
      DomProtoViewRef,
      resolveInternalDomProtoView,
      DomElementBinder,
      RenderProtoViewMergeMapping,
      ViewType,
      ViewEncapsulation,
      NG_BINDING_CLASS,
      NG_CONTENT_ELEMENT_NAME,
      cloneAndQueryProtoView,
      queryBoundElements,
      queryBoundTextNodeIndices,
      NG_SHADOW_ROOT_ELEMENT_NAME;
  function mergeProtoViewsRecursively(protoViewRefs) {
    var clonedProtoViews = [];
    var hostViewAndBinderIndices = [];
    cloneProtoViews(protoViewRefs, clonedProtoViews, hostViewAndBinderIndices);
    var mainProtoView = clonedProtoViews[0];
    mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices);
    var fragments = [];
    var elementsWithNativeShadowRoot = new Set();
    mergeComponents(clonedProtoViews, hostViewAndBinderIndices, fragments, elementsWithNativeShadowRoot);
    markBoundTextNodeParentsAsBoundElements(clonedProtoViews);
    var rootElement = createRootElementFromFragments(fragments);
    var fragmentsRootNodeCount = fragments.map((function(fragment) {
      return fragment.length;
    }));
    var rootNode = DOM.content(rootElement);
    var mergedBoundElements = queryBoundElements(rootNode, false);
    var mergedBoundTextIndices = new Map();
    var boundTextNodeMap = indexBoundTextNodes(clonedProtoViews);
    var rootTextNodeIndices = calcRootTextNodeIndices(rootNode, boundTextNodeMap, mergedBoundTextIndices);
    var mergedElementBinders = calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodeMap, mergedBoundTextIndices);
    var mappedElementIndices = calcMappedElementIndices(clonedProtoViews, mergedBoundElements);
    var mappedTextIndices = calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices);
    var hostElementIndicesByViewIndex = calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices);
    var nestedViewCounts = calcNestedViewCounts(hostViewAndBinderIndices);
    var mergedProtoView = DomProtoView.create(mainProtoView.original.type, rootElement, mainProtoView.original.encapsulation, fragmentsRootNodeCount, rootTextNodeIndices, mergedElementBinders, new Map());
    return new RenderProtoViewMergeMapping(new DomProtoViewRef(mergedProtoView), fragmentsRootNodeCount.length, mappedElementIndices, mergedBoundElements.length, mappedTextIndices, hostElementIndicesByViewIndex, nestedViewCounts);
  }
  function cloneProtoViews(protoViewRefs, targetClonedProtoViews, targetHostViewAndBinderIndices) {
    var hostProtoView = resolveInternalDomProtoView(protoViewRefs[0]);
    var hostPvIdx = targetClonedProtoViews.length;
    targetClonedProtoViews.push(cloneAndQueryProtoView(hostProtoView, false));
    if (targetHostViewAndBinderIndices.length === 0) {
      targetHostViewAndBinderIndices.push([null, null]);
    }
    var protoViewIdx = 1;
    for (var i = 0; i < hostProtoView.elementBinders.length; i++) {
      var binder = hostProtoView.elementBinders[i];
      if (binder.hasNestedProtoView) {
        var nestedEntry = protoViewRefs[protoViewIdx++];
        if (isPresent(nestedEntry)) {
          targetHostViewAndBinderIndices.push([hostPvIdx, i]);
          if (isArray(nestedEntry)) {
            cloneProtoViews(nestedEntry, targetClonedProtoViews, targetHostViewAndBinderIndices);
          } else {
            targetClonedProtoViews.push(cloneAndQueryProtoView(resolveInternalDomProtoView(nestedEntry), false));
          }
        }
      }
    }
  }
  function markBoundTextNodeParentsAsBoundElements(mergableProtoViews) {
    mergableProtoViews.forEach((function(mergableProtoView) {
      mergableProtoView.boundTextNodes.forEach((function(textNode) {
        var parentNode = textNode.parentNode;
        if (isPresent(parentNode) && DOM.isElementNode(parentNode)) {
          DOM.addClass(parentNode, NG_BINDING_CLASS);
        }
      }));
    }));
  }
  function indexBoundTextNodes(mergableProtoViews) {
    var boundTextNodeMap = new Map();
    for (var pvIndex = 0; pvIndex < mergableProtoViews.length; pvIndex++) {
      var mergableProtoView = mergableProtoViews[pvIndex];
      mergableProtoView.boundTextNodes.forEach((function(textNode) {
        boundTextNodeMap.set(textNode, null);
      }));
    }
    return boundTextNodeMap;
  }
  function mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices) {
    var nearestHostComponentOrRootPvIndices = calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices);
    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
      var clonedProtoView = clonedProtoViews[viewIdx];
      if (clonedProtoView.original.type === ViewType.EMBEDDED) {
        var hostComponentIdx = nearestHostComponentOrRootPvIndices[viewIdx];
        var hostPv = clonedProtoViews[hostComponentIdx];
        clonedProtoView.fragments.forEach((function(fragment) {
          return hostPv.fragments.push(fragment);
        }));
      }
    }
  }
  function calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices) {
    var nearestHostComponentOrRootPvIndices = ListWrapper.createFixedSize(clonedProtoViews.length);
    nearestHostComponentOrRootPvIndices[0] = null;
    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostProtoView = clonedProtoViews[hostViewIdx];
      if (hostViewIdx === 0 || hostProtoView.original.type === ViewType.COMPONENT) {
        nearestHostComponentOrRootPvIndices[viewIdx] = hostViewIdx;
      } else {
        nearestHostComponentOrRootPvIndices[viewIdx] = nearestHostComponentOrRootPvIndices[hostViewIdx];
      }
    }
    return nearestHostComponentOrRootPvIndices;
  }
  function mergeComponents(clonedProtoViews, hostViewAndBinderIndices, targetFragments, targetElementsWithNativeShadowRoot) {
    var hostProtoView = clonedProtoViews[0];
    hostProtoView.fragments.forEach((function(fragment) {
      return targetFragments.push(fragment);
    }));
    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
      var hostProtoView = clonedProtoViews[hostViewIdx];
      var clonedProtoView = clonedProtoViews[viewIdx];
      if (clonedProtoView.original.type === ViewType.COMPONENT) {
        mergeComponent(hostProtoView, hostBinderIdx, clonedProtoView, targetFragments, targetElementsWithNativeShadowRoot);
      }
    }
  }
  function mergeComponent(hostProtoView, binderIdx, nestedProtoView, targetFragments, targetElementsWithNativeShadowRoot) {
    var hostElement = hostProtoView.boundElements[binderIdx];
    var fragmentElements = mapFragmentsIntoElements(nestedProtoView.fragments);
    var contentElements = findContentElements(fragmentElements);
    var projectableNodes = DOM.childNodesAsList(hostElement);
    for (var i = 0; i < contentElements.length; i++) {
      var contentElement = contentElements[i];
      var select = DOM.getAttribute(contentElement, 'select');
      projectableNodes = projectMatchingNodes(select, contentElement, projectableNodes);
    }
    var fragments = extractFragmentNodesFromElements(fragmentElements);
    var useNativeShadowRoot = nestedProtoView.original.encapsulation === ViewEncapsulation.NATIVE;
    if (useNativeShadowRoot) {
      targetElementsWithNativeShadowRoot.add(hostElement);
    }
    MapWrapper.forEach(nestedProtoView.original.hostAttributes, (function(attrValue, attrName) {
      DOM.setAttribute(hostElement, attrName, attrValue);
    }));
    appendComponentNodesToHost(hostProtoView, binderIdx, fragments[0], useNativeShadowRoot);
    for (var i = 1; i < fragments.length; i++) {
      targetFragments.push(fragments[i]);
    }
  }
  function mapFragmentsIntoElements(fragments) {
    return fragments.map((function(fragment) {
      var fragmentElement = DOM.createTemplate('');
      fragment.forEach((function(node) {
        return DOM.appendChild(DOM.content(fragmentElement), node);
      }));
      return fragmentElement;
    }));
  }
  function extractFragmentNodesFromElements(fragmentElements) {
    return fragmentElements.map((function(fragmentElement) {
      return DOM.childNodesAsList(DOM.content(fragmentElement));
    }));
  }
  function findContentElements(fragmentElements) {
    var contentElements = [];
    fragmentElements.forEach((function(fragmentElement) {
      var fragmentContentElements = DOM.querySelectorAll(DOM.content(fragmentElement), NG_CONTENT_ELEMENT_NAME);
      for (var i = 0; i < fragmentContentElements.length; i++) {
        contentElements.push(fragmentContentElements[i]);
      }
    }));
    return sortContentElements(contentElements);
  }
  function appendComponentNodesToHost(hostProtoView, binderIdx, componentRootNodes, useNativeShadowRoot) {
    var hostElement = hostProtoView.boundElements[binderIdx];
    if (useNativeShadowRoot) {
      var shadowRootWrapper = DOM.createElement(NG_SHADOW_ROOT_ELEMENT_NAME);
      for (var i = 0; i < componentRootNodes.length; i++) {
        DOM.appendChild(shadowRootWrapper, componentRootNodes[i]);
      }
      var firstChild = DOM.firstChild(hostElement);
      if (isPresent(firstChild)) {
        DOM.insertBefore(firstChild, shadowRootWrapper);
      } else {
        DOM.appendChild(hostElement, shadowRootWrapper);
      }
    } else {
      DOM.clearNodes(hostElement);
      for (var i = 0; i < componentRootNodes.length; i++) {
        DOM.appendChild(hostElement, componentRootNodes[i]);
      }
    }
  }
  function projectMatchingNodes(selector, contentElement, nodes) {
    var remaining = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var matches = false;
      if (isWildcard(selector)) {
        matches = true;
      } else if (DOM.isElementNode(node) && DOM.elementMatches(node, selector)) {
        matches = true;
      }
      if (matches) {
        DOM.insertBefore(contentElement, node);
      } else {
        remaining.push(node);
      }
    }
    DOM.remove(contentElement);
    return remaining;
  }
  function isWildcard(selector) {
    return isBlank(selector) || selector.length === 0 || selector == '*';
  }
  function sortContentElements(contentElements) {
    var firstWildcard = null;
    var sorted = [];
    contentElements.forEach((function(contentElement) {
      var select = DOM.getAttribute(contentElement, 'select');
      if (isWildcard(select)) {
        if (isBlank(firstWildcard)) {
          firstWildcard = contentElement;
        }
      } else {
        sorted.push(contentElement);
      }
    }));
    if (isPresent(firstWildcard)) {
      sorted.push(firstWildcard);
    }
    return sorted;
  }
  function createRootElementFromFragments(fragments) {
    var rootElement = DOM.createTemplate('');
    var rootNode = DOM.content(rootElement);
    fragments.forEach((function(fragment) {
      fragment.forEach((function(node) {
        DOM.appendChild(rootNode, node);
      }));
    }));
    return rootElement;
  }
  function calcRootTextNodeIndices(rootNode, boundTextNodes, targetBoundTextIndices) {
    var rootTextNodeIndices = [];
    queryBoundTextNodeIndices(rootNode, boundTextNodes, (function(textNode, nodeIndex, _) {
      rootTextNodeIndices.push(nodeIndex);
      targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
    }));
    return rootTextNodeIndices;
  }
  function calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodes, targetBoundTextIndices) {
    var elementBinderByElement = indexElementBindersByElement(clonedProtoViews);
    var mergedElementBinders = [];
    for (var i = 0; i < mergedBoundElements.length; i++) {
      var element = mergedBoundElements[i];
      var textNodeIndices = [];
      queryBoundTextNodeIndices(element, boundTextNodes, (function(textNode, nodeIndex, _) {
        textNodeIndices.push(nodeIndex);
        targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
      }));
      mergedElementBinders.push(updateElementBinders(elementBinderByElement.get(element), textNodeIndices, SetWrapper.has(elementsWithNativeShadowRoot, element)));
    }
    return mergedElementBinders;
  }
  function indexElementBindersByElement(mergableProtoViews) {
    var elementBinderByElement = new Map();
    mergableProtoViews.forEach((function(mergableProtoView) {
      for (var i = 0; i < mergableProtoView.boundElements.length; i++) {
        var el = mergableProtoView.boundElements[i];
        if (isPresent(el)) {
          elementBinderByElement.set(el, mergableProtoView.original.elementBinders[i]);
        }
      }
    }));
    return elementBinderByElement;
  }
  function updateElementBinders(elementBinder, textNodeIndices, hasNativeShadowRoot) {
    var result;
    if (isBlank(elementBinder)) {
      result = new DomElementBinder({
        textNodeIndices: textNodeIndices,
        hasNestedProtoView: false,
        eventLocals: null,
        localEvents: [],
        globalEvents: [],
        hasNativeShadowRoot: false
      });
    } else {
      result = new DomElementBinder({
        textNodeIndices: textNodeIndices,
        hasNestedProtoView: false,
        eventLocals: elementBinder.eventLocals,
        localEvents: elementBinder.localEvents,
        globalEvents: elementBinder.globalEvents,
        hasNativeShadowRoot: hasNativeShadowRoot
      });
    }
    return result;
  }
  function calcMappedElementIndices(clonedProtoViews, mergedBoundElements) {
    var mergedBoundElementIndices = indexArray(mergedBoundElements);
    var mappedElementIndices = [];
    clonedProtoViews.forEach((function(clonedProtoView) {
      clonedProtoView.boundElements.forEach((function(boundElement) {
        var mappedElementIndex = mergedBoundElementIndices.get(boundElement);
        mappedElementIndices.push(mappedElementIndex);
      }));
    }));
    return mappedElementIndices;
  }
  function calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices) {
    var mappedTextIndices = [];
    clonedProtoViews.forEach((function(clonedProtoView) {
      clonedProtoView.boundTextNodes.forEach((function(textNode) {
        var mappedTextIndex = mergedBoundTextIndices.get(textNode);
        mappedTextIndices.push(mappedTextIndex);
      }));
    }));
    return mappedTextIndices;
  }
  function calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices) {
    var hostElementIndices = [null];
    var viewElementOffsets = [0];
    var elementIndex = clonedProtoViews[0].original.elementBinders.length;
    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
      viewElementOffsets.push(elementIndex);
      elementIndex += clonedProtoViews[viewIdx].original.elementBinders.length;
      var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
      var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
      hostElementIndices.push(viewElementOffsets[hostViewIdx] + hostBinderIdx);
    }
    return hostElementIndices;
  }
  function calcNestedViewCounts(hostViewAndBinderIndices) {
    var nestedViewCounts = ListWrapper.createFixedSize(hostViewAndBinderIndices.length);
    ListWrapper.fill(nestedViewCounts, 0);
    for (var viewIdx = hostViewAndBinderIndices.length - 1; viewIdx >= 1; viewIdx--) {
      var hostViewAndElementIdx = hostViewAndBinderIndices[viewIdx];
      if (isPresent(hostViewAndElementIdx)) {
        nestedViewCounts[hostViewAndElementIdx[0]] += nestedViewCounts[viewIdx] + 1;
      }
    }
    return nestedViewCounts;
  }
  function indexArray(arr) {
    var map = new Map();
    for (var i = 0; i < arr.length; i++) {
      map.set(arr[i], i);
    }
    return map;
  }
  $__export("mergeProtoViewsRecursively", mergeProtoViewsRecursively);
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      isArray = $__m.isArray;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      SetWrapper = $__m.SetWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DomProtoView = $__m.DomProtoView;
      DomProtoViewRef = $__m.DomProtoViewRef;
      resolveInternalDomProtoView = $__m.resolveInternalDomProtoView;
    }, function($__m) {
      DomElementBinder = $__m.DomElementBinder;
    }, function($__m) {
      RenderProtoViewMergeMapping = $__m.RenderProtoViewMergeMapping;
      ViewType = $__m.ViewType;
      ViewEncapsulation = $__m.ViewEncapsulation;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
      NG_CONTENT_ELEMENT_NAME = $__m.NG_CONTENT_ELEMENT_NAME;
      cloneAndQueryProtoView = $__m.cloneAndQueryProtoView;
      queryBoundElements = $__m.queryBoundElements;
      queryBoundTextNodeIndices = $__m.queryBoundTextNodeIndices;
      NG_SHADOW_ROOT_ELEMENT_NAME = $__m.NG_SHADOW_ROOT_ELEMENT_NAME;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/render/dom/view/view", ["angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/view";
  var DOM,
      Map,
      isPresent,
      stringify,
      RenderViewRef,
      camelCaseToDashCase,
      DomViewRef,
      DomView;
  function resolveInternalDomView(viewRef) {
    return viewRef._view;
  }
  $__export("resolveInternalDomView", resolveInternalDomView);
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      isPresent = $__m.isPresent;
      stringify = $__m.stringify;
    }, function($__m) {
      RenderViewRef = $__m.RenderViewRef;
    }, function($__m) {
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      DomViewRef = (function($__super) {
        function DomViewRef(_view) {
          $traceurRuntime.superConstructor(DomViewRef).call(this);
          this._view = _view;
        }
        return ($traceurRuntime.createClass)(DomViewRef, {}, {}, $__super);
      }(RenderViewRef));
      $__export("DomViewRef", DomViewRef);
      DomView = (function() {
        function DomView(proto, boundTextNodes, boundElements) {
          this.proto = proto;
          this.boundTextNodes = boundTextNodes;
          this.boundElements = boundElements;
          this.hydrated = false;
          this.eventDispatcher = null;
          this.eventHandlerRemovers = [];
        }
        return ($traceurRuntime.createClass)(DomView, {
          setElementProperty: function(elementIndex, propertyName, value) {
            DOM.setProperty(this.boundElements[elementIndex], propertyName, value);
          },
          setElementAttribute: function(elementIndex, attributeName, value) {
            var element = this.boundElements[elementIndex];
            var dashCasedAttributeName = camelCaseToDashCase(attributeName);
            if (isPresent(value)) {
              DOM.setAttribute(element, dashCasedAttributeName, stringify(value));
            } else {
              DOM.removeAttribute(element, dashCasedAttributeName);
            }
          },
          setElementClass: function(elementIndex, className, isAdd) {
            var element = this.boundElements[elementIndex];
            if (isAdd) {
              DOM.addClass(element, className);
            } else {
              DOM.removeClass(element, className);
            }
          },
          setElementStyle: function(elementIndex, styleName, value) {
            var element = this.boundElements[elementIndex];
            var dashCasedStyleName = camelCaseToDashCase(styleName);
            if (isPresent(value)) {
              DOM.setStyle(element, dashCasedStyleName, stringify(value));
            } else {
              DOM.removeStyle(element, dashCasedStyleName);
            }
          },
          invokeElementMethod: function(elementIndex, methodName, args) {
            var element = this.boundElements[elementIndex];
            DOM.invoke(element, methodName, args);
          },
          setText: function(textIndex, value) {
            DOM.setText(this.boundTextNodes[textIndex], value);
          },
          dispatchEvent: function(elementIndex, eventName, event) {
            var allowDefaultBehavior = true;
            if (isPresent(this.eventDispatcher)) {
              var evalLocals = new Map();
              evalLocals.set('$event', event);
              allowDefaultBehavior = this.eventDispatcher.dispatchRenderEvent(elementIndex, eventName, evalLocals);
              if (!allowDefaultBehavior) {
                event.preventDefault();
              }
            }
            return allowDefaultBehavior;
          }
        }, {});
      }());
      $__export("DomView", DomView);
    }
  };
});

System.register("angular2/src/render/dom/view/fragment", ["angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/fragment";
  var RenderFragmentRef,
      DomFragmentRef;
  function resolveInternalDomFragment(fragmentRef) {
    return fragmentRef._nodes;
  }
  $__export("resolveInternalDomFragment", resolveInternalDomFragment);
  return {
    setters: [function($__m) {
      RenderFragmentRef = $__m.RenderFragmentRef;
    }],
    execute: function() {
      DomFragmentRef = (function($__super) {
        function DomFragmentRef(_nodes) {
          $traceurRuntime.superConstructor(DomFragmentRef).call(this);
          this._nodes = _nodes;
        }
        return ($traceurRuntime.createClass)(DomFragmentRef, {}, {}, $__super);
      }(RenderFragmentRef));
      $__export("DomFragmentRef", DomFragmentRef);
    }
  };
});

System.register("angular2/src/core/application_tokens", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_tokens";
  var OpaqueToken,
      CONST_EXPR,
      appComponentRefPromiseToken,
      appComponentTypeToken;
  return {
    setters: [function($__m) {
      OpaqueToken = $__m.OpaqueToken;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      appComponentRefPromiseToken = CONST_EXPR(new OpaqueToken('Promise<ComponentRef>'));
      $__export("appComponentRefPromiseToken", appComponentRefPromiseToken);
      appComponentTypeToken = CONST_EXPR(new OpaqueToken('RootComponent'));
      $__export("appComponentTypeToken", appComponentTypeToken);
    }
  };
});

System.register("angular2/src/core/annotations/annotations", ["angular2/src/core/annotations_impl/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/annotations";
  return {
    setters: [function($__m) {
      $__export("ComponentAnnotation", $__m.Component);
      $__export("DirectiveAnnotation", $__m.Directive);
      $__export("LifecycleEvent", $__m.LifecycleEvent);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/annotations/view", ["angular2/src/core/annotations_impl/view"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/view";
  return {
    setters: [function($__m) {
      $__export("ViewAnnotation", $__m.View);
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/annotations/di", ["angular2/src/core/annotations_impl/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/di";
  return {
    setters: [function($__m) {
      $__export("QueryAnnotation", $__m.Query);
      $__export("ViewQueryAnnotation", $__m.ViewQuery);
      $__export("AttributeAnnotation", $__m.Attribute);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/annotations/decorators", ["angular2/src/core/annotations/annotations", "angular2/src/core/annotations/view", "angular2/src/core/annotations/di", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations/decorators";
  var ComponentAnnotation,
      DirectiveAnnotation,
      ViewAnnotation,
      AttributeAnnotation,
      QueryAnnotation,
      ViewQueryAnnotation,
      makeDecorator,
      makeParamDecorator,
      Component,
      Directive,
      View,
      Attribute,
      Query,
      ViewQuery;
  return {
    setters: [function($__m) {
      ComponentAnnotation = $__m.ComponentAnnotation;
      DirectiveAnnotation = $__m.DirectiveAnnotation;
    }, function($__m) {
      ViewAnnotation = $__m.ViewAnnotation;
    }, function($__m) {
      AttributeAnnotation = $__m.AttributeAnnotation;
      QueryAnnotation = $__m.QueryAnnotation;
      ViewQueryAnnotation = $__m.ViewQueryAnnotation;
    }, function($__m) {
      makeDecorator = $__m.makeDecorator;
      makeParamDecorator = $__m.makeParamDecorator;
    }],
    execute: function() {
      Component = makeDecorator(ComponentAnnotation, (function(fn) {
        return fn.View = View;
      }));
      $__export("Component", Component);
      Directive = makeDecorator(DirectiveAnnotation);
      $__export("Directive", Directive);
      View = makeDecorator(ViewAnnotation, (function(fn) {
        return fn.View = View;
      }));
      $__export("View", View);
      Attribute = makeParamDecorator(AttributeAnnotation);
      $__export("Attribute", Attribute);
      Query = makeParamDecorator(QueryAnnotation);
      $__export("Query", Query);
      ViewQuery = makeParamDecorator(ViewQueryAnnotation);
      $__export("ViewQuery", ViewQuery);
    }
  };
});

System.register("angular2/core", ["angular2/src/core/application_tokens", "angular2/src/core/application_common", "angular2/src/services/app_root_url", "angular2/src/services/url_resolver", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/compiler", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/query_list", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/zone/ng_zone", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/core";
  return {
    setters: [function($__m) {
      $__export("appComponentTypeToken", $__m.appComponentTypeToken);
    }, function($__m) {
      $__export("ApplicationRef", $__m.ApplicationRef);
    }, function($__m) {
      $__export("AppRootUrl", $__m.AppRootUrl);
    }, function($__m) {
      $__export("UrlResolver", $__m.UrlResolver);
    }, function($__m) {
      $__export("ComponentUrlMapper", $__m.ComponentUrlMapper);
    }, function($__m) {
      $__export("DirectiveResolver", $__m.DirectiveResolver);
    }, function($__m) {
      $__export("Compiler", $__m.Compiler);
    }, function($__m) {
      $__export("AppViewManager", $__m.AppViewManager);
    }, function($__m) {
      $__export("QueryList", $__m.QueryList);
    }, function($__m) {
      $__export("DynamicComponentLoader", $__m.DynamicComponentLoader);
      $__export("ComponentRef", $__m.ComponentRef);
    }, function($__m) {
      $__export("ElementRef", $__m.ElementRef);
    }, function($__m) {
      $__export("TemplateRef", $__m.TemplateRef);
    }, function($__m) {
      $__export("ViewRef", $__m.ViewRef);
      $__export("ProtoViewRef", $__m.ProtoViewRef);
    }, function($__m) {
      $__export("ViewContainerRef", $__m.ViewContainerRef);
    }, function($__m) {
      $__export("NgZone", $__m.NgZone);
    }, function($__m) {
      $__export("Observable", $__m.Observable);
      $__export("EventEmitter", $__m.EventEmitter);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/directives/ng_for", ["angular2/annotations", "angular2/core", "angular2/change_detection", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_for";
  var __decorate,
      __metadata,
      Directive,
      LifecycleEvent,
      ViewContainerRef,
      TemplateRef,
      ChangeDetectorRef,
      Pipes,
      isPresent,
      isBlank,
      NgFor,
      RecordViewTuple;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
      Pipes = $__m.Pipes;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgFor = (($traceurRuntime.createClass)(function(viewContainer, templateRef, pipes, cdr) {
        this.viewContainer = viewContainer;
        this.templateRef = templateRef;
        this.pipes = pipes;
        this.cdr = cdr;
      }, {
        set ngForOf(value) {
          this._ngForOf = value;
          this._pipe = this.pipes.get("iterableDiff", value, this.cdr, this._pipe);
        },
        onCheck: function() {
          var diff = this._pipe.transform(this._ngForOf, null);
          if (isPresent(diff))
            this._applyChanges(diff.wrapped);
        },
        _applyChanges: function(changes) {
          if (isBlank(changes)) {
            this.viewContainer.clear();
            return ;
          }
          var recordViewTuples = [];
          changes.forEachRemovedItem((function(removedRecord) {
            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
          }));
          changes.forEachMovedItem((function(movedRecord) {
            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
          }));
          var insertTuples = NgFor.bulkRemove(recordViewTuples, this.viewContainer);
          changes.forEachAddedItem((function(addedRecord) {
            return insertTuples.push(new RecordViewTuple(addedRecord, null));
          }));
          NgFor.bulkInsert(insertTuples, this.viewContainer, this.templateRef);
          for (var i = 0; i < insertTuples.length; i++) {
            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
          }
        },
        _perViewChange: function(view, record) {
          view.setLocal('\$implicit', record.item);
          view.setLocal('index', record.currentIndex);
        }
      }, {
        bulkRemove: function(tuples, viewContainer) {
          tuples.sort((function(a, b) {
            return a.record.previousIndex - b.record.previousIndex;
          }));
          var movedTuples = [];
          for (var i = tuples.length - 1; i >= 0; i--) {
            var tuple = tuples[i];
            if (isPresent(tuple.record.currentIndex)) {
              tuple.view = viewContainer.detach(tuple.record.previousIndex);
              movedTuples.push(tuple);
            } else {
              viewContainer.remove(tuple.record.previousIndex);
            }
          }
          return movedTuples;
        },
        bulkInsert: function(tuples, viewContainer, templateRef) {
          tuples.sort((function(a, b) {
            return a.record.currentIndex - b.record.currentIndex;
          }));
          for (var i = 0; i < tuples.length; i++) {
            var tuple = tuples[i];
            if (isPresent(tuple.view)) {
              viewContainer.insert(tuple.view, tuple.record.currentIndex);
            } else {
              tuple.view = viewContainer.createEmbeddedView(templateRef, tuple.record.currentIndex);
            }
          }
          return tuples;
        }
      }));
      $__export("NgFor", NgFor);
      $__export("NgFor", NgFor = __decorate([Directive({
        selector: '[ng-for][ng-for-of]',
        properties: ['ngForOf'],
        lifecycle: [LifecycleEvent.onCheck]
      }), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, Pipes, ChangeDetectorRef])], NgFor));
      RecordViewTuple = (function() {
        function RecordViewTuple(record, view) {
          this.record = record;
          this.view = view;
        }
        return ($traceurRuntime.createClass)(RecordViewTuple, {}, {});
      }());
      $__export("RecordViewTuple", RecordViewTuple);
    }
  };
});

System.register("angular2/src/directives/ng_if", ["angular2/annotations", "angular2/core", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_if";
  var __decorate,
      __metadata,
      Directive,
      ViewContainerRef,
      TemplateRef,
      isBlank,
      NgIf;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgIf = (($traceurRuntime.createClass)(function(viewContainer, templateRef) {
        this.viewContainer = viewContainer;
        this.prevCondition = null;
        this.templateRef = templateRef;
      }, {set ngIf(newCondition) {
          if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
            this.prevCondition = true;
            this.viewContainer.createEmbeddedView(this.templateRef);
          } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
            this.prevCondition = false;
            this.viewContainer.clear();
          }
        }}, {}));
      $__export("NgIf", NgIf);
      $__export("NgIf", NgIf = __decorate([Directive({
        selector: '[ng-if]',
        properties: ['ngIf']
      }), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef])], NgIf));
    }
  };
});

System.register("angular2/src/directives/ng_non_bindable", ["angular2/annotations"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_non_bindable";
  var __decorate,
      __metadata,
      Directive,
      NgNonBindable;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgNonBindable = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("NgNonBindable", NgNonBindable);
      $__export("NgNonBindable", NgNonBindable = __decorate([Directive({
        selector: '[ng-non-bindable]',
        compileChildren: false
      }), __metadata('design:paramtypes', [])], NgNonBindable));
    }
  };
});

System.register("angular2/src/directives/ng_switch", ["angular2/annotations", "angular2/di", "angular2/core", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_switch";
  var __decorate,
      __metadata,
      __param,
      Directive,
      Ancestor,
      ViewContainerRef,
      TemplateRef,
      isPresent,
      isBlank,
      normalizeBlank,
      ListWrapper,
      MapWrapper,
      Map,
      SwitchView,
      NgSwitch,
      NgSwitchWhen,
      NgSwitchDefault,
      _whenDefault;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Ancestor = $__m.Ancestor;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      normalizeBlank = $__m.normalizeBlank;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      SwitchView = (function() {
        function SwitchView(viewContainerRef, templateRef) {
          this._templateRef = templateRef;
          this._viewContainerRef = viewContainerRef;
        }
        return ($traceurRuntime.createClass)(SwitchView, {
          create: function() {
            this._viewContainerRef.createEmbeddedView(this._templateRef);
          },
          destroy: function() {
            this._viewContainerRef.clear();
          }
        }, {});
      }());
      $__export("SwitchView", SwitchView);
      NgSwitch = (($traceurRuntime.createClass)(function() {
        this._valueViews = new Map();
        this._activeViews = [];
        this._useDefault = false;
      }, {
        set ngSwitch(value) {
          this._emptyAllActiveViews();
          this._useDefault = false;
          var views = this._valueViews.get(value);
          if (isBlank(views)) {
            this._useDefault = true;
            views = normalizeBlank(this._valueViews.get(_whenDefault));
          }
          this._activateViews(views);
          this._switchValue = value;
        },
        _onWhenValueChanged: function(oldWhen, newWhen, view) {
          this._deregisterView(oldWhen, view);
          this._registerView(newWhen, view);
          if (oldWhen === this._switchValue) {
            view.destroy();
            ListWrapper.remove(this._activeViews, view);
          } else if (newWhen === this._switchValue) {
            if (this._useDefault) {
              this._useDefault = false;
              this._emptyAllActiveViews();
            }
            view.create();
            this._activeViews.push(view);
          }
          if (this._activeViews.length === 0 && !this._useDefault) {
            this._useDefault = true;
            this._activateViews(this._valueViews.get(_whenDefault));
          }
        },
        _emptyAllActiveViews: function() {
          var activeContainers = this._activeViews;
          for (var i = 0; i < activeContainers.length; i++) {
            activeContainers[i].destroy();
          }
          this._activeViews = [];
        },
        _activateViews: function(views) {
          if (isPresent(views)) {
            for (var i = 0; i < views.length; i++) {
              views[i].create();
            }
            this._activeViews = views;
          }
        },
        _registerView: function(value, view) {
          var views = this._valueViews.get(value);
          if (isBlank(views)) {
            views = [];
            this._valueViews.set(value, views);
          }
          views.push(view);
        },
        _deregisterView: function(value, view) {
          if (value == _whenDefault)
            return ;
          var views = this._valueViews.get(value);
          if (views.length == 1) {
            MapWrapper.delete(this._valueViews, value);
          } else {
            ListWrapper.remove(views, view);
          }
        }
      }, {}));
      $__export("NgSwitch", NgSwitch);
      $__export("NgSwitch", NgSwitch = __decorate([Directive({
        selector: '[ng-switch]',
        properties: ['ngSwitch']
      }), __metadata('design:paramtypes', [])], NgSwitch));
      NgSwitchWhen = (($traceurRuntime.createClass)(function(viewContainer, templateRef, sswitch) {
        this._value = _whenDefault;
        this._switch = sswitch;
        this._view = new SwitchView(viewContainer, templateRef);
      }, {
        onDestroy: function() {
          this._switch;
        },
        set ngSwitchWhen(value) {
          this._switch._onWhenValueChanged(this._value, value, this._view);
          this._value = value;
        }
      }, {}));
      $__export("NgSwitchWhen", NgSwitchWhen);
      $__export("NgSwitchWhen", NgSwitchWhen = __decorate([Directive({
        selector: '[ng-switch-when]',
        properties: ['ngSwitchWhen']
      }), __param(2, Ancestor()), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, NgSwitch])], NgSwitchWhen));
      NgSwitchDefault = (($traceurRuntime.createClass)(function(viewContainer, templateRef, sswitch) {
        sswitch._registerView(_whenDefault, new SwitchView(viewContainer, templateRef));
      }, {}, {}));
      $__export("NgSwitchDefault", NgSwitchDefault);
      $__export("NgSwitchDefault", NgSwitchDefault = __decorate([Directive({selector: '[ng-switch-default]'}), __param(2, Ancestor()), __metadata('design:paramtypes', [ViewContainerRef, TemplateRef, NgSwitch])], NgSwitchDefault));
      _whenDefault = new Object();
    }
  };
});

System.register("angular2/src/directives/class", ["angular2/annotations", "angular2/core", "angular2/src/change_detection/pipes/pipes", "angular2/src/render/api", "angular2/src/change_detection/pipes/iterable_changes", "angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/class";
  var __decorate,
      __metadata,
      Directive,
      LifecycleEvent,
      ElementRef,
      Pipes,
      Renderer,
      IterableChanges,
      isPresent,
      isString,
      ListWrapper,
      StringMapWrapper,
      isListLikeIterable,
      CSSClass;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Pipes = $__m.Pipes;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      IterableChanges = $__m.IterableChanges;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isString = $__m.isString;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
      isListLikeIterable = $__m.isListLikeIterable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      CSSClass = (($traceurRuntime.createClass)(function(_pipes, _ngEl, _renderer) {
        this._pipes = _pipes;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
      }, {
        set rawClass(v) {
          this._cleanupClasses(this._rawClass);
          if (isString(v)) {
            v = v.split(' ');
          }
          this._rawClass = v;
          this._pipe = this._pipes.get(isListLikeIterable(v) ? 'iterableDiff' : 'keyValDiff', v);
        },
        onCheck: function() {
          var diff = this._pipe.transform(this._rawClass, null);
          if (isPresent(diff) && isPresent(diff.wrapped)) {
            if (diff.wrapped instanceof IterableChanges) {
              this._applyArrayChanges(diff.wrapped);
            } else {
              this._applyObjectChanges(diff.wrapped);
            }
          }
        },
        onDestroy: function() {
          this._cleanupClasses(this._rawClass);
        },
        _cleanupClasses: function(rawClassVal) {
          var $__0 = this;
          if (isPresent(rawClassVal)) {
            if (isListLikeIterable(rawClassVal)) {
              ListWrapper.forEach(rawClassVal, (function(className) {
                $__0._toggleClass(className, false);
              }));
            } else {
              StringMapWrapper.forEach(rawClassVal, (function(expVal, className) {
                if (expVal)
                  $__0._toggleClass(className, false);
              }));
            }
          }
        },
        _applyObjectChanges: function(diff) {
          var $__0 = this;
          diff.forEachAddedItem((function(record) {
            $__0._toggleClass(record.key, record.currentValue);
          }));
          diff.forEachChangedItem((function(record) {
            $__0._toggleClass(record.key, record.currentValue);
          }));
          diff.forEachRemovedItem((function(record) {
            if (record.previousValue) {
              $__0._toggleClass(record.key, false);
            }
          }));
        },
        _applyArrayChanges: function(diff) {
          var $__0 = this;
          diff.forEachAddedItem((function(record) {
            $__0._toggleClass(record.item, true);
          }));
          diff.forEachRemovedItem((function(record) {
            $__0._toggleClass(record.item, false);
          }));
        },
        _toggleClass: function(className, enabled) {
          this._renderer.setElementClass(this._ngEl, className, enabled);
        }
      }, {}));
      $__export("CSSClass", CSSClass);
      $__export("CSSClass", CSSClass = __decorate([Directive({
        selector: '[class]',
        lifecycle: [LifecycleEvent.onCheck, LifecycleEvent.onDestroy],
        properties: ['rawClass: class']
      }), __metadata('design:paramtypes', [Pipes, ElementRef, Renderer])], CSSClass));
    }
  };
});

System.register("angular2/src/directives/ng_style", ["angular2/annotations", "angular2/core", "angular2/src/change_detection/pipes/pipes", "angular2/src/facade/lang", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/directives/ng_style";
  var __decorate,
      __metadata,
      Directive,
      LifecycleEvent,
      ElementRef,
      Pipes,
      isPresent,
      Renderer,
      NgStyle;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Pipes = $__m.Pipes;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Renderer = $__m.Renderer;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgStyle = (($traceurRuntime.createClass)(function(_pipes, _ngEl, _renderer) {
        this._pipes = _pipes;
        this._ngEl = _ngEl;
        this._renderer = _renderer;
      }, {
        set rawStyle(v) {
          this._rawStyle = v;
          this._pipe = this._pipes.get('keyValDiff', this._rawStyle);
        },
        onCheck: function() {
          var diff = this._pipe.transform(this._rawStyle, null);
          if (isPresent(diff) && isPresent(diff.wrapped)) {
            this._applyChanges(diff.wrapped);
          }
        },
        _applyChanges: function(diff) {
          var $__0 = this;
          diff.forEachAddedItem((function(record) {
            $__0._setStyle(record.key, record.currentValue);
          }));
          diff.forEachChangedItem((function(record) {
            $__0._setStyle(record.key, record.currentValue);
          }));
          diff.forEachRemovedItem((function(record) {
            $__0._setStyle(record.key, null);
          }));
        },
        _setStyle: function(name, val) {
          this._renderer.setElementStyle(this._ngEl, name, val);
        }
      }, {}));
      $__export("NgStyle", NgStyle);
      $__export("NgStyle", NgStyle = __decorate([Directive({
        selector: '[ng-style]',
        lifecycle: [LifecycleEvent.onCheck],
        properties: ['rawStyle: ng-style']
      }), __metadata('design:paramtypes', [Pipes, ElementRef, Renderer])], NgStyle));
    }
  };
});

System.register("angular2/src/http/interfaces", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/interfaces";
  var BaseException,
      ConnectionBackend,
      Connection;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      ConnectionBackend = (function() {
        function ConnectionBackend() {}
        return ($traceurRuntime.createClass)(ConnectionBackend, {createConnection: function(request) {
            throw new BaseException('Abstract!');
          }}, {});
      }());
      $__export("ConnectionBackend", ConnectionBackend);
      Connection = (function() {
        function Connection() {}
        return ($traceurRuntime.createClass)(Connection, {dispose: function() {
            throw new BaseException('Abstract!');
          }}, {});
      }());
      $__export("Connection", Connection);
    }
  };
});

System.register("angular2/src/http/headers", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/headers";
  var isBlank,
      BaseException,
      isListLikeIterable,
      Map,
      MapWrapper,
      ListWrapper,
      StringMap,
      Headers;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      isListLikeIterable = $__m.isListLikeIterable;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
      StringMap = $__m.StringMap;
    }],
    execute: function() {
      Headers = (function() {
        function Headers(headers) {
          var $__0 = this;
          if (isBlank(headers)) {
            this._headersMap = new Map();
            return ;
          }
          if (headers instanceof Headers) {
            this._headersMap = headers._headersMap;
          } else if (headers instanceof StringMap) {
            this._headersMap = MapWrapper.createFromStringMap(headers);
            MapWrapper.forEach(this._headersMap, (function(v, k) {
              if (!isListLikeIterable(v)) {
                var list = [];
                list.push(v);
                $__0._headersMap.set(k, list);
              }
            }));
          }
        }
        return ($traceurRuntime.createClass)(Headers, {
          append: function(name, value) {
            var mapName = this._headersMap.get(name);
            var list = isListLikeIterable(mapName) ? mapName : [];
            list.push(value);
            this._headersMap.set(name, list);
          },
          delete: function(name) {
            MapWrapper.delete(this._headersMap, name);
          },
          forEach: function(fn) {
            MapWrapper.forEach(this._headersMap, fn);
          },
          get: function(header) {
            return ListWrapper.first(this._headersMap.get(header));
          },
          has: function(header) {
            return this._headersMap.has(header);
          },
          keys: function() {
            return MapWrapper.keys(this._headersMap);
          },
          set: function(header, value) {
            var list = [];
            if (isListLikeIterable(value)) {
              var pushValue = value.join(',');
              list.push(pushValue);
            } else {
              list.push(value);
            }
            this._headersMap.set(header, list);
          },
          values: function() {
            return MapWrapper.values(this._headersMap);
          },
          getAll: function(header) {
            var headers = this._headersMap.get(header);
            return isListLikeIterable(headers) ? headers : [];
          },
          entries: function() {
            throw new BaseException('"entries" method is not implemented on Headers class');
          }
        }, {});
      }());
      $__export("Headers", Headers);
    }
  };
});

System.register("angular2/src/http/enums", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/enums";
  var RequestModesOpts,
      RequestCacheOpts,
      RequestCredentialsOpts,
      RequestMethods,
      RequestMethodsMap,
      ReadyStates,
      ResponseTypes;
  return {
    setters: [],
    execute: function() {
      $__export("RequestModesOpts", RequestModesOpts);
      (function(RequestModesOpts) {
        RequestModesOpts[RequestModesOpts["Cors"] = 0] = "Cors";
        RequestModesOpts[RequestModesOpts["NoCors"] = 1] = "NoCors";
        RequestModesOpts[RequestModesOpts["SameOrigin"] = 2] = "SameOrigin";
      })(RequestModesOpts || ($__export("RequestModesOpts", RequestModesOpts = {})));
      $__export("RequestCacheOpts", RequestCacheOpts);
      (function(RequestCacheOpts) {
        RequestCacheOpts[RequestCacheOpts["Default"] = 0] = "Default";
        RequestCacheOpts[RequestCacheOpts["NoStore"] = 1] = "NoStore";
        RequestCacheOpts[RequestCacheOpts["Reload"] = 2] = "Reload";
        RequestCacheOpts[RequestCacheOpts["NoCache"] = 3] = "NoCache";
        RequestCacheOpts[RequestCacheOpts["ForceCache"] = 4] = "ForceCache";
        RequestCacheOpts[RequestCacheOpts["OnlyIfCached"] = 5] = "OnlyIfCached";
      })(RequestCacheOpts || ($__export("RequestCacheOpts", RequestCacheOpts = {})));
      $__export("RequestCredentialsOpts", RequestCredentialsOpts);
      (function(RequestCredentialsOpts) {
        RequestCredentialsOpts[RequestCredentialsOpts["Omit"] = 0] = "Omit";
        RequestCredentialsOpts[RequestCredentialsOpts["SameOrigin"] = 1] = "SameOrigin";
        RequestCredentialsOpts[RequestCredentialsOpts["Include"] = 2] = "Include";
      })(RequestCredentialsOpts || ($__export("RequestCredentialsOpts", RequestCredentialsOpts = {})));
      $__export("RequestMethods", RequestMethods);
      (function(RequestMethods) {
        RequestMethods[RequestMethods["GET"] = 0] = "GET";
        RequestMethods[RequestMethods["POST"] = 1] = "POST";
        RequestMethods[RequestMethods["PUT"] = 2] = "PUT";
        RequestMethods[RequestMethods["DELETE"] = 3] = "DELETE";
        RequestMethods[RequestMethods["OPTIONS"] = 4] = "OPTIONS";
        RequestMethods[RequestMethods["HEAD"] = 5] = "HEAD";
        RequestMethods[RequestMethods["PATCH"] = 6] = "PATCH";
      })(RequestMethods || ($__export("RequestMethods", RequestMethods = {})));
      RequestMethodsMap = (function() {
        function RequestMethodsMap() {
          this._methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'HEAD', 'PATCH'];
        }
        return ($traceurRuntime.createClass)(RequestMethodsMap, {getMethod: function(method) {
            return this._methods[method];
          }}, {});
      }());
      $__export("RequestMethodsMap", RequestMethodsMap);
      $__export("ReadyStates", ReadyStates);
      (function(ReadyStates) {
        ReadyStates[ReadyStates["UNSENT"] = 0] = "UNSENT";
        ReadyStates[ReadyStates["OPEN"] = 1] = "OPEN";
        ReadyStates[ReadyStates["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
        ReadyStates[ReadyStates["LOADING"] = 3] = "LOADING";
        ReadyStates[ReadyStates["DONE"] = 4] = "DONE";
        ReadyStates[ReadyStates["CANCELLED"] = 5] = "CANCELLED";
      })(ReadyStates || ($__export("ReadyStates", ReadyStates = {})));
      $__export("ResponseTypes", ResponseTypes);
      (function(ResponseTypes) {
        ResponseTypes[ResponseTypes["Basic"] = 0] = "Basic";
        ResponseTypes[ResponseTypes["Cors"] = 1] = "Cors";
        ResponseTypes[ResponseTypes["Default"] = 2] = "Default";
        ResponseTypes[ResponseTypes["Error"] = 3] = "Error";
        ResponseTypes[ResponseTypes["Opaque"] = 4] = "Opaque";
      })(ResponseTypes || ($__export("ResponseTypes", ResponseTypes = {})));
    }
  };
});

System.register("angular2/src/http/http_utils", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/http_utils";
  return {
    setters: [function($__m) {
      $__export("isJsObject", $__m.isJsObject);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/http/base_response_options", ["angular2/di", "angular2/src/facade/lang", "angular2/src/http/headers", "angular2/src/http/enums"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/base_response_options";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      Headers,
      ResponseTypes,
      ResponseOptions,
      BaseResponseOptions;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Headers = $__m.Headers;
    }, function($__m) {
      ResponseTypes = $__m.ResponseTypes;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ResponseOptions = (function() {
        function ResponseOptions() {
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              body = $__2.body,
              status = $__2.status,
              headers = $__2.headers,
              statusText = $__2.statusText,
              type = $__2.type,
              url = $__2.url;
          this.body = isPresent(body) ? body : null;
          this.status = isPresent(status) ? status : null;
          this.headers = isPresent(headers) ? headers : null;
          this.statusText = isPresent(statusText) ? statusText : null;
          this.type = isPresent(type) ? type : null;
          this.url = isPresent(url) ? url : null;
        }
        return ($traceurRuntime.createClass)(ResponseOptions, {merge: function(options) {
            return new ResponseOptions({
              body: isPresent(options) && isPresent(options.body) ? options.body : this.body,
              status: isPresent(options) && isPresent(options.status) ? options.status : this.status,
              headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,
              statusText: isPresent(options) && isPresent(options.statusText) ? options.statusText : this.statusText,
              type: isPresent(options) && isPresent(options.type) ? options.type : this.type,
              url: isPresent(options) && isPresent(options.url) ? options.url : this.url
            });
          }}, {});
      }());
      $__export("ResponseOptions", ResponseOptions);
      BaseResponseOptions = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this, {
            status: 200,
            statusText: 'Ok',
            type: ResponseTypes.Default,
            headers: new Headers()
          });
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(ResponseOptions));
      $__export("BaseResponseOptions", BaseResponseOptions);
      $__export("BaseResponseOptions", BaseResponseOptions = __decorate([Injectable(), __metadata('design:paramtypes', [])], BaseResponseOptions));
    }
  };
});

System.register("angular2/src/http/backends/browser_xhr", ["angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/backends/browser_xhr";
  var __decorate,
      __metadata,
      Injectable,
      BrowserXhr;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      BrowserXhr = (($traceurRuntime.createClass)(function() {}, {build: function() {
          return (new XMLHttpRequest());
        }}, {}));
      $__export("BrowserXhr", BrowserXhr);
      $__export("BrowserXhr", BrowserXhr = __decorate([Injectable(), __metadata('design:paramtypes', [])], BrowserXhr));
    }
  };
});

System.register("angular2/src/http/backends/browser_jsonp", ["angular2/di", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/backends/browser_jsonp";
  var __decorate,
      __metadata,
      Injectable,
      global,
      _nextRequestId,
      JSONP_HOME,
      _jsonpConnections,
      BrowserJsonp;
  function _getJsonpConnections() {
    if (_jsonpConnections === null) {
      _jsonpConnections = global[JSONP_HOME] = {};
    }
    return _jsonpConnections;
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      global = $__m.global;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      _nextRequestId = 0;
      JSONP_HOME = '__ng_jsonp__';
      $__export("JSONP_HOME", JSONP_HOME);
      _jsonpConnections = null;
      BrowserJsonp = (($traceurRuntime.createClass)(function() {}, {
        build: function(url) {
          var node = document.createElement('script');
          node.src = url;
          return node;
        },
        nextRequestID: function() {
          return ("__req" + _nextRequestId++);
        },
        requestCallback: function(id) {
          return (JSONP_HOME + "." + id + ".finished");
        },
        exposeConnection: function(id, connection) {
          var connections = _getJsonpConnections();
          connections[id] = connection;
        },
        removeConnection: function(id) {
          var connections = _getJsonpConnections();
          connections[id] = null;
        },
        send: function(node) {
          document.body.appendChild((node));
        },
        cleanup: function(node) {
          if (node.parentNode) {
            node.parentNode.removeChild((node));
          }
        }
      }, {}));
      $__export("BrowserJsonp", BrowserJsonp);
      $__export("BrowserJsonp", BrowserJsonp = __decorate([Injectable(), __metadata('design:paramtypes', [])], BrowserJsonp));
    }
  };
});

System.register("angular2/src/http/backends/mock_backend", ["angular2/di", "angular2/src/http/static_request", "angular2/src/http/enums", "angular2/src/http/interfaces", "angular2/src/facade/async", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/backends/mock_backend";
  var __decorate,
      __metadata,
      Injectable,
      Request,
      ReadyStates,
      Connection,
      ConnectionBackend,
      ObservableWrapper,
      EventEmitter,
      isPresent,
      IMPLEMENTS,
      BaseException,
      MockConnection,
      MockBackend;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      Request = $__m.Request;
    }, function($__m) {
      ReadyStates = $__m.ReadyStates;
    }, function($__m) {
      Connection = $__m.Connection;
      ConnectionBackend = $__m.ConnectionBackend;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
      EventEmitter = $__m.EventEmitter;
    }, function($__m) {
      isPresent = $__m.isPresent;
      IMPLEMENTS = $__m.IMPLEMENTS;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      MockConnection = (($traceurRuntime.createClass)(function(req) {
        this.response = new EventEmitter();
        this.readyState = ReadyStates.OPEN;
        this.request = req;
      }, {
        dispose: function() {
          if (this.readyState !== ReadyStates.DONE) {
            this.readyState = ReadyStates.CANCELLED;
          }
        },
        mockRespond: function(res) {
          if (this.readyState === ReadyStates.DONE || this.readyState === ReadyStates.CANCELLED) {
            throw new BaseException('Connection has already been resolved');
          }
          this.readyState = ReadyStates.DONE;
          ObservableWrapper.callNext(this.response, res);
          ObservableWrapper.callReturn(this.response);
        },
        mockDownload: function(res) {},
        mockError: function(err) {
          this.readyState = ReadyStates.DONE;
          ObservableWrapper.callThrow(this.response, err);
          ObservableWrapper.callReturn(this.response);
        }
      }, {}));
      $__export("MockConnection", MockConnection);
      $__export("MockConnection", MockConnection = __decorate([IMPLEMENTS(Connection), __metadata('design:paramtypes', [Request])], MockConnection));
      MockBackend = (($traceurRuntime.createClass)(function() {
        var $__0 = this;
        this.connectionsArray = [];
        this.connections = new EventEmitter();
        ObservableWrapper.subscribe(this.connections, (function(connection) {
          return $__0.connectionsArray.push(connection);
        }));
        this.pendingConnections = new EventEmitter();
      }, {
        verifyNoPendingRequests: function() {
          var pending = 0;
          ObservableWrapper.subscribe(this.pendingConnections, (function(c) {
            return pending++;
          }));
          if (pending > 0)
            throw new BaseException((pending + " pending connections to be resolved"));
        },
        resolveAllConnections: function() {
          ObservableWrapper.subscribe(this.connections, (function(c) {
            return c.readyState = 4;
          }));
        },
        createConnection: function(req) {
          if (!isPresent(req) || !(req instanceof Request)) {
            throw new BaseException(("createConnection requires an instance of Request, got " + req));
          }
          var connection = new MockConnection(req);
          ObservableWrapper.callNext(this.connections, connection);
          return connection;
        }
      }, {}));
      $__export("MockBackend", MockBackend);
      $__export("MockBackend", MockBackend = __decorate([Injectable(), IMPLEMENTS(ConnectionBackend), __metadata('design:paramtypes', [])], MockBackend));
    }
  };
});

System.register("angular2/src/http/url_search_params", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/url_search_params";
  var isPresent,
      StringWrapper,
      Map,
      MapWrapper,
      ListWrapper,
      isListLikeIterable,
      URLSearchParams;
  function paramParser(rawParams) {
    var map = new Map();
    var params = StringWrapper.split(rawParams, new RegExp('&'));
    ListWrapper.forEach(params, (function(param) {
      var split = StringWrapper.split(param, new RegExp('='));
      var key = ListWrapper.get(split, 0);
      var val = ListWrapper.get(split, 1);
      var list = isPresent(map.get(key)) ? map.get(key) : [];
      list.push(val);
      map.set(key, list);
    }));
    return map;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
      isListLikeIterable = $__m.isListLikeIterable;
    }],
    execute: function() {
      URLSearchParams = (function() {
        function URLSearchParams(rawParams) {
          this.rawParams = rawParams;
          this.paramsMap = paramParser(rawParams);
        }
        return ($traceurRuntime.createClass)(URLSearchParams, {
          has: function(param) {
            return this.paramsMap.has(param);
          },
          get: function(param) {
            var storedParam = this.paramsMap.get(param);
            if (isListLikeIterable(storedParam)) {
              return ListWrapper.first(storedParam);
            } else {
              return null;
            }
          },
          getAll: function(param) {
            var mapParam = this.paramsMap.get(param);
            return isPresent(mapParam) ? mapParam : [];
          },
          append: function(param, val) {
            var mapParam = this.paramsMap.get(param);
            var list = isPresent(mapParam) ? mapParam : [];
            list.push(val);
            this.paramsMap.set(param, list);
          },
          toString: function() {
            var paramsList = [];
            MapWrapper.forEach(this.paramsMap, (function(values, k) {
              ListWrapper.forEach(values, (function(v) {
                paramsList.push(k + '=' + v);
              }));
            }));
            return ListWrapper.join(paramsList, '&');
          },
          delete: function(param) {
            MapWrapper.delete(this.paramsMap, param);
          }
        }, {});
      }());
      $__export("URLSearchParams", URLSearchParams);
    }
  };
});

System.register("angular2/src/forms/validators", ["angular2/src/facade/lang", "angular2/src/facade/collection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/validators";
  var isBlank,
      isPresent,
      ListWrapper,
      StringMapWrapper,
      Validators;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }],
    execute: function() {
      Validators = (function() {
        function Validators() {}
        return ($traceurRuntime.createClass)(Validators, {}, {
          required: function(c) {
            return isBlank(c.value) || c.value == "" ? {"required": true} : null;
          },
          nullValidator: function(c) {
            return null;
          },
          compose: function(validators) {
            return function(c) {
              var res = ListWrapper.reduce(validators, (function(res, validator) {
                var errors = validator(c);
                return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;
              }), {});
              return StringMapWrapper.isEmpty(res) ? null : res;
            };
          },
          group: function(c) {
            var res = {};
            StringMapWrapper.forEach(c.controls, (function(control, name) {
              if (c.contains(name) && isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          array: function(c) {
            var res = {};
            ListWrapper.forEach(c.controls, (function(control) {
              if (isPresent(control.errors)) {
                Validators._mergeErrors(control, res);
              }
            }));
            return StringMapWrapper.isEmpty(res) ? null : res;
          },
          _mergeErrors: function(control, res) {
            StringMapWrapper.forEach(control.errors, (function(value, error) {
              if (!StringMapWrapper.contains(res, error)) {
                res[error] = [];
              }
              var current = res[error];
              current.push(control);
            }));
          }
        });
      }());
      $__export("Validators", Validators);
    }
  };
});

System.register("angular2/src/forms/directives/abstract_control_directive", [], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/abstract_control_directive";
  var AbstractControlDirective;
  return {
    setters: [],
    execute: function() {
      AbstractControlDirective = (function() {
        function AbstractControlDirective() {}
        return ($traceurRuntime.createClass)(AbstractControlDirective, {
          get control() {
            return null;
          },
          get value() {
            return this.control.value;
          },
          get valid() {
            return this.control.valid;
          },
          get errors() {
            return this.control.errors;
          },
          get pristine() {
            return this.control.pristine;
          },
          get dirty() {
            return this.control.dirty;
          },
          get touched() {
            return this.control.touched;
          },
          get untouched() {
            return this.control.untouched;
          }
        }, {});
      }());
      $__export("AbstractControlDirective", AbstractControlDirective);
    }
  };
});

System.register("angular2/src/forms/directives/control_container", ["angular2/src/forms/directives/abstract_control_directive"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/control_container";
  var AbstractControlDirective,
      ControlContainer;
  return {
    setters: [function($__m) {
      AbstractControlDirective = $__m.AbstractControlDirective;
    }],
    execute: function() {
      ControlContainer = (function($__super) {
        function ControlContainer() {
          $traceurRuntime.superConstructor(ControlContainer).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(ControlContainer, {
          get formDirective() {
            return null;
          },
          get path() {
            return null;
          }
        }, {}, $__super);
      }(AbstractControlDirective));
      $__export("ControlContainer", ControlContainer);
    }
  };
});

System.register("angular2/src/forms/directives/ng_control", ["angular2/src/forms/directives/abstract_control_directive"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control";
  var AbstractControlDirective,
      NgControl;
  return {
    setters: [function($__m) {
      AbstractControlDirective = $__m.AbstractControlDirective;
    }],
    execute: function() {
      NgControl = (function($__super) {
        function NgControl() {
          var $__2;
          for (var args = [],
              $__1 = 0; $__1 < arguments.length; $__1++)
            args[$__1] = arguments[$__1];
          ($__2 = $traceurRuntime.superConstructor(NgControl)).call.apply($__2, $traceurRuntime.spread([this], args));
          this.name = null;
          this.valueAccessor = null;
        }
        return ($traceurRuntime.createClass)(NgControl, {
          get validator() {
            return null;
          },
          get path() {
            return null;
          },
          viewToModelUpdate: function(newValue) {}
        }, {}, $__super);
      }(AbstractControlDirective));
      $__export("NgControl", NgControl);
    }
  };
});

System.register("angular2/src/forms/directives/validators", ["angular2/di", "angular2/src/facade/lang", "angular2/annotations", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/validators";
  var __decorate,
      __metadata,
      forwardRef,
      Binding,
      CONST_EXPR,
      Directive,
      Validators,
      NgValidator,
      requiredValidatorBinding,
      NgRequiredValidator;
  return {
    setters: [function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      NgValidator = (function() {
        function NgValidator() {}
        return ($traceurRuntime.createClass)(NgValidator, {get validator() {
            throw "Is not implemented";
          }}, {});
      }());
      $__export("NgValidator", NgValidator);
      requiredValidatorBinding = CONST_EXPR(new Binding(NgValidator, {toAlias: forwardRef((function() {
          return NgRequiredValidator;
        }))}));
      NgRequiredValidator = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {get validator() {
            return Validators.required;
          }}, {}, $__super);
      }(NgValidator));
      $__export("NgRequiredValidator", NgRequiredValidator);
      $__export("NgRequiredValidator", NgRequiredValidator = __decorate([Directive({
        selector: '[required][ng-control],[required][ng-form-control],[required][ng-model]',
        hostInjector: [requiredValidatorBinding]
      }), __metadata('design:paramtypes', [])], NgRequiredValidator));
    }
  };
});

System.register("angular2/src/forms/directives/shared", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/shared";
  var ListWrapper,
      StringMapWrapper,
      isBlank,
      BaseException,
      looseIdentical,
      Validators;
  function controlPath(name, parent) {
    var p = ListWrapper.clone(parent.path);
    p.push(name);
    return p;
  }
  function setUpControl(c, dir) {
    if (isBlank(c))
      _throwError(dir, "Cannot find control");
    if (isBlank(dir.valueAccessor))
      _throwError(dir, "No value accessor for");
    c.validator = Validators.compose([c.validator, dir.validator]);
    dir.valueAccessor.writeValue(c.value);
    dir.valueAccessor.registerOnChange((function(newValue) {
      dir.viewToModelUpdate(newValue);
      c.updateValue(newValue, {emitModelToViewChange: false});
      c.markAsDirty();
    }));
    c.registerOnChange((function(newValue) {
      return dir.valueAccessor.writeValue(newValue);
    }));
    dir.valueAccessor.registerOnTouched((function() {
      return c.markAsTouched();
    }));
  }
  function composeNgValidator(ngValidators) {
    if (isBlank(ngValidators))
      return Validators.nullValidator;
    return Validators.compose(ngValidators.map((function(v) {
      return v.validator;
    })));
  }
  function _throwError(dir, message) {
    var path = ListWrapper.join(dir.path, " -> ");
    throw new BaseException((message + " '" + path + "'"));
  }
  function setProperty(renderer, elementRef, propName, propValue) {
    renderer.setElementProperty(elementRef, propName, propValue);
  }
  function isPropertyUpdated(changes, viewModel) {
    if (!StringMapWrapper.contains(changes, "model"))
      return false;
    var change = changes["model"];
    if (change.isFirstChange())
      return true;
    return !looseIdentical(viewModel, change.currentValue);
  }
  $__export("controlPath", controlPath);
  $__export("setUpControl", setUpControl);
  $__export("composeNgValidator", composeNgValidator);
  $__export("setProperty", setProperty);
  $__export("isPropertyUpdated", isPropertyUpdated);
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      looseIdentical = $__m.looseIdentical;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
    }
  };
});

System.register("angular2/src/forms/directives/ng_form_control", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/annotations", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form_control";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      NgControl,
      NgValidator,
      setUpControl,
      composeNgValidator,
      isPropertyUpdated,
      formControlBinding,
      NgFormControl;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      formControlBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgFormControl;
        }))}));
      NgFormControl = (function($__super) {
        function $__0(ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.update = new EventEmitter();
          this._added = false;
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              setUpControl(this.form, this);
              this.form.updateValidity();
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this.form.updateValue(this.model);
            }
          },
          get path() {
            return [];
          },
          get control() {
            return this.form;
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgFormControl", NgFormControl);
      $__export("NgFormControl", NgFormControl = __decorate([Directive({
        selector: '[ng-form-control]',
        hostInjector: [formControlBinding],
        properties: ['form: ngFormControl', 'model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Query(NgValidator)), __metadata('design:paramtypes', [QueryList])], NgFormControl));
    }
  };
});

System.register("angular2/src/forms/directives/ng_model", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/annotations", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/forms/model", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_model";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      NgControl,
      Control,
      NgValidator,
      setUpControl,
      composeNgValidator,
      isPropertyUpdated,
      formControlBinding,
      NgModel;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      Control = $__m.Control;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      formControlBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgModel;
        }))}));
      NgModel = (function($__super) {
        function $__0(ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._control = new Control();
          this._added = false;
          this.update = new EventEmitter();
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              setUpControl(this._control, this);
              this._control.updateValidity();
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this._control.updateValue(this.model);
            }
          },
          get control() {
            return this._control;
          },
          get path() {
            return [];
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgModel", NgModel);
      $__export("NgModel", NgModel = __decorate([Directive({
        selector: '[ng-model]:not([ng-control]):not([ng-form-control])',
        hostInjector: [formControlBinding],
        properties: ['model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Query(NgValidator)), __metadata('design:paramtypes', [QueryList])], NgModel));
    }
  };
});

System.register("angular2/src/forms/directives/ng_control_group", ["angular2/annotations", "angular2/di", "angular2/src/facade/lang", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control_group";
  var __decorate,
      __metadata,
      __param,
      Directive,
      LifecycleEvent,
      Ancestor,
      forwardRef,
      Binding,
      CONST_EXPR,
      ControlContainer,
      controlPath,
      controlGroupBinding,
      NgControlGroup;
  return {
    setters: [function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      Ancestor = $__m.Ancestor;
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      controlPath = $__m.controlPath;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      controlGroupBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgControlGroup;
        }))}));
      NgControlGroup = (function($__super) {
        function $__0(_parent) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._parent = _parent;
        }
        return ($traceurRuntime.createClass)($__0, {
          onInit: function() {
            this.formDirective.addControlGroup(this);
          },
          onDestroy: function() {
            this.formDirective.removeControlGroup(this);
          },
          get control() {
            return this.formDirective.getControlGroup(this);
          },
          get path() {
            return controlPath(this.name, this._parent);
          },
          get formDirective() {
            return this._parent.formDirective;
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgControlGroup", NgControlGroup);
      $__export("NgControlGroup", NgControlGroup = __decorate([Directive({
        selector: '[ng-control-group]',
        hostInjector: [controlGroupBinding],
        properties: ['name: ng-control-group'],
        lifecycle: [LifecycleEvent.onInit, LifecycleEvent.onDestroy],
        exportAs: 'form'
      }), __param(0, Ancestor()), __metadata('design:paramtypes', [ControlContainer])], NgControlGroup));
    }
  };
});

System.register("angular2/src/forms/directives/ng_form_model", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/annotations", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form_model";
  var __decorate,
      __metadata,
      CONST_EXPR,
      ListWrapper,
      ObservableWrapper,
      EventEmitter,
      Directive,
      LifecycleEvent,
      forwardRef,
      Binding,
      ControlContainer,
      setUpControl,
      formDirectiveBinding,
      NgFormModel;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
      EventEmitter = $__m.EventEmitter;
    }, function($__m) {
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      formDirectiveBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgFormModel;
        }))}));
      NgFormModel = (function($__super) {
        function $__1() {
          var $__4;
          for (var args = [],
              $__3 = 0; $__3 < arguments.length; $__3++)
            args[$__3] = arguments[$__3];
          ($__4 = $traceurRuntime.superConstructor($__1)).call.apply($__4, $traceurRuntime.spread([this], args));
          this.form = null;
          this.directives = [];
          this.ngSubmit = new EventEmitter();
        }
        return ($traceurRuntime.createClass)($__1, {
          onChange: function(_) {
            this._updateDomValue();
          },
          get formDirective() {
            return this;
          },
          get control() {
            return this.form;
          },
          get path() {
            return [];
          },
          addControl: function(dir) {
            var c = this.form.find(dir.path);
            setUpControl(c, dir);
            c.updateValidity();
            this.directives.push(dir);
          },
          getControl: function(dir) {
            return this.form.find(dir.path);
          },
          removeControl: function(dir) {
            ListWrapper.remove(this.directives, dir);
          },
          addControlGroup: function(dir) {},
          removeControlGroup: function(dir) {},
          getControlGroup: function(dir) {
            return this.form.find(dir.path);
          },
          updateModel: function(dir, value) {
            var c = this.form.find(dir.path);
            c.updateValue(value);
          },
          onSubmit: function() {
            ObservableWrapper.callNext(this.ngSubmit, null);
            return false;
          },
          _updateDomValue: function() {
            var $__0 = this;
            ListWrapper.forEach(this.directives, (function(dir) {
              var c = $__0.form.find(dir.path);
              dir.valueAccessor.writeValue(c.value);
            }));
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgFormModel", NgFormModel);
      $__export("NgFormModel", NgFormModel = __decorate([Directive({
        selector: '[ng-form-model]',
        hostInjector: [formDirectiveBinding],
        properties: ['form: ng-form-model'],
        lifecycle: [LifecycleEvent.onChange],
        host: {'(submit)': 'onSubmit()'},
        events: ['ngSubmit'],
        exportAs: 'form'
      }), __metadata('design:paramtypes', [])], NgFormModel));
    }
  };
});

System.register("angular2/src/forms/directives/ng_form", ["angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/annotations", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/model", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_form";
  var __decorate,
      __metadata,
      PromiseWrapper,
      ObservableWrapper,
      EventEmitter,
      ListWrapper,
      isPresent,
      CONST_EXPR,
      Directive,
      forwardRef,
      Binding,
      ControlContainer,
      ControlGroup,
      Control,
      setUpControl,
      formDirectiveBinding,
      NgForm;
  return {
    setters: [function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
      ObservableWrapper = $__m.ObservableWrapper;
      EventEmitter = $__m.EventEmitter;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      ControlGroup = $__m.ControlGroup;
      Control = $__m.Control;
    }, function($__m) {
      setUpControl = $__m.setUpControl;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      formDirectiveBinding = CONST_EXPR(new Binding(ControlContainer, {toAlias: forwardRef((function() {
          return NgForm;
        }))}));
      NgForm = (function($__super) {
        function $__1() {
          $traceurRuntime.superConstructor($__1).call(this);
          this.ngSubmit = new EventEmitter();
          this.form = new ControlGroup({});
        }
        return ($traceurRuntime.createClass)($__1, {
          get formDirective() {
            return this;
          },
          get control() {
            return this.form;
          },
          get path() {
            return [];
          },
          get controls() {
            return this.form.controls;
          },
          addControl: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              var c = new Control();
              setUpControl(c, dir);
              container.addControl(dir.name, c);
              c.updateValidity();
            }));
          },
          getControl: function(dir) {
            return this.form.find(dir.path);
          },
          removeControl: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              if (isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
              }
            }));
          },
          addControlGroup: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              var c = new ControlGroup({});
              container.addControl(dir.name, c);
              c.updateValidity();
            }));
          },
          removeControlGroup: function(dir) {
            var $__0 = this;
            this._later((function(_) {
              var container = $__0._findContainer(dir.path);
              if (isPresent(container)) {
                container.removeControl(dir.name);
                container.updateValidity();
              }
            }));
          },
          getControlGroup: function(dir) {
            return this.form.find(dir.path);
          },
          updateModel: function(dir, value) {
            var $__0 = this;
            this._later((function(_) {
              var c = $__0.form.find(dir.path);
              c.updateValue(value);
            }));
          },
          onSubmit: function() {
            ObservableWrapper.callNext(this.ngSubmit, null);
            return false;
          },
          _findContainer: function(path) {
            ListWrapper.removeLast(path);
            return ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
          },
          _later: function(fn) {
            var c = PromiseWrapper.completer();
            PromiseWrapper.then(c.promise, fn, (function(_) {}));
            c.resolve(null);
          }
        }, {}, $__super);
      }(ControlContainer));
      $__export("NgForm", NgForm);
      $__export("NgForm", NgForm = __decorate([Directive({
        selector: 'form:not([ng-no-form]):not([ng-form-model]),ng-form,[ng-form]',
        hostInjector: [formDirectiveBinding],
        host: {'(submit)': 'onSubmit()'},
        events: ['ngSubmit'],
        exportAs: 'form'
      }), __metadata('design:paramtypes', [])], NgForm));
    }
  };
});

System.register("angular2/render", ["angular2/src/render/render"], function($__export) {
  "use strict";
  var __moduleName = "angular2/render";
  return {
    setters: [function($__m) {
      $__export("Renderer", $__m.Renderer);
      $__export("RenderViewRef", $__m.RenderViewRef);
      $__export("RenderProtoViewRef", $__m.RenderProtoViewRef);
      $__export("RenderFragmentRef", $__m.RenderFragmentRef);
      $__export("RenderViewWithFragments", $__m.RenderViewWithFragments);
      $__export("DomRenderer", $__m.DomRenderer);
      $__export("DOCUMENT_TOKEN", $__m.DOCUMENT_TOKEN);
      $__export("APP_ID_TOKEN", $__m.APP_ID_TOKEN);
      $__export("DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES", $__m.DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/forms/directives/checkbox_value_accessor", ["angular2/render", "angular2/annotations", "angular2/core", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/checkbox_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      Directive,
      ElementRef,
      Self,
      NgControl,
      isPresent,
      setProperty,
      CheckboxControlValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      CheckboxControlValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
      }, {
        writeValue: function(value) {
          setProperty(this.renderer, this.elementRef, "checked", value);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        }
      }, {}));
      $__export("CheckboxControlValueAccessor", CheckboxControlValueAccessor);
      $__export("CheckboxControlValueAccessor", CheckboxControlValueAccessor = __decorate([Directive({
        selector: 'input[type=checkbox][ng-control],input[type=checkbox][ng-form-control],input[type=checkbox][ng-model]',
        host: {
          '(change)': 'onChange($event.target.checked)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef])], CheckboxControlValueAccessor));
    }
  };
});

System.register("angular2/src/forms/directives/select_control_value_accessor", ["angular2/render", "angular2/core", "angular2/di", "angular2/annotations", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/select_control_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      ElementRef,
      QueryList,
      Self,
      Query,
      Directive,
      NgControl,
      isPresent,
      setProperty,
      NgSelectOption,
      SelectControlValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
      QueryList = $__m.QueryList;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      NgSelectOption = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("NgSelectOption", NgSelectOption);
      $__export("NgSelectOption", NgSelectOption = __decorate([Directive({selector: 'option'}), __metadata('design:paramtypes', [])], NgSelectOption));
      SelectControlValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef, query) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
        this._updateValueWhenListOfOptionsChanges(query);
      }, {
        writeValue: function(value) {
          this.value = value;
          setProperty(this.renderer, this.elementRef, "value", value);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        },
        _updateValueWhenListOfOptionsChanges: function(query) {
          var $__0 = this;
          query.onChange((function() {
            return $__0.writeValue($__0.value);
          }));
        }
      }, {}));
      $__export("SelectControlValueAccessor", SelectControlValueAccessor);
      $__export("SelectControlValueAccessor", SelectControlValueAccessor = __decorate([Directive({
        selector: 'select[ng-control],select[ng-form-control],select[ng-model]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __param(3, Query(NgSelectOption, {descendants: true})), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef, QueryList])], SelectControlValueAccessor));
    }
  };
});

System.register("angular2/src/forms/directives", ["angular2/src/facade/lang", "angular2/src/forms/directives/ng_control_name", "angular2/src/forms/directives/ng_form_control", "angular2/src/forms/directives/ng_model", "angular2/src/forms/directives/ng_control_group", "angular2/src/forms/directives/ng_form_model", "angular2/src/forms/directives/ng_form", "angular2/src/forms/directives/default_value_accessor", "angular2/src/forms/directives/checkbox_value_accessor", "angular2/src/forms/directives/select_control_value_accessor", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/ng_control"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives";
  var CONST_EXPR,
      NgControlName,
      NgFormControl,
      NgModel,
      NgControlGroup,
      NgFormModel,
      NgForm,
      DefaultValueAccessor,
      CheckboxControlValueAccessor,
      SelectControlValueAccessor,
      NgSelectOption,
      NgRequiredValidator,
      formDirectives;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      NgControlName = $__m.NgControlName;
      $__export("NgControlName", $__m.NgControlName);
    }, function($__m) {
      NgFormControl = $__m.NgFormControl;
      $__export("NgFormControl", $__m.NgFormControl);
    }, function($__m) {
      NgModel = $__m.NgModel;
      $__export("NgModel", $__m.NgModel);
    }, function($__m) {
      NgControlGroup = $__m.NgControlGroup;
      $__export("NgControlGroup", $__m.NgControlGroup);
    }, function($__m) {
      NgFormModel = $__m.NgFormModel;
      $__export("NgFormModel", $__m.NgFormModel);
    }, function($__m) {
      NgForm = $__m.NgForm;
      $__export("NgForm", $__m.NgForm);
    }, function($__m) {
      DefaultValueAccessor = $__m.DefaultValueAccessor;
      $__export("DefaultValueAccessor", $__m.DefaultValueAccessor);
    }, function($__m) {
      CheckboxControlValueAccessor = $__m.CheckboxControlValueAccessor;
      $__export("CheckboxControlValueAccessor", $__m.CheckboxControlValueAccessor);
    }, function($__m) {
      SelectControlValueAccessor = $__m.SelectControlValueAccessor;
      NgSelectOption = $__m.NgSelectOption;
      $__export("SelectControlValueAccessor", $__m.SelectControlValueAccessor);
      $__export("NgSelectOption", $__m.NgSelectOption);
    }, function($__m) {
      NgRequiredValidator = $__m.NgRequiredValidator;
      $__export("NgValidator", $__m.NgValidator);
      $__export("NgRequiredValidator", $__m.NgRequiredValidator);
    }, function($__m) {
      $__export("NgControl", $__m.NgControl);
    }],
    execute: function() {
      formDirectives = CONST_EXPR([NgControlName, NgControlGroup, NgFormControl, NgModel, NgFormModel, NgForm, NgSelectOption, DefaultValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, NgRequiredValidator]);
      $__export("formDirectives", formDirectives);
    }
  };
});

System.register("angular2/src/forms/form_builder", ["angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/forms/model"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/form_builder";
  var __decorate,
      __metadata,
      Injectable,
      StringMapWrapper,
      ListWrapper,
      isPresent,
      isArray,
      modelModule,
      FormBuilder;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isArray = $__m.isArray;
    }, function($__m) {
      modelModule = $__m;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      FormBuilder = (($traceurRuntime.createClass)(function() {}, {
        group: function(controlsConfig) {
          var extra = arguments[1] !== (void 0) ? arguments[1] : null;
          var controls = this._reduceControls(controlsConfig);
          var optionals = isPresent(extra) ? StringMapWrapper.get(extra, "optionals") : null;
          var validator = isPresent(extra) ? StringMapWrapper.get(extra, "validator") : null;
          if (isPresent(validator)) {
            return new modelModule.ControlGroup(controls, optionals, validator);
          } else {
            return new modelModule.ControlGroup(controls, optionals);
          }
        },
        control: function(value) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : null;
          if (isPresent(validator)) {
            return new modelModule.Control(value, validator);
          } else {
            return new modelModule.Control(value);
          }
        },
        array: function(controlsConfig) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : null;
          var $__0 = this;
          var controls = ListWrapper.map(controlsConfig, (function(c) {
            return $__0._createControl(c);
          }));
          if (isPresent(validator)) {
            return new modelModule.ControlArray(controls, validator);
          } else {
            return new modelModule.ControlArray(controls);
          }
        },
        _reduceControls: function(controlsConfig) {
          var $__0 = this;
          var controls = {};
          StringMapWrapper.forEach(controlsConfig, (function(controlConfig, controlName) {
            controls[controlName] = $__0._createControl(controlConfig);
          }));
          return controls;
        },
        _createControl: function(controlConfig) {
          if (controlConfig instanceof modelModule.Control || controlConfig instanceof modelModule.ControlGroup || controlConfig instanceof modelModule.ControlArray) {
            return controlConfig;
          } else if (isArray(controlConfig)) {
            var value = ListWrapper.get(controlConfig, 0);
            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
            return this.control(value, validator);
          } else {
            return this.control(controlConfig);
          }
        }
      }, {}));
      $__export("FormBuilder", FormBuilder);
      $__export("FormBuilder", FormBuilder = __decorate([Injectable(), __metadata('design:paramtypes', [])], FormBuilder));
    }
  };
});

System.register("angular2/src/di/metadata", ["angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/metadata";
  var __decorate,
      __metadata,
      CONST,
      CONST_EXPR,
      stringify,
      isBlank,
      InjectMetadata,
      OptionalMetadata,
      DependencyMetadata,
      InjectableMetadata,
      VisibilityMetadata,
      SelfMetadata,
      AncestorMetadata,
      UnboundedMetadata,
      DEFAULT_VISIBILITY;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
      CONST_EXPR = $__m.CONST_EXPR;
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      InjectMetadata = (($traceurRuntime.createClass)(function(token) {
        this.token = token;
      }, {toString: function() {
          return ("@Inject(" + stringify(this.token) + ")");
        }}, {}));
      $__export("InjectMetadata", InjectMetadata);
      $__export("InjectMetadata", InjectMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], InjectMetadata));
      OptionalMetadata = (($traceurRuntime.createClass)(function() {}, {toString: function() {
          return "@Optional()";
        }}, {}));
      $__export("OptionalMetadata", OptionalMetadata);
      $__export("OptionalMetadata", OptionalMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], OptionalMetadata));
      DependencyMetadata = (($traceurRuntime.createClass)(function() {}, {get token() {
          return null;
        }}, {}));
      $__export("DependencyMetadata", DependencyMetadata);
      $__export("DependencyMetadata", DependencyMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], DependencyMetadata));
      InjectableMetadata = (($traceurRuntime.createClass)(function() {}, {}, {}));
      $__export("InjectableMetadata", InjectableMetadata);
      $__export("InjectableMetadata", InjectableMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], InjectableMetadata));
      VisibilityMetadata = (($traceurRuntime.createClass)(function(crossBoundaries, _includeSelf) {
        this.crossBoundaries = crossBoundaries;
        this._includeSelf = _includeSelf;
      }, {
        get includeSelf() {
          return isBlank(this._includeSelf) ? false : this._includeSelf;
        },
        toString: function() {
          return ("@Visibility(crossBoundaries: " + this.crossBoundaries + ", includeSelf: " + this.includeSelf + "})");
        }
      }, {}));
      $__export("VisibilityMetadata", VisibilityMetadata);
      $__export("VisibilityMetadata", VisibilityMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Boolean, Boolean])], VisibilityMetadata));
      SelfMetadata = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this, false, true);
        }
        return ($traceurRuntime.createClass)($__0, {toString: function() {
            return "@Self()";
          }}, {}, $__super);
      }(VisibilityMetadata));
      $__export("SelfMetadata", SelfMetadata);
      $__export("SelfMetadata", SelfMetadata = __decorate([CONST(), __metadata('design:paramtypes', [])], SelfMetadata));
      AncestorMetadata = (function($__super) {
        function $__0() {
          var self = (arguments[0] !== (void 0) ? arguments[0] : {}).self;
          $traceurRuntime.superConstructor($__0).call(this, false, self);
        }
        return ($traceurRuntime.createClass)($__0, {toString: function() {
            return ("@Ancestor(self: " + this.includeSelf + "})");
          }}, {}, $__super);
      }(VisibilityMetadata));
      $__export("AncestorMetadata", AncestorMetadata);
      $__export("AncestorMetadata", AncestorMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], AncestorMetadata));
      UnboundedMetadata = (function($__super) {
        function $__0() {
          var self = (arguments[0] !== (void 0) ? arguments[0] : {}).self;
          $traceurRuntime.superConstructor($__0).call(this, true, self);
        }
        return ($traceurRuntime.createClass)($__0, {toString: function() {
            return ("@Unbounded(self: " + this.includeSelf + "})");
          }}, {}, $__super);
      }(VisibilityMetadata));
      $__export("UnboundedMetadata", UnboundedMetadata);
      $__export("UnboundedMetadata", UnboundedMetadata = __decorate([CONST(), __metadata('design:paramtypes', [Object])], UnboundedMetadata));
      DEFAULT_VISIBILITY = CONST_EXPR(new UnboundedMetadata({self: true}));
      $__export("DEFAULT_VISIBILITY", DEFAULT_VISIBILITY);
    }
  };
});

System.register("angular2/src/di/decorators", ["angular2/src/di/metadata", "angular2/src/util/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/decorators";
  var InjectMetadata,
      OptionalMetadata,
      InjectableMetadata,
      SelfMetadata,
      AncestorMetadata,
      UnboundedMetadata,
      makeDecorator,
      makeParamDecorator,
      Inject,
      Optional,
      Injectable,
      Self,
      Ancestor,
      Unbounded;
  return {
    setters: [function($__m) {
      InjectMetadata = $__m.InjectMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      InjectableMetadata = $__m.InjectableMetadata;
      SelfMetadata = $__m.SelfMetadata;
      AncestorMetadata = $__m.AncestorMetadata;
      UnboundedMetadata = $__m.UnboundedMetadata;
    }, function($__m) {
      makeDecorator = $__m.makeDecorator;
      makeParamDecorator = $__m.makeParamDecorator;
    }],
    execute: function() {
      Inject = makeParamDecorator(InjectMetadata);
      $__export("Inject", Inject);
      Optional = makeParamDecorator(OptionalMetadata);
      $__export("Optional", Optional);
      Injectable = makeDecorator(InjectableMetadata);
      $__export("Injectable", Injectable);
      Self = makeParamDecorator(SelfMetadata);
      $__export("Self", Self);
      Ancestor = makeParamDecorator(AncestorMetadata);
      $__export("Ancestor", Ancestor);
      Unbounded = makeParamDecorator(UnboundedMetadata);
      $__export("Unbounded", Unbounded);
    }
  };
});

System.register("angular2/src/reflection/reflection", ["angular2/src/reflection/reflector", "angular2/src/reflection/reflection_capabilities"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/reflection/reflection";
  var Reflector,
      ReflectionCapabilities,
      reflector;
  return {
    setters: [function($__m) {
      Reflector = $__m.Reflector;
      $__export("Reflector", $__m.Reflector);
      $__export("ReflectionInfo", $__m.ReflectionInfo);
    }, function($__m) {
      ReflectionCapabilities = $__m.ReflectionCapabilities;
    }],
    execute: function() {
      reflector = new Reflector(new ReflectionCapabilities());
      $__export("reflector", reflector);
    }
  };
});

System.register("angular2/src/di/key", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/di/type_literal", "angular2/src/di/forward_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/key";
  var MapWrapper,
      stringify,
      isBlank,
      BaseException,
      TypeLiteral,
      resolveForwardRef,
      Key,
      KeyRegistry,
      _globalKeyRegistry;
  return {
    setters: [function($__m) {
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      TypeLiteral = $__m.TypeLiteral;
      $__export("TypeLiteral", $__m.TypeLiteral);
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      Key = (function() {
        function Key(token, id) {
          this.token = token;
          this.id = id;
          if (isBlank(token)) {
            throw new BaseException('Token must be defined!');
          }
        }
        return ($traceurRuntime.createClass)(Key, {get displayName() {
            return stringify(this.token);
          }}, {
          get: function(token) {
            return _globalKeyRegistry.get(resolveForwardRef(token));
          },
          get numberOfKeys() {
            return _globalKeyRegistry.numberOfKeys;
          }
        });
      }());
      $__export("Key", Key);
      KeyRegistry = (function() {
        function KeyRegistry() {
          this._allKeys = new Map();
        }
        return ($traceurRuntime.createClass)(KeyRegistry, {
          get: function(token) {
            if (token instanceof Key)
              return token;
            var theToken = token;
            if (token instanceof TypeLiteral) {
              theToken = token.type;
            }
            token = theToken;
            if (this._allKeys.has(token)) {
              return this._allKeys.get(token);
            }
            var newKey = new Key(token, Key.numberOfKeys);
            this._allKeys.set(token, newKey);
            return newKey;
          },
          get numberOfKeys() {
            return MapWrapper.size(this._allKeys);
          }
        }, {});
      }());
      $__export("KeyRegistry", KeyRegistry);
      _globalKeyRegistry = new KeyRegistry();
    }
  };
});

System.register("angular2/src/dom/browser_adapter", ["angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/dom/generic_browser_adapter"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/dom/browser_adapter";
  var ListWrapper,
      isBlank,
      isPresent,
      global,
      setRootDomAdapter,
      GenericBrowserDomAdapter,
      _attrToPropMap,
      DOM_KEY_LOCATION_NUMPAD,
      _keyMap,
      _chromeNumKeyPadMap,
      BrowserDomAdapter,
      baseElement,
      urlParsingNode;
  function getBaseElementHref() {
    if (isBlank(baseElement)) {
      baseElement = document.querySelector('base');
      if (isBlank(baseElement)) {
        return null;
      }
    }
    return baseElement.attr('href');
  }
  function relativePath(url) {
    if (isBlank(urlParsingNode)) {
      urlParsingNode = document.createElement("a");
    }
    urlParsingNode.setAttribute('href', url);
    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      global = $__m.global;
    }, function($__m) {
      setRootDomAdapter = $__m.setRootDomAdapter;
    }, function($__m) {
      GenericBrowserDomAdapter = $__m.GenericBrowserDomAdapter;
    }],
    execute: function() {
      _attrToPropMap = {
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex'
      };
      DOM_KEY_LOCATION_NUMPAD = 3;
      _keyMap = {
        '\b': 'Backspace',
        '\t': 'Tab',
        '\x7F': 'Delete',
        '\x1B': 'Escape',
        'Del': 'Delete',
        'Esc': 'Escape',
        'Left': 'ArrowLeft',
        'Right': 'ArrowRight',
        'Up': 'ArrowUp',
        'Down': 'ArrowDown',
        'Menu': 'ContextMenu',
        'Scroll': 'ScrollLock',
        'Win': 'OS'
      };
      _chromeNumKeyPadMap = {
        'A': '1',
        'B': '2',
        'C': '3',
        'D': '4',
        'E': '5',
        'F': '6',
        'G': '7',
        'H': '8',
        'I': '9',
        'J': '*',
        'K': '+',
        'M': '-',
        'N': '.',
        'O': '/',
        '\x60': '0',
        '\x90': 'NumLock'
      };
      BrowserDomAdapter = (function($__super) {
        function BrowserDomAdapter() {
          $traceurRuntime.superConstructor(BrowserDomAdapter).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)(BrowserDomAdapter, {
          hasProperty: function(element, name) {
            return name in element;
          },
          setProperty: function(el, name, value) {
            el[name] = value;
          },
          getProperty: function(el, name) {
            return el[name];
          },
          invoke: function(el, methodName, args) {
            el[methodName].apply(el, args);
          },
          logError: function(error) {
            window.console.error(error);
          },
          log: function(error) {
            window.console.log(error);
          },
          logGroup: function(error) {
            if (window.console.group) {
              window.console.group(error);
            } else {
              window.console.log(error);
            }
          },
          logGroupEnd: function() {
            if (window.console.groupEnd) {
              window.console.groupEnd();
            }
          },
          get attrToPropMap() {
            return _attrToPropMap;
          },
          query: function(selector) {
            return document.querySelector(selector);
          },
          querySelector: function(el, selector) {
            return el.querySelector(selector);
          },
          querySelectorAll: function(el, selector) {
            return el.querySelectorAll(selector);
          },
          on: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
          },
          onAndCancel: function(el, evt, listener) {
            el.addEventListener(evt, listener, false);
            return (function() {
              el.removeEventListener(evt, listener, false);
            });
          },
          dispatchEvent: function(el, evt) {
            el.dispatchEvent(evt);
          },
          createMouseEvent: function(eventType) {
            var evt = document.createEvent('MouseEvent');
            evt.initEvent(eventType, true, true);
            return evt;
          },
          createEvent: function(eventType) {
            var evt = document.createEvent('Event');
            evt.initEvent(eventType, true, true);
            return evt;
          },
          preventDefault: function(evt) {
            evt.preventDefault();
            evt.returnValue = false;
          },
          getInnerHTML: function(el) {
            return el.innerHTML;
          },
          getOuterHTML: function(el) {
            return el.outerHTML;
          },
          nodeName: function(node) {
            return node.nodeName;
          },
          nodeValue: function(node) {
            return node.nodeValue;
          },
          type: function(node) {
            return node.type;
          },
          content: function(node) {
            if (this.hasProperty(node, "content")) {
              return node.content;
            } else {
              return node;
            }
          },
          firstChild: function(el) {
            return el.firstChild;
          },
          nextSibling: function(el) {
            return el.nextSibling;
          },
          parentElement: function(el) {
            return el.parentElement;
          },
          childNodes: function(el) {
            return el.childNodes;
          },
          childNodesAsList: function(el) {
            var childNodes = el.childNodes;
            var res = ListWrapper.createFixedSize(childNodes.length);
            for (var i = 0; i < childNodes.length; i++) {
              res[i] = childNodes[i];
            }
            return res;
          },
          clearNodes: function(el) {
            while (el.firstChild) {
              el.firstChild.remove();
            }
          },
          appendChild: function(el, node) {
            el.appendChild(node);
          },
          removeChild: function(el, node) {
            el.removeChild(node);
          },
          replaceChild: function(el, newChild, oldChild) {
            el.replaceChild(newChild, oldChild);
          },
          remove: function(node) {
            node.remove();
            return node;
          },
          insertBefore: function(el, node) {
            el.parentNode.insertBefore(node, el);
          },
          insertAllBefore: function(el, nodes) {
            ListWrapper.forEach(nodes, (function(n) {
              el.parentNode.insertBefore(n, el);
            }));
          },
          insertAfter: function(el, node) {
            el.parentNode.insertBefore(node, el.nextSibling);
          },
          setInnerHTML: function(el, value) {
            el.innerHTML = value;
          },
          getText: function(el) {
            return el.textContent;
          },
          setText: function(el, value) {
            el.textContent = value;
          },
          getValue: function(el) {
            return el.value;
          },
          setValue: function(el, value) {
            el.value = value;
          },
          getChecked: function(el) {
            return el.checked;
          },
          setChecked: function(el, value) {
            el.checked = value;
          },
          createTemplate: function(html) {
            var t = document.createElement('template');
            t.innerHTML = html;
            return t;
          },
          createElement: function(tagName) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createElement(tagName);
          },
          createTextNode: function(text) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            return doc.createTextNode(text);
          },
          createScriptTag: function(attrName, attrValue) {
            var doc = arguments[2] !== (void 0) ? arguments[2] : document;
            var el = doc.createElement('SCRIPT');
            el.setAttribute(attrName, attrValue);
            return el;
          },
          createStyleElement: function(css) {
            var doc = arguments[1] !== (void 0) ? arguments[1] : document;
            var style = doc.createElement('style');
            this.appendChild(style, this.createTextNode(css));
            return style;
          },
          createShadowRoot: function(el) {
            return el.createShadowRoot();
          },
          getShadowRoot: function(el) {
            return el.shadowRoot;
          },
          getHost: function(el) {
            return el.host;
          },
          clone: function(node) {
            return node.cloneNode(true);
          },
          getElementsByClassName: function(element, name) {
            return element.getElementsByClassName(name);
          },
          getElementsByTagName: function(element, name) {
            return element.getElementsByTagName(name);
          },
          classList: function(element) {
            return Array.prototype.slice.call(element.classList, 0);
          },
          addClass: function(element, classname) {
            element.classList.add(classname);
          },
          removeClass: function(element, classname) {
            element.classList.remove(classname);
          },
          hasClass: function(element, classname) {
            return element.classList.contains(classname);
          },
          setStyle: function(element, stylename, stylevalue) {
            element.style[stylename] = stylevalue;
          },
          removeStyle: function(element, stylename) {
            element.style[stylename] = null;
          },
          getStyle: function(element, stylename) {
            return element.style[stylename];
          },
          tagName: function(element) {
            return element.tagName;
          },
          attributeMap: function(element) {
            var res = new Map();
            var elAttrs = element.attributes;
            for (var i = 0; i < elAttrs.length; i++) {
              var attrib = elAttrs[i];
              res.set(attrib.name, attrib.value);
            }
            return res;
          },
          hasAttribute: function(element, attribute) {
            return element.hasAttribute(attribute);
          },
          getAttribute: function(element, attribute) {
            return element.getAttribute(attribute);
          },
          setAttribute: function(element, name, value) {
            element.setAttribute(name, value);
          },
          removeAttribute: function(element, attribute) {
            element.removeAttribute(attribute);
          },
          templateAwareRoot: function(el) {
            return this.isTemplateElement(el) ? this.content(el) : el;
          },
          createHtmlDocument: function() {
            return document.implementation.createHTMLDocument('fakeTitle');
          },
          defaultDoc: function() {
            return document;
          },
          getBoundingClientRect: function(el) {
            try {
              return el.getBoundingClientRect();
            } catch (e) {
              return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
              };
            }
          },
          getTitle: function() {
            return document.title;
          },
          setTitle: function(newTitle) {
            document.title = newTitle || '';
          },
          elementMatches: function(n, selector) {
            return n instanceof HTMLElement && n.matches ? n.matches(selector) : n.msMatchesSelector(selector);
          },
          isTemplateElement: function(el) {
            return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
          },
          isTextNode: function(node) {
            return node.nodeType === Node.TEXT_NODE;
          },
          isCommentNode: function(node) {
            return node.nodeType === Node.COMMENT_NODE;
          },
          isElementNode: function(node) {
            return node.nodeType === Node.ELEMENT_NODE;
          },
          hasShadowRoot: function(node) {
            return node instanceof HTMLElement && isPresent(node.shadowRoot);
          },
          isShadowRoot: function(node) {
            return node instanceof DocumentFragment;
          },
          importIntoDoc: function(node) {
            var toImport = node;
            if (this.isTemplateElement(node)) {
              toImport = this.content(node);
            }
            return document.importNode(toImport, true);
          },
          isPageRule: function(rule) {
            return rule.type === CSSRule.PAGE_RULE;
          },
          isStyleRule: function(rule) {
            return rule.type === CSSRule.STYLE_RULE;
          },
          isMediaRule: function(rule) {
            return rule.type === CSSRule.MEDIA_RULE;
          },
          isKeyframesRule: function(rule) {
            return rule.type === CSSRule.KEYFRAMES_RULE;
          },
          getHref: function(el) {
            return el.href;
          },
          getEventKey: function(event) {
            var key = event.key;
            if (isBlank(key)) {
              key = event.keyIdentifier;
              if (isBlank(key)) {
                return 'Unidentified';
              }
              if (key.startsWith('U+')) {
                key = String.fromCharCode(parseInt(key.substring(2), 16));
                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                  key = _chromeNumKeyPadMap[key];
                }
              }
            }
            if (_keyMap.hasOwnProperty(key)) {
              key = _keyMap[key];
            }
            return key;
          },
          getGlobalEventTarget: function(target) {
            if (target == "window") {
              return window;
            } else if (target == "document") {
              return document;
            } else if (target == "body") {
              return document.body;
            }
          },
          getHistory: function() {
            return window.history;
          },
          getLocation: function() {
            return window.location;
          },
          getBaseHref: function() {
            var href = getBaseElementHref();
            if (isBlank(href)) {
              return null;
            }
            return relativePath(href);
          },
          getUserAgent: function() {
            return window.navigator.userAgent;
          },
          setData: function(element, name, value) {
            element.dataset[name] = value;
          },
          getData: function(element, name) {
            return element.dataset[name];
          },
          setGlobalVar: function(name, value) {
            global[name] = value;
          }
        }, {makeCurrent: function() {
            setRootDomAdapter(new BrowserDomAdapter());
          }}, $__super);
      }(GenericBrowserDomAdapter));
      $__export("BrowserDomAdapter", BrowserDomAdapter);
      baseElement = null;
      urlParsingNode = null;
    }
  };
});

System.register("angular2/src/facade/async", ["angular2/src/facade/lang", "rx"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/facade/async";
  var global,
      Rx,
      Promise,
      PromiseWrapper,
      TimerWrapper,
      ObservableWrapper,
      Observable,
      EventEmitter;
  return {
    setters: [function($__m) {
      global = $__m.global;
    }, function($__m) {
      Rx = $__m;
    }],
    execute: function() {
      Promise = global.Promise;
      $__export("Promise", Promise);
      PromiseWrapper = (function() {
        function PromiseWrapper() {}
        return ($traceurRuntime.createClass)(PromiseWrapper, {}, {
          resolve: function(obj) {
            return Promise.resolve(obj);
          },
          reject: function(obj, _) {
            return Promise.reject(obj);
          },
          catchError: function(promise, onError) {
            return promise.catch(onError);
          },
          all: function(promises) {
            if (promises.length == 0)
              return Promise.resolve([]);
            return Promise.all(promises);
          },
          then: function(promise, success, rejection) {
            return promise.then(success, rejection);
          },
          wrap: function(computation) {
            return new Promise((function(res, rej) {
              try {
                res(computation());
              } catch (e) {
                rej(e);
              }
            }));
          },
          completer: function() {
            var resolve;
            var reject;
            var p = new Promise(function(res, rej) {
              resolve = res;
              reject = rej;
            });
            return {
              promise: p,
              resolve: resolve,
              reject: reject
            };
          }
        });
      }());
      $__export("PromiseWrapper", PromiseWrapper);
      TimerWrapper = (function() {
        function TimerWrapper() {}
        return ($traceurRuntime.createClass)(TimerWrapper, {}, {
          setTimeout: function(fn, millis) {
            return global.setTimeout(fn, millis);
          },
          clearTimeout: function(id) {
            global.clearTimeout(id);
          },
          setInterval: function(fn, millis) {
            return global.setInterval(fn, millis);
          },
          clearInterval: function(id) {
            global.clearInterval(id);
          }
        });
      }());
      $__export("TimerWrapper", TimerWrapper);
      ObservableWrapper = (function() {
        function ObservableWrapper() {}
        return ($traceurRuntime.createClass)(ObservableWrapper, {}, {
          subscribe: function(emitter, onNext) {
            var onThrow = arguments[2] !== (void 0) ? arguments[2] : null;
            var onReturn = arguments[3] !== (void 0) ? arguments[3] : null;
            return emitter.observer({
              next: onNext,
              throw: onThrow,
              return: onReturn
            });
          },
          isObservable: function(obs) {
            return obs instanceof Observable;
          },
          dispose: function(subscription) {
            subscription.dispose();
          },
          callNext: function(emitter, value) {
            emitter.next(value);
          },
          callThrow: function(emitter, error) {
            emitter.throw(error);
          },
          callReturn: function(emitter) {
            emitter.return(null);
          }
        });
      }());
      $__export("ObservableWrapper", ObservableWrapper);
      Observable = (function() {
        function Observable() {}
        return ($traceurRuntime.createClass)(Observable, {observer: function(generator) {
            return null;
          }}, {});
      }());
      $__export("Observable", Observable);
      EventEmitter = (function($__super) {
        function EventEmitter() {
          $traceurRuntime.superConstructor(EventEmitter).call(this);
          if (Rx.hasOwnProperty('default')) {
            this._subject = new Rx.default.Rx.Subject();
            this._immediateScheduler = Rx.default.Rx.Scheduler.immediate;
          } else {
            this._subject = new Rx.Subject();
            this._immediateScheduler = Rx.Scheduler.immediate;
          }
        }
        return ($traceurRuntime.createClass)(EventEmitter, {
          observer: function(generator) {
            return this._subject.observeOn(this._immediateScheduler).subscribe((function(value) {
              setTimeout((function() {
                return generator.next(value);
              }));
            }), (function(error) {
              return generator.throw ? generator.throw(error) : null;
            }), (function() {
              return generator.return ? generator.return() : null;
            }));
          },
          toRx: function() {
            return this._subject;
          },
          next: function(value) {
            this._subject.onNext(value);
          },
          throw: function(error) {
            this._subject.onError(error);
          },
          return: function(value) {
            this._subject.onCompleted();
          }
        }, {}, $__super);
      }(Observable));
      $__export("EventEmitter", EventEmitter);
    }
  };
});

System.register("angular2/src/change_detection/change_detector_ref", ["angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detector_ref";
  var DETACHED,
      CHECK_ALWAYS,
      ChangeDetectorRef;
  return {
    setters: [function($__m) {
      DETACHED = $__m.DETACHED;
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
    }],
    execute: function() {
      ChangeDetectorRef = (function() {
        function ChangeDetectorRef(_cd) {
          this._cd = _cd;
        }
        return ($traceurRuntime.createClass)(ChangeDetectorRef, {
          requestCheck: function() {
            this._cd.markPathToRootAsCheckOnce();
          },
          detach: function() {
            this._cd.mode = DETACHED;
          },
          reattach: function() {
            this._cd.mode = CHECK_ALWAYS;
            this.requestCheck();
          }
        }, {});
      }());
      $__export("ChangeDetectorRef", ChangeDetectorRef);
    }
  };
});

System.register("angular2/src/change_detection/change_detection_util", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/pipes/pipe", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_util";
  var CONST_EXPR,
      isPresent,
      isBlank,
      BaseException,
      StringMapWrapper,
      DehydratedException,
      ExpressionChangedAfterItHasBeenCheckedException,
      WrappedValue,
      CHECK_ALWAYS,
      CHECK_ONCE,
      ON_PUSH,
      SimpleChange,
      _simpleChangesIndex,
      _simpleChanges,
      ChangeDetectionUtil;
  function _simpleChange(previousValue, currentValue) {
    var index = _simpleChangesIndex++ % 20;
    var s = _simpleChanges[index];
    s.previousValue = previousValue;
    s.currentValue = currentValue;
    return s;
  }
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      DehydratedException = $__m.DehydratedException;
      ExpressionChangedAfterItHasBeenCheckedException = $__m.ExpressionChangedAfterItHasBeenCheckedException;
    }, function($__m) {
      WrappedValue = $__m.WrappedValue;
    }, function($__m) {
      CHECK_ALWAYS = $__m.CHECK_ALWAYS;
      CHECK_ONCE = $__m.CHECK_ONCE;
      ON_PUSH = $__m.ON_PUSH;
    }],
    execute: function() {
      SimpleChange = (function() {
        function SimpleChange(previousValue, currentValue) {
          this.previousValue = previousValue;
          this.currentValue = currentValue;
        }
        return ($traceurRuntime.createClass)(SimpleChange, {isFirstChange: function() {
            return this.previousValue === ChangeDetectionUtil.uninitialized;
          }}, {});
      }());
      $__export("SimpleChange", SimpleChange);
      _simpleChangesIndex = 0;
      _simpleChanges = [new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null), new SimpleChange(null, null)];
      ChangeDetectionUtil = (function() {
        function ChangeDetectionUtil() {}
        return ($traceurRuntime.createClass)(ChangeDetectionUtil, {}, {
          arrayFn0: function() {
            return [];
          },
          arrayFn1: function(a1) {
            return [a1];
          },
          arrayFn2: function(a1, a2) {
            return [a1, a2];
          },
          arrayFn3: function(a1, a2, a3) {
            return [a1, a2, a3];
          },
          arrayFn4: function(a1, a2, a3, a4) {
            return [a1, a2, a3, a4];
          },
          arrayFn5: function(a1, a2, a3, a4, a5) {
            return [a1, a2, a3, a4, a5];
          },
          arrayFn6: function(a1, a2, a3, a4, a5, a6) {
            return [a1, a2, a3, a4, a5, a6];
          },
          arrayFn7: function(a1, a2, a3, a4, a5, a6, a7) {
            return [a1, a2, a3, a4, a5, a6, a7];
          },
          arrayFn8: function(a1, a2, a3, a4, a5, a6, a7, a8) {
            return [a1, a2, a3, a4, a5, a6, a7, a8];
          },
          arrayFn9: function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
          },
          operation_negate: function(value) {
            return !value;
          },
          operation_add: function(left, right) {
            return left + right;
          },
          operation_subtract: function(left, right) {
            return left - right;
          },
          operation_multiply: function(left, right) {
            return left * right;
          },
          operation_divide: function(left, right) {
            return left / right;
          },
          operation_remainder: function(left, right) {
            return left % right;
          },
          operation_equals: function(left, right) {
            return left == right;
          },
          operation_not_equals: function(left, right) {
            return left != right;
          },
          operation_identical: function(left, right) {
            return left === right;
          },
          operation_not_identical: function(left, right) {
            return left !== right;
          },
          operation_less_then: function(left, right) {
            return left < right;
          },
          operation_greater_then: function(left, right) {
            return left > right;
          },
          operation_less_or_equals_then: function(left, right) {
            return left <= right;
          },
          operation_greater_or_equals_then: function(left, right) {
            return left >= right;
          },
          operation_logical_and: function(left, right) {
            return left && right;
          },
          operation_logical_or: function(left, right) {
            return left || right;
          },
          cond: function(cond, trueVal, falseVal) {
            return cond ? trueVal : falseVal;
          },
          mapFn: function(keys) {
            function buildMap(values) {
              var res = StringMapWrapper.create();
              for (var i = 0; i < keys.length; ++i) {
                StringMapWrapper.set(res, keys[i], values[i]);
              }
              return res;
            }
            switch (keys.length) {
              case 0:
                return (function() {
                  return [];
                });
              case 1:
                return (function(a1) {
                  return buildMap([a1]);
                });
              case 2:
                return (function(a1, a2) {
                  return buildMap([a1, a2]);
                });
              case 3:
                return (function(a1, a2, a3) {
                  return buildMap([a1, a2, a3]);
                });
              case 4:
                return (function(a1, a2, a3, a4) {
                  return buildMap([a1, a2, a3, a4]);
                });
              case 5:
                return (function(a1, a2, a3, a4, a5) {
                  return buildMap([a1, a2, a3, a4, a5]);
                });
              case 6:
                return (function(a1, a2, a3, a4, a5, a6) {
                  return buildMap([a1, a2, a3, a4, a5, a6]);
                });
              case 7:
                return (function(a1, a2, a3, a4, a5, a6, a7) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7]);
                });
              case 8:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]);
                });
              case 9:
                return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                  return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
                });
              default:
                throw new BaseException("Does not support literal maps with more than 9 elements");
            }
          },
          keyedAccess: function(obj, args) {
            return obj[args[0]];
          },
          unwrapValue: function(value) {
            if (value instanceof WrappedValue) {
              return value.wrapped;
            } else {
              return value;
            }
          },
          throwOnChange: function(proto, change) {
            throw new ExpressionChangedAfterItHasBeenCheckedException(proto, change, null);
          },
          throwDehydrated: function() {
            throw new DehydratedException();
          },
          changeDetectionMode: function(strategy) {
            return strategy == ON_PUSH ? CHECK_ONCE : CHECK_ALWAYS;
          },
          simpleChange: function(previousValue, currentValue) {
            return _simpleChange(previousValue, currentValue);
          },
          addChange: function(changes, propertyName, change) {
            if (isBlank(changes)) {
              changes = {};
            }
            changes[propertyName] = change;
            return changes;
          },
          isValueBlank: function(value) {
            return isBlank(value);
          },
          s: function(value) {
            return isPresent(value) ? ("" + value) : '';
          }
        });
      }());
      $__export("ChangeDetectionUtil", ChangeDetectionUtil);
      ChangeDetectionUtil.uninitialized = CONST_EXPR(new Object());
    }
  };
});

System.register("angular2/src/change_detection/proto_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/coalesce", "angular2/src/change_detection/proto_record"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/proto_change_detector";
  var BaseException,
      isPresent,
      isString,
      ListWrapper,
      ImplicitReceiver,
      ChangeDetectionUtil,
      DynamicChangeDetector,
      DirectiveIndex,
      coalesce,
      ProtoRecord,
      RecordType,
      DynamicProtoChangeDetector,
      ProtoRecordBuilder,
      _ConvertAstIntoProtoRecords;
  function _arrayFn(length) {
    switch (length) {
      case 0:
        return ChangeDetectionUtil.arrayFn0;
      case 1:
        return ChangeDetectionUtil.arrayFn1;
      case 2:
        return ChangeDetectionUtil.arrayFn2;
      case 3:
        return ChangeDetectionUtil.arrayFn3;
      case 4:
        return ChangeDetectionUtil.arrayFn4;
      case 5:
        return ChangeDetectionUtil.arrayFn5;
      case 6:
        return ChangeDetectionUtil.arrayFn6;
      case 7:
        return ChangeDetectionUtil.arrayFn7;
      case 8:
        return ChangeDetectionUtil.arrayFn8;
      case 9:
        return ChangeDetectionUtil.arrayFn9;
      default:
        throw new BaseException("Does not support literal maps with more than 9 elements");
    }
  }
  function _mapPrimitiveName(keys) {
    var stringifiedKeys = ListWrapper.join(ListWrapper.map(keys, (function(k) {
      return isString(k) ? ("\"" + k + "\"") : ("" + k);
    })), ", ");
    return ("mapFn([" + stringifiedKeys + "])");
  }
  function _operationToPrimitiveName(operation) {
    switch (operation) {
      case '+':
        return "operation_add";
      case '-':
        return "operation_subtract";
      case '*':
        return "operation_multiply";
      case '/':
        return "operation_divide";
      case '%':
        return "operation_remainder";
      case '==':
        return "operation_equals";
      case '!=':
        return "operation_not_equals";
      case '===':
        return "operation_identical";
      case '!==':
        return "operation_not_identical";
      case '<':
        return "operation_less_then";
      case '>':
        return "operation_greater_then";
      case '<=':
        return "operation_less_or_equals_then";
      case '>=':
        return "operation_greater_or_equals_then";
      case '&&':
        return "operation_logical_and";
      case '||':
        return "operation_logical_or";
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function _operationToFunction(operation) {
    switch (operation) {
      case '+':
        return ChangeDetectionUtil.operation_add;
      case '-':
        return ChangeDetectionUtil.operation_subtract;
      case '*':
        return ChangeDetectionUtil.operation_multiply;
      case '/':
        return ChangeDetectionUtil.operation_divide;
      case '%':
        return ChangeDetectionUtil.operation_remainder;
      case '==':
        return ChangeDetectionUtil.operation_equals;
      case '!=':
        return ChangeDetectionUtil.operation_not_equals;
      case '===':
        return ChangeDetectionUtil.operation_identical;
      case '!==':
        return ChangeDetectionUtil.operation_not_identical;
      case '<':
        return ChangeDetectionUtil.operation_less_then;
      case '>':
        return ChangeDetectionUtil.operation_greater_then;
      case '<=':
        return ChangeDetectionUtil.operation_less_or_equals_then;
      case '>=':
        return ChangeDetectionUtil.operation_greater_or_equals_then;
      case '&&':
        return ChangeDetectionUtil.operation_logical_and;
      case '||':
        return ChangeDetectionUtil.operation_logical_or;
      default:
        throw new BaseException(("Unsupported operation " + operation));
    }
  }
  function s(v) {
    return isPresent(v) ? ("" + v) : '';
  }
  function _interpolationFn(strings) {
    var length = strings.length;
    var c0 = length > 0 ? strings[0] : null;
    var c1 = length > 1 ? strings[1] : null;
    var c2 = length > 2 ? strings[2] : null;
    var c3 = length > 3 ? strings[3] : null;
    var c4 = length > 4 ? strings[4] : null;
    var c5 = length > 5 ? strings[5] : null;
    var c6 = length > 6 ? strings[6] : null;
    var c7 = length > 7 ? strings[7] : null;
    var c8 = length > 8 ? strings[8] : null;
    var c9 = length > 9 ? strings[9] : null;
    switch (length - 1) {
      case 1:
        return (function(a1) {
          return c0 + s(a1) + c1;
        });
      case 2:
        return (function(a1, a2) {
          return c0 + s(a1) + c1 + s(a2) + c2;
        });
      case 3:
        return (function(a1, a2, a3) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3;
        });
      case 4:
        return (function(a1, a2, a3, a4) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4;
        });
      case 5:
        return (function(a1, a2, a3, a4, a5) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
        });
      case 6:
        return (function(a1, a2, a3, a4, a5, a6) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
        });
      case 7:
        return (function(a1, a2, a3, a4, a5, a6, a7) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7;
        });
      case 8:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8;
        });
      case 9:
        return (function(a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) + c8 + s(a9) + c9;
        });
      default:
        throw new BaseException("Does not support more than 9 expressions");
    }
  }
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isPresent = $__m.isPresent;
      isString = $__m.isString;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ImplicitReceiver = $__m.ImplicitReceiver;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      DynamicChangeDetector = $__m.DynamicChangeDetector;
    }, function($__m) {
      DirectiveIndex = $__m.DirectiveIndex;
    }, function($__m) {
      coalesce = $__m.coalesce;
    }, function($__m) {
      ProtoRecord = $__m.ProtoRecord;
      RecordType = $__m.RecordType;
    }],
    execute: function() {
      DynamicProtoChangeDetector = (function() {
        function DynamicProtoChangeDetector(definition) {
          this.definition = definition;
          this._records = this._createRecords(definition);
        }
        return ($traceurRuntime.createClass)(DynamicProtoChangeDetector, {
          instantiate: function(dispatcher) {
            return new DynamicChangeDetector(this.definition.id, this.definition.strategy, dispatcher, this._records, this.definition.directiveRecords);
          },
          _createRecords: function(definition) {
            var recordBuilder = new ProtoRecordBuilder();
            ListWrapper.forEach(definition.bindingRecords, (function(b) {
              recordBuilder.add(b, definition.variableNames);
            }));
            return coalesce(recordBuilder.records);
          }
        }, {});
      }());
      $__export("DynamicProtoChangeDetector", DynamicProtoChangeDetector);
      ProtoRecordBuilder = (function() {
        function ProtoRecordBuilder() {
          this.records = [];
        }
        return ($traceurRuntime.createClass)(ProtoRecordBuilder, {
          add: function(b) {
            var variableNames = arguments[1] !== (void 0) ? arguments[1] : null;
            var oldLast = ListWrapper.last(this.records);
            if (isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
              oldLast.lastInDirective = false;
            }
            this._appendRecords(b, variableNames);
            var newLast = ListWrapper.last(this.records);
            if (isPresent(newLast) && newLast !== oldLast) {
              newLast.lastInBinding = true;
              newLast.lastInDirective = true;
            }
          },
          _appendRecords: function(b, variableNames) {
            if (b.isDirectiveLifecycle()) {
              this.records.push(new ProtoRecord(RecordType.DIRECTIVE_LIFECYCLE, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, null, false, false));
            } else {
              _ConvertAstIntoProtoRecords.append(this.records, b, variableNames);
            }
          }
        }, {});
      }());
      $__export("ProtoRecordBuilder", ProtoRecordBuilder);
      _ConvertAstIntoProtoRecords = (function() {
        function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _expressionAsString, _variableNames) {
          this._records = _records;
          this._bindingRecord = _bindingRecord;
          this._expressionAsString = _expressionAsString;
          this._variableNames = _variableNames;
        }
        return ($traceurRuntime.createClass)(_ConvertAstIntoProtoRecords, {
          visitImplicitReceiver: function(ast) {
            return this._bindingRecord.implicitReceiver;
          },
          visitInterpolation: function(ast) {
            var args = this._visitAll(ast.expressions);
            return this._addRecord(RecordType.INTERPOLATE, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
          },
          visitLiteralPrimitive: function(ast) {
            return this._addRecord(RecordType.CONST, "literal", ast.value, [], null, 0);
          },
          visitAccessMember: function(ast) {
            var receiver = ast.receiver.visit(this);
            if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name) && ast.receiver instanceof ImplicitReceiver) {
              return this._addRecord(RecordType.LOCAL, ast.name, ast.name, [], null, receiver);
            } else {
              return this._addRecord(RecordType.PROPERTY, ast.name, ast.getter, [], null, receiver);
            }
          },
          visitSafeAccessMember: function(ast) {
            var receiver = ast.receiver.visit(this);
            return this._addRecord(RecordType.SAFE_PROPERTY, ast.name, ast.getter, [], null, receiver);
          },
          visitMethodCall: function(ast) {
            var receiver = ast.receiver.visit(this);
            var args = this._visitAll(ast.args);
            if (isPresent(this._variableNames) && ListWrapper.contains(this._variableNames, ast.name)) {
              var target = this._addRecord(RecordType.LOCAL, ast.name, ast.name, [], null, receiver);
              return this._addRecord(RecordType.INVOKE_CLOSURE, "closure", null, args, null, target);
            } else {
              return this._addRecord(RecordType.INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
            }
          },
          visitSafeMethodCall: function(ast) {
            var receiver = ast.receiver.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.SAFE_INVOKE_METHOD, ast.name, ast.fn, args, null, receiver);
          },
          visitFunctionCall: function(ast) {
            var target = ast.target.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.INVOKE_CLOSURE, "closure", null, args, null, target);
          },
          visitLiteralArray: function(ast) {
            var primitiveName = ("arrayFn" + ast.expressions.length);
            return this._addRecord(RecordType.PRIMITIVE_OP, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
          },
          visitLiteralMap: function(ast) {
            return this._addRecord(RecordType.PRIMITIVE_OP, _mapPrimitiveName(ast.keys), ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
          },
          visitBinary: function(ast) {
            var left = ast.left.visit(this);
            var right = ast.right.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
          },
          visitPrefixNot: function(ast) {
            var exp = ast.expression.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, "operation_negate", ChangeDetectionUtil.operation_negate, [exp], null, 0);
          },
          visitConditional: function(ast) {
            var c = ast.condition.visit(this);
            var t = ast.trueExp.visit(this);
            var f = ast.falseExp.visit(this);
            return this._addRecord(RecordType.PRIMITIVE_OP, "cond", ChangeDetectionUtil.cond, [c, t, f], null, 0);
          },
          visitPipe: function(ast) {
            var value = ast.exp.visit(this);
            var args = this._visitAll(ast.args);
            return this._addRecord(RecordType.PIPE, ast.name, ast.name, args, null, value);
          },
          visitKeyedAccess: function(ast) {
            var obj = ast.obj.visit(this);
            var key = ast.key.visit(this);
            return this._addRecord(RecordType.KEYED_ACCESS, "keyedAccess", ChangeDetectionUtil.keyedAccess, [key], null, obj);
          },
          visitAssignment: function(ast) {
            throw new BaseException('Not supported');
          },
          visitChain: function(ast) {
            throw new BaseException('Not supported');
          },
          visitIf: function(ast) {
            throw new BaseException('Not supported');
          },
          _visitAll: function(asts) {
            var res = ListWrapper.createFixedSize(asts.length);
            for (var i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
            }
            return res;
          },
          _addRecord: function(type, name, funcOrValue, args, fixedArgs, context) {
            var selfIndex = this._records.length + 1;
            if (context instanceof DirectiveIndex) {
              this._records.push(new ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, this._expressionAsString, false, false));
            } else {
              this._records.push(new ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, this._expressionAsString, false, false));
            }
            return selfIndex;
          }
        }, {append: function(records, b, variableNames) {
            var c = new _ConvertAstIntoProtoRecords(records, b, b.ast.toString(), variableNames);
            b.ast.visit(c);
          }});
      }());
    }
  };
});

System.register("angular2/src/change_detection/pipes/limit_to_pipe", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/math"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/limit_to_pipe";
  var __decorate,
      __metadata,
      isBlank,
      isString,
      isArray,
      StringWrapper,
      BaseException,
      CONST,
      ListWrapper,
      Math,
      LimitToPipe,
      LimitToPipeFactory;
  return {
    setters: [function($__m) {
      isBlank = $__m.isBlank;
      isString = $__m.isString;
      isArray = $__m.isArray;
      StringWrapper = $__m.StringWrapper;
      BaseException = $__m.BaseException;
      CONST = $__m.CONST;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      Math = $__m.Math;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      LimitToPipe = (function() {
        function LimitToPipe() {}
        return ($traceurRuntime.createClass)(LimitToPipe, {
          supports: function(obj) {
            return LimitToPipe.supportsObj(obj);
          },
          transform: function(value) {
            var args = arguments[1] !== (void 0) ? arguments[1] : null;
            if (isBlank(args) || args.length == 0) {
              throw new BaseException('limitTo pipe requires one argument');
            }
            var limit = args[0];
            var left = 0,
                right = Math.min(limit, value.length);
            if (limit < 0) {
              left = Math.max(0, value.length + limit);
              right = value.length;
            }
            if (isString(value)) {
              return StringWrapper.substring(value, left, right);
            }
            return ListWrapper.slice(value, left, right);
          },
          onDestroy: function() {}
        }, {supportsObj: function(obj) {
            return isString(obj) || isArray(obj);
          }});
      }());
      $__export("LimitToPipe", LimitToPipe);
      LimitToPipeFactory = (($traceurRuntime.createClass)(function() {}, {
        supports: function(obj) {
          return LimitToPipe.supportsObj(obj);
        },
        create: function(cdRef) {
          return new LimitToPipe();
        }
      }, {}));
      $__export("LimitToPipeFactory", LimitToPipeFactory);
      $__export("LimitToPipeFactory", LimitToPipeFactory = __decorate([CONST(), __metadata('design:paramtypes', [])], LimitToPipeFactory));
    }
  };
});

System.register("angular2/src/change_detection/pipes/date_pipe", ["angular2/src/facade/lang", "angular2/src/facade/intl", "angular2/src/facade/collection", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/pipes/date_pipe";
  var __decorate,
      __metadata,
      isDate,
      isNumber,
      isPresent,
      DateWrapper,
      CONST,
      DateFormatter,
      StringMapWrapper,
      BasePipe,
      defaultLocale,
      DatePipe;
  return {
    setters: [function($__m) {
      isDate = $__m.isDate;
      isNumber = $__m.isNumber;
      isPresent = $__m.isPresent;
      DateWrapper = $__m.DateWrapper;
      CONST = $__m.CONST;
    }, function($__m) {
      DateFormatter = $__m.DateFormatter;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      BasePipe = $__m.BasePipe;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      defaultLocale = 'en-US';
      DatePipe = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {
          transform: function(value, args) {
            var pattern = isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';
            if (isNumber(value)) {
              value = DateWrapper.fromMillis(value);
            }
            if (StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
              pattern = StringMapWrapper.get(DatePipe._ALIASES, pattern);
            }
            return DateFormatter.format(value, defaultLocale, pattern);
          },
          supports: function(obj) {
            return isDate(obj) || isNumber(obj);
          },
          create: function(cdRef) {
            return this;
          }
        }, {}, $__super);
      }(BasePipe));
      $__export("DatePipe", DatePipe);
      DatePipe._ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
      };
      $__export("DatePipe", DatePipe = __decorate([CONST(), __metadata('design:paramtypes', [])], DatePipe));
    }
  };
});

System.register("angular2/src/core/compiler/view", ["angular2/src/facade/collection", "angular2/src/change_detection/change_detection", "angular2/src/core/compiler/element_binder", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view";
  var ListWrapper,
      MapWrapper,
      Map,
      StringMapWrapper,
      Locals,
      ElementBinder,
      isPresent,
      isBlank,
      BaseException,
      ViewRef,
      ProtoViewRef,
      internalView,
      AppProtoViewMergeMapping,
      AppViewContainer,
      AppView,
      DebugContext,
      _Context,
      EventEvaluationError,
      AppProtoView;
  function inverseIndexMapping(input, resultLength) {
    var result = ListWrapper.createGrowableSize(resultLength);
    for (var i = 0; i < input.length; i++) {
      var value = input[i];
      if (isPresent(value)) {
        result[input[i]] = i;
      }
    }
    return result;
  }
  function _localsToStringMap(locals) {
    var res = {};
    var c = locals;
    while (isPresent(c)) {
      res = StringMapWrapper.merge(res, MapWrapper.toStringMap(c.current));
      c = c.parent;
    }
    return res;
  }
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Map = $__m.Map;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      Locals = $__m.Locals;
    }, function($__m) {
      ElementBinder = $__m.ElementBinder;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ViewRef = $__m.ViewRef;
      ProtoViewRef = $__m.ProtoViewRef;
      internalView = $__m.internalView;
    }],
    execute: function() {
      AppProtoViewMergeMapping = (function() {
        function AppProtoViewMergeMapping(renderProtoViewMergeMapping) {
          this.renderProtoViewRef = renderProtoViewMergeMapping.mergedProtoViewRef;
          this.renderFragmentCount = renderProtoViewMergeMapping.fragmentCount;
          this.renderElementIndices = renderProtoViewMergeMapping.mappedElementIndices;
          this.renderInverseElementIndices = inverseIndexMapping(this.renderElementIndices, renderProtoViewMergeMapping.mappedElementCount);
          this.renderTextIndices = renderProtoViewMergeMapping.mappedTextIndices;
          this.hostElementIndicesByViewIndex = renderProtoViewMergeMapping.hostElementIndicesByViewIndex;
          this.nestedViewIndicesByElementIndex = inverseIndexMapping(this.hostElementIndicesByViewIndex, this.renderElementIndices.length);
          this.nestedViewCountByViewIndex = renderProtoViewMergeMapping.nestedViewCountByViewIndex;
        }
        return ($traceurRuntime.createClass)(AppProtoViewMergeMapping, {}, {});
      }());
      $__export("AppProtoViewMergeMapping", AppProtoViewMergeMapping);
      AppViewContainer = (function() {
        function AppViewContainer() {
          this.views = [];
        }
        return ($traceurRuntime.createClass)(AppViewContainer, {}, {});
      }());
      $__export("AppViewContainer", AppViewContainer);
      AppView = (function() {
        function AppView(renderer, proto, mainMergeMapping, viewOffset, elementOffset, textOffset, protoLocals, render, renderFragment) {
          this.renderer = renderer;
          this.proto = proto;
          this.mainMergeMapping = mainMergeMapping;
          this.viewOffset = viewOffset;
          this.elementOffset = elementOffset;
          this.textOffset = textOffset;
          this.render = render;
          this.renderFragment = renderFragment;
          this.views = null;
          this.elementInjectors = null;
          this.viewContainers = null;
          this.preBuiltObjects = null;
          this.changeDetector = null;
          this.context = null;
          this.ref = new ViewRef(this);
          this.locals = new Locals(null, MapWrapper.clone(protoLocals));
        }
        return ($traceurRuntime.createClass)(AppView, {
          init: function(changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers) {
            this.changeDetector = changeDetector;
            this.elementInjectors = elementInjectors;
            this.rootElementInjectors = rootElementInjectors;
            this.preBuiltObjects = preBuiltObjects;
            this.views = views;
            this.elementRefs = elementRefs;
            this.viewContainers = viewContainers;
          },
          setLocal: function(contextName, value) {
            if (!this.hydrated())
              throw new BaseException('Cannot set locals on dehydrated view.');
            if (!this.proto.variableBindings.has(contextName)) {
              return ;
            }
            var templateName = this.proto.variableBindings.get(contextName);
            this.locals.set(templateName, value);
          },
          hydrated: function() {
            return isPresent(this.context);
          },
          triggerEventHandlers: function(eventName, eventObj, boundElementIndex) {
            var locals = new Map();
            locals.set('$event', eventObj);
            this.dispatchEvent(boundElementIndex, eventName, locals);
          },
          notifyOnBinding: function(b, currentValue) {
            if (b.isTextNode()) {
              this.renderer.setText(this.render, this.mainMergeMapping.renderTextIndices[b.elementIndex + this.textOffset], currentValue);
            } else {
              var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
              if (b.isElementProperty()) {
                this.renderer.setElementProperty(elementRef, b.propertyName, currentValue);
              } else if (b.isElementAttribute()) {
                this.renderer.setElementAttribute(elementRef, b.propertyName, currentValue);
              } else if (b.isElementClass()) {
                this.renderer.setElementClass(elementRef, b.propertyName, currentValue);
              } else if (b.isElementStyle()) {
                var unit = isPresent(b.propertyUnit) ? b.propertyUnit : '';
                this.renderer.setElementStyle(elementRef, b.propertyName, ("" + currentValue + unit));
              } else {
                throw new BaseException('Unsupported directive record');
              }
            }
          },
          notifyOnAllChangesDone: function() {
            var eiCount = this.proto.elementBinders.length;
            var ei = this.elementInjectors;
            for (var i = eiCount - 1; i >= 0; i--) {
              if (isPresent(ei[i + this.elementOffset]))
                ei[i + this.elementOffset].onAllChangesDone();
            }
          },
          getDirectiveFor: function(directive) {
            var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
            return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
          },
          getNestedView: function(boundElementIndex) {
            var viewIndex = this.mainMergeMapping.nestedViewIndicesByElementIndex[boundElementIndex];
            return isPresent(viewIndex) ? this.views[viewIndex] : null;
          },
          getHostElement: function() {
            var boundElementIndex = this.mainMergeMapping.hostElementIndicesByViewIndex[this.viewOffset];
            return isPresent(boundElementIndex) ? this.elementRefs[boundElementIndex] : null;
          },
          getDebugContext: function(elementIndex, directiveIndex) {
            try {
              var offsettedIndex = this.elementOffset + elementIndex;
              var hasRefForIndex = offsettedIndex < this.elementRefs.length;
              var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
              var host = this.getHostElement();
              var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
              var element = isPresent(elementRef) ? elementRef.nativeElement : null;
              var componentElement = isPresent(host) ? host.nativeElement : null;
              var directive = isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
              var injector = isPresent(ei) ? ei.getInjector() : null;
              return new DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);
            } catch (e) {
              return null;
            }
          },
          getDetectorFor: function(directive) {
            var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
            return isPresent(childView) ? childView.changeDetector : null;
          },
          invokeElementMethod: function(elementIndex, methodName, args) {
            this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
          },
          dispatchRenderEvent: function(renderElementIndex, eventName, locals) {
            var elementRef = this.elementRefs[this.mainMergeMapping.renderInverseElementIndices[renderElementIndex]];
            var view = internalView(elementRef.parentView);
            return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
          },
          dispatchEvent: function(boundElementIndex, eventName, locals) {
            var $__0 = this;
            try {
              var allowDefaultBehavior = true;
              if (this.hydrated()) {
                var elBinder = this.proto.elementBinders[boundElementIndex - this.elementOffset];
                if (isBlank(elBinder.hostListeners))
                  return allowDefaultBehavior;
                var eventMap = elBinder.hostListeners[eventName];
                if (isBlank(eventMap))
                  return allowDefaultBehavior;
                MapWrapper.forEach(eventMap, (function(expr, directiveIndex) {
                  var context;
                  if (directiveIndex === -1) {
                    context = $__0.context;
                  } else {
                    context = $__0.elementInjectors[boundElementIndex].getDirectiveAtIndex(directiveIndex);
                  }
                  var result = expr.eval(context, new Locals($__0.locals, locals));
                  if (isPresent(result)) {
                    allowDefaultBehavior = allowDefaultBehavior && result == true;
                  }
                }));
              }
              return allowDefaultBehavior;
            } catch (e) {
              var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
              var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector) : null;
              throw new EventEvaluationError(eventName, e, e.stack, context);
            }
          }
        }, {});
      }());
      $__export("AppView", AppView);
      DebugContext = (function() {
        function DebugContext(element, componentElement, directive, context, locals, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.directive = directive;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(DebugContext, {}, {});
      }());
      $__export("DebugContext", DebugContext);
      _Context = (function() {
        function _Context(element, componentElement, context, locals, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      EventEvaluationError = (function($__super) {
        function EventEvaluationError(eventName, originalException, originalStack, context) {
          $traceurRuntime.superConstructor(EventEvaluationError).call(this, ("Error during evaluation of \"" + eventName + "\""), originalException, originalStack, context);
        }
        return ($traceurRuntime.createClass)(EventEvaluationError, {}, {}, $__super);
      }(BaseException));
      AppProtoView = (function() {
        function AppProtoView(type, isEmbeddedFragment, render, protoChangeDetector, variableBindings, variableLocations, textBindingCount) {
          var $__0 = this;
          this.type = type;
          this.isEmbeddedFragment = isEmbeddedFragment;
          this.render = render;
          this.protoChangeDetector = protoChangeDetector;
          this.variableBindings = variableBindings;
          this.variableLocations = variableLocations;
          this.textBindingCount = textBindingCount;
          this.elementBinders = [];
          this.protoLocals = new Map();
          this.ref = new ProtoViewRef(this);
          if (isPresent(variableBindings)) {
            MapWrapper.forEach(variableBindings, (function(templateName, _) {
              $__0.protoLocals.set(templateName, null);
            }));
          }
        }
        return ($traceurRuntime.createClass)(AppProtoView, {
          bindElement: function(parent, distanceToParent, protoElementInjector) {
            var componentDirective = arguments[3] !== (void 0) ? arguments[3] : null;
            var elBinder = new ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective);
            this.elementBinders.push(elBinder);
            return elBinder;
          },
          bindEvent: function(eventBindings, boundElementIndex) {
            var directiveIndex = arguments[2] !== (void 0) ? arguments[2] : -1;
            var elBinder = this.elementBinders[boundElementIndex];
            var events = elBinder.hostListeners;
            if (isBlank(events)) {
              events = StringMapWrapper.create();
              elBinder.hostListeners = events;
            }
            for (var i = 0; i < eventBindings.length; i++) {
              var eventBinding = eventBindings[i];
              var eventName = eventBinding.fullName;
              var event = StringMapWrapper.get(events, eventName);
              if (isBlank(event)) {
                event = new Map();
                StringMapWrapper.set(events, eventName, event);
              }
              event.set(directiveIndex, eventBinding.source);
            }
          }
        }, {});
      }());
      $__export("AppProtoView", AppProtoView);
    }
  };
});

System.register("angular2/src/core/compiler/view_manager_utils", ["angular2/di", "angular2/src/facade/collection", "angular2/src/core/compiler/element_injector", "angular2/src/facade/lang", "angular2/src/core/compiler/view", "angular2/src/core/compiler/view_ref", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager_utils";
  var __decorate,
      __metadata,
      Injector,
      Injectable,
      ListWrapper,
      MapWrapper,
      eli,
      isPresent,
      isBlank,
      viewModule,
      internalView,
      ElementRef,
      TemplateRef,
      ViewType,
      AppViewManagerUtils;
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      Injectable = $__m.Injectable;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      eli = $__m;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      viewModule = $__m;
    }, function($__m) {
      internalView = $__m.internalView;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      ViewType = $__m.ViewType;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewManagerUtils = (($traceurRuntime.createClass)(function() {}, {
        getComponentInstance: function(parentView, boundElementIndex) {
          var eli = parentView.elementInjectors[boundElementIndex];
          return eli.getComponent();
        },
        createView: function(mergedParentViewProto, renderViewWithFragments, viewManager, renderer) {
          var renderFragments = renderViewWithFragments.fragmentRefs;
          var renderView = renderViewWithFragments.viewRef;
          var elementCount = mergedParentViewProto.mergeMapping.renderElementIndices.length;
          var viewCount = mergedParentViewProto.mergeMapping.nestedViewCountByViewIndex[0] + 1;
          var elementRefs = ListWrapper.createFixedSize(elementCount);
          var viewContainers = ListWrapper.createFixedSize(elementCount);
          var preBuiltObjects = ListWrapper.createFixedSize(elementCount);
          var elementInjectors = ListWrapper.createFixedSize(elementCount);
          var views = ListWrapper.createFixedSize(viewCount);
          var elementOffset = 0;
          var textOffset = 0;
          var fragmentIdx = 0;
          for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
            var hostElementIndex = mergedParentViewProto.mergeMapping.hostElementIndicesByViewIndex[viewOffset];
            var parentView = isPresent(hostElementIndex) ? internalView(elementRefs[hostElementIndex].parentView) : null;
            var protoView = isPresent(hostElementIndex) ? parentView.proto.elementBinders[hostElementIndex - parentView.elementOffset].nestedProtoView : mergedParentViewProto;
            var renderFragment = null;
            if (viewOffset === 0 || protoView.type === ViewType.EMBEDDED) {
              renderFragment = renderFragments[fragmentIdx++];
            }
            var currentView = new viewModule.AppView(renderer, protoView, mergedParentViewProto.mergeMapping, viewOffset, elementOffset, textOffset, protoView.protoLocals, renderView, renderFragment);
            views[viewOffset] = currentView;
            var rootElementInjectors = [];
            for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
              var binder = protoView.elementBinders[binderIdx];
              var boundElementIndex = elementOffset + binderIdx;
              var elementInjector = null;
              var protoElementInjector = binder.protoElementInjector;
              if (isPresent(protoElementInjector)) {
                if (isPresent(protoElementInjector.parent)) {
                  var parentElementInjector = elementInjectors[elementOffset + protoElementInjector.parent.index];
                  elementInjector = protoElementInjector.instantiate(parentElementInjector);
                } else {
                  elementInjector = protoElementInjector.instantiate(null);
                  rootElementInjectors.push(elementInjector);
                }
              }
              elementInjectors[boundElementIndex] = elementInjector;
              var el = new ElementRef(currentView.ref, boundElementIndex, mergedParentViewProto.mergeMapping.renderElementIndices[boundElementIndex], renderer);
              elementRefs[el.boundElementIndex] = el;
              if (isPresent(elementInjector)) {
                var templateRef = binder.hasEmbeddedProtoView() ? new TemplateRef(el) : null;
                preBuiltObjects[boundElementIndex] = new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
              }
            }
            currentView.init(protoView.protoChangeDetector.instantiate(currentView), elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
            if (isPresent(parentView) && protoView.type === ViewType.COMPONENT) {
              parentView.changeDetector.addShadowDomChild(currentView.changeDetector);
            }
            elementOffset += protoView.elementBinders.length;
            textOffset += protoView.textBindingCount;
          }
          return views[0];
        },
        hydrateRootHostView: function(hostView, injector) {
          this._hydrateView(hostView, injector, null, new Object(), null);
        },
        attachViewInContainer: function(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view) {
          if (isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
          }
          parentView.changeDetector.addChild(view.changeDetector);
          var viewContainer = parentView.viewContainers[boundElementIndex];
          if (isBlank(viewContainer)) {
            viewContainer = new viewModule.AppViewContainer();
            parentView.viewContainers[boundElementIndex] = viewContainer;
          }
          ListWrapper.insert(viewContainer.views, atIndex, view);
          var sibling;
          if (atIndex == 0) {
            sibling = null;
          } else {
            sibling = ListWrapper.last(viewContainer.views[atIndex - 1].rootElementInjectors);
          }
          var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
          for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
            if (isPresent(elementInjector.parent)) {
              view.rootElementInjectors[i].linkAfter(elementInjector.parent, sibling);
            } else {
              contextView.rootElementInjectors.push(view.rootElementInjectors[i]);
            }
          }
        },
        detachViewInContainer: function(parentView, boundElementIndex, atIndex) {
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          view.changeDetector.remove();
          ListWrapper.removeAt(viewContainer.views, atIndex);
          for (var i = 0; i < view.rootElementInjectors.length; ++i) {
            var inj = view.rootElementInjectors[i];
            if (isPresent(inj.parent)) {
              inj.unlink();
            } else {
              var removeIdx = ListWrapper.indexOf(parentView.rootElementInjectors, inj);
              if (removeIdx >= 0) {
                ListWrapper.removeAt(parentView.rootElementInjectors, removeIdx);
              }
            }
          }
        },
        hydrateViewInContainer: function(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedBindings) {
          if (isBlank(contextView)) {
            contextView = parentView;
            contextBoundElementIndex = boundElementIndex;
          }
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
          var injector = isPresent(imperativelyCreatedBindings) ? Injector.fromResolvedBindings(imperativelyCreatedBindings) : null;
          this._hydrateView(view, injector, elementInjector.getHost(), contextView.context, contextView.locals);
        },
        _hydrateView: function(initView, imperativelyCreatedInjector, hostElementInjector, context, parentLocals) {
          var viewIdx = initView.viewOffset;
          var endViewOffset = viewIdx + initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx];
          while (viewIdx <= endViewOffset) {
            var currView = initView.views[viewIdx];
            var currProtoView = currView.proto;
            if (currView !== initView && currView.proto.type === ViewType.EMBEDDED) {
              viewIdx += initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx] + 1;
            } else {
              if (currView !== initView) {
                imperativelyCreatedInjector = null;
                parentLocals = null;
                var hostElementIndex = initView.mainMergeMapping.hostElementIndicesByViewIndex[viewIdx];
                hostElementInjector = initView.elementInjectors[hostElementIndex];
                context = hostElementInjector.getComponent();
              }
              currView.context = context;
              currView.locals.parent = parentLocals;
              var binders = currProtoView.elementBinders;
              for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                var boundElementIndex = binderIdx + currView.elementOffset;
                var elementInjector = initView.elementInjectors[boundElementIndex];
                if (isPresent(elementInjector)) {
                  elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector, currView.preBuiltObjects[boundElementIndex]);
                  this._populateViewLocals(currView, elementInjector, boundElementIndex);
                  this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
                  this._setUpHostActions(currView, elementInjector, boundElementIndex);
                }
              }
              var pipes = this._getPipes(imperativelyCreatedInjector, hostElementInjector);
              currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
              viewIdx++;
            }
          }
        },
        _getPipes: function(imperativelyCreatedInjector, hostElementInjector) {
          var pipesKey = eli.StaticKeys.instance().pipesKey;
          if (isPresent(imperativelyCreatedInjector))
            return imperativelyCreatedInjector.getOptional(pipesKey);
          if (isPresent(hostElementInjector))
            return hostElementInjector.getPipes();
          return null;
        },
        _populateViewLocals: function(view, elementInjector, boundElementIdx) {
          if (isPresent(elementInjector.getDirectiveVariableBindings())) {
            MapWrapper.forEach(elementInjector.getDirectiveVariableBindings(), (function(directiveIndex, name) {
              if (isBlank(directiveIndex)) {
                view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
              } else {
                view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
              }
            }));
          }
        },
        _setUpEventEmitters: function(view, elementInjector, boundElementIndex) {
          var emitters = elementInjector.getEventEmitterAccessors();
          for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
            var directiveEmitters = emitters[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
              var eventEmitterAccessor = directiveEmitters[eventIndex];
              eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
            }
          }
        },
        _setUpHostActions: function(view, elementInjector, boundElementIndex) {
          var hostActions = elementInjector.getHostActionAccessors();
          for (var directiveIndex = 0; directiveIndex < hostActions.length; ++directiveIndex) {
            var directiveHostActions = hostActions[directiveIndex];
            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
            for (var index = 0; index < directiveHostActions.length; ++index) {
              var hostActionAccessor = directiveHostActions[index];
              hostActionAccessor.subscribe(view, boundElementIndex, directive);
            }
          }
        },
        dehydrateView: function(initView) {
          var endViewOffset = initView.viewOffset + initView.mainMergeMapping.nestedViewCountByViewIndex[initView.viewOffset];
          for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = initView.views[viewIdx];
            if (currView.hydrated()) {
              if (isPresent(currView.locals)) {
                currView.locals.clearValues();
              }
              currView.context = null;
              currView.changeDetector.dehydrate();
              var binders = currView.proto.elementBinders;
              for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
                var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
                if (isPresent(eli)) {
                  eli.dehydrate();
                }
              }
            }
          }
        }
      }, {}));
      $__export("AppViewManagerUtils", AppViewManagerUtils);
      $__export("AppViewManagerUtils", AppViewManagerUtils = __decorate([Injectable(), __metadata('design:paramtypes', [])], AppViewManagerUtils));
    }
  };
});

System.register("angular2/src/core/compiler/view_resolver", ["angular2/di", "angular2/src/core/annotations_impl/view", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_resolver";
  var __decorate,
      __metadata,
      Injectable,
      View,
      stringify,
      isBlank,
      BaseException,
      Map,
      reflector,
      ViewResolver;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      View = $__m.View;
    }, function($__m) {
      stringify = $__m.stringify;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      ViewResolver = (($traceurRuntime.createClass)(function() {
        this._cache = new Map();
      }, {
        resolve: function(component) {
          var view = this._cache.get(component);
          if (isBlank(view)) {
            view = this._resolve(component);
            this._cache.set(component, view);
          }
          return view;
        },
        _resolve: function(component) {
          var annotations = reflector.annotations(component);
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            if (annotation instanceof View) {
              return annotation;
            }
          }
          throw new BaseException(("No View annotation found on component " + stringify(component)));
        }
      }, {}));
      $__export("ViewResolver", ViewResolver);
      $__export("ViewResolver", ViewResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], ViewResolver));
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_inliner", ["angular2/di", "angular2/src/render/xhr", "angular2/src/facade/collection", "angular2/src/services/url_resolver", "angular2/src/render/dom/compiler/style_url_resolver", "angular2/src/facade/lang", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_inliner";
  var __decorate,
      __metadata,
      Injectable,
      XHR,
      ListWrapper,
      UrlResolver,
      StyleUrlResolver,
      isBlank,
      isPresent,
      RegExpWrapper,
      StringWrapper,
      isPromise,
      PromiseWrapper,
      StyleInliner,
      _importRe,
      _urlRe,
      _mediaQueryRe;
  function _extractUrl(importRule) {
    var match = RegExpWrapper.firstMatch(_urlRe, importRule);
    if (isBlank(match))
      return null;
    return isPresent(match[1]) ? match[1] : match[2];
  }
  function _extractMediaQuery(importRule) {
    var match = RegExpWrapper.firstMatch(_mediaQueryRe, importRule);
    if (isBlank(match))
      return null;
    var mediaQuery = match[1].trim();
    return (mediaQuery.length > 0) ? mediaQuery : null;
  }
  function _wrapInMediaRule(css, query) {
    return (isBlank(query)) ? css : ("@media " + query + " {\n" + css + "\n}");
  }
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      RegExpWrapper = $__m.RegExpWrapper;
      StringWrapper = $__m.StringWrapper;
      isPromise = $__m.isPromise;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      StyleInliner = (($traceurRuntime.createClass)(function(_xhr, _styleUrlResolver, _urlResolver) {
        this._xhr = _xhr;
        this._styleUrlResolver = _styleUrlResolver;
        this._urlResolver = _urlResolver;
      }, {
        inlineImports: function(cssText, baseUrl) {
          return this._inlineImports(cssText, baseUrl, []);
        },
        _inlineImports: function(cssText, baseUrl, inlinedUrls) {
          var $__0 = this;
          var partIndex = 0;
          var parts = StringWrapper.split(cssText, _importRe);
          if (parts.length === 1) {
            return cssText;
          }
          var promises = [];
          while (partIndex < parts.length - 1) {
            var prefix = parts[partIndex];
            var rule = parts[partIndex + 1];
            var url = _extractUrl(rule);
            if (isPresent(url)) {
              url = this._urlResolver.resolve(baseUrl, url);
            }
            var mediaQuery = _extractMediaQuery(rule);
            var promise = void 0;
            if (isBlank(url)) {
              promise = PromiseWrapper.resolve(("/* Invalid import rule: \"@import " + rule + ";\" */"));
            } else if (ListWrapper.contains(inlinedUrls, url)) {
              promise = PromiseWrapper.resolve(prefix);
            } else {
              inlinedUrls.push(url);
              promise = PromiseWrapper.then(this._xhr.get(url), (function(rawCss) {
                var inlinedCss = $__0._inlineImports(rawCss, url, inlinedUrls);
                if (isPromise(inlinedCss)) {
                  return inlinedCss.then((function(css) {
                    return prefix + $__0._transformImportedCss(css, mediaQuery, url) + '\n';
                  }));
                } else {
                  return prefix + $__0._transformImportedCss(inlinedCss, mediaQuery, url) + '\n';
                }
              }), (function(error) {
                return ("/* failed to import " + url + " */\n");
              }));
            }
            promises.push(promise);
            partIndex += 2;
          }
          return PromiseWrapper.all(promises).then(function(cssParts) {
            var cssText = cssParts.join('');
            if (partIndex < parts.length) {
              cssText += parts[partIndex];
            }
            return cssText;
          });
        },
        _transformImportedCss: function(css, mediaQuery, url) {
          css = this._styleUrlResolver.resolveUrls(css, url);
          return _wrapInMediaRule(css, mediaQuery);
        }
      }, {}));
      $__export("StyleInliner", StyleInliner);
      $__export("StyleInliner", StyleInliner = __decorate([Injectable(), __metadata('design:paramtypes', [XHR, StyleUrlResolver, UrlResolver])], StyleInliner));
      _importRe = /@import\s+([^;]+);/g;
      _urlRe = RegExpWrapper.create('url\\(\\s*?[\'"]?([^\'")]+)[\'"]?|' + '[\'"]([^\'")]+)[\'"]');
      _mediaQueryRe = /['"][^'"]+['"]\s*\)?\s*(.*)/g;
    }
  };
});

System.register("angular2/src/render/dom/events/hammer_gestures", ["angular2/src/render/dom/events/hammer_common", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/events/hammer_gestures";
  var HammerGesturesPluginCommon,
      isPresent,
      BaseException,
      HammerGesturesPlugin;
  return {
    setters: [function($__m) {
      HammerGesturesPluginCommon = $__m.HammerGesturesPluginCommon;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }],
    execute: function() {
      HammerGesturesPlugin = (function($__super) {
        function HammerGesturesPlugin() {
          $traceurRuntime.superConstructor(HammerGesturesPlugin).call(this);
        }
        return ($traceurRuntime.createClass)(HammerGesturesPlugin, {
          supports: function(eventName) {
            if (!$traceurRuntime.superGet(this, HammerGesturesPlugin.prototype, "supports").call(this, eventName))
              return false;
            if (!isPresent(window['Hammer'])) {
              throw new BaseException(("Hammer.js is not loaded, can not bind " + eventName + " event"));
            }
            return true;
          },
          addEventListener: function(element, eventName, handler, shouldSupportBubble) {
            if (shouldSupportBubble)
              throw new BaseException('Hammer.js plugin does not support bubbling gestures.');
            var zone = this.manager.getZone();
            eventName = eventName.toLowerCase();
            zone.runOutsideAngular(function() {
              var mc = new Hammer(element);
              mc.get('pinch').set({enable: true});
              mc.get('rotate').set({enable: true});
              mc.on(eventName, function(eventObj) {
                zone.run(function() {
                  handler(eventObj);
                });
              });
            });
          }
        }, {}, $__super);
      }(HammerGesturesPluginCommon));
      $__export("HammerGesturesPlugin", HammerGesturesPlugin);
    }
  };
});

System.register("angular2/src/core/testability/testability", ["angular2/di", "angular2/src/dom/dom_adapter", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/core/testability/get_testability", "angular2/src/core/zone/ng_zone", "angular2/src/facade/async"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/testability/testability";
  var __decorate,
      __metadata,
      Injectable,
      DOM,
      Map,
      BaseException,
      getTestabilityModule,
      NgZone,
      PromiseWrapper,
      Testability,
      TestabilityRegistry;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Map = $__m.Map;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      getTestabilityModule = $__m;
    }, function($__m) {
      NgZone = $__m.NgZone;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Testability = (($traceurRuntime.createClass)(function(_ngZone) {
        this._ngZone = _ngZone;
        this._pendingCount = 0;
        this._callbacks = [];
        this._isAngularEventPending = false;
        this._watchAngularEvents(_ngZone);
      }, {
        _watchAngularEvents: function(_ngZone) {
          var $__0 = this;
          _ngZone.overrideOnTurnStart((function() {
            $__0._isAngularEventPending = true;
          }));
          _ngZone.overrideOnEventDone((function() {
            $__0._isAngularEventPending = false;
            $__0._runCallbacksIfReady();
          }), true);
        },
        increasePendingRequestCount: function() {
          this._pendingCount += 1;
          return this._pendingCount;
        },
        decreasePendingRequestCount: function() {
          this._pendingCount -= 1;
          if (this._pendingCount < 0) {
            throw new BaseException('pending async requests below zero');
          }
          this._runCallbacksIfReady();
          return this._pendingCount;
        },
        _runCallbacksIfReady: function() {
          var $__0 = this;
          if (this._pendingCount != 0 || this._isAngularEventPending) {
            return ;
          }
          PromiseWrapper.resolve(null).then((function(_) {
            while ($__0._callbacks.length !== 0) {
              ($__0._callbacks.pop())();
            }
          }));
        },
        whenStable: function(callback) {
          this._callbacks.push(callback);
          this._runCallbacksIfReady();
        },
        getPendingRequestCount: function() {
          return this._pendingCount;
        },
        isAngularEventPending: function() {
          return this._isAngularEventPending;
        },
        findBindings: function(using, binding, exactMatch) {
          return [];
        }
      }, {}));
      $__export("Testability", Testability);
      $__export("Testability", Testability = __decorate([Injectable(), __metadata('design:paramtypes', [NgZone])], Testability));
      TestabilityRegistry = (($traceurRuntime.createClass)(function() {
        this._applications = new Map();
        getTestabilityModule.GetTestability.addToWindow(this);
      }, {
        registerApplication: function(token, testability) {
          this._applications.set(token, testability);
        },
        findTestabilityInTree: function(elem) {
          if (elem == null) {
            return null;
          }
          if (this._applications.has(elem)) {
            return this._applications.get(elem);
          }
          if (DOM.isShadowRoot(elem)) {
            return this.findTestabilityInTree(DOM.getHost(elem));
          }
          return this.findTestabilityInTree(DOM.parentElement(elem));
        }
      }, {}));
      $__export("TestabilityRegistry", TestabilityRegistry);
      $__export("TestabilityRegistry", TestabilityRegistry = __decorate([Injectable(), __metadata('design:paramtypes', [])], TestabilityRegistry));
    }
  };
});

System.register("angular2/src/render/dom/view/shared_styles_host", ["angular2/src/dom/dom_adapter", "angular2/di", "angular2/src/facade/collection", "angular2/src/render/dom/dom_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/shared_styles_host";
  var __decorate,
      __metadata,
      __param,
      DOM,
      Inject,
      Injectable,
      SetWrapper,
      DOCUMENT_TOKEN,
      SharedStylesHost,
      DomSharedStylesHost;
  return {
    setters: [function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
    }, function($__m) {
      SetWrapper = $__m.SetWrapper;
    }, function($__m) {
      DOCUMENT_TOKEN = $__m.DOCUMENT_TOKEN;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      SharedStylesHost = (($traceurRuntime.createClass)(function() {
        this._styles = [];
        this._stylesSet = new Set();
      }, {
        addStyles: function(styles) {
          var $__0 = this;
          var additions = [];
          styles.forEach((function(style) {
            if (!SetWrapper.has($__0._stylesSet, style)) {
              $__0._stylesSet.add(style);
              $__0._styles.push(style);
              additions.push(style);
            }
          }));
          this.onStylesAdded(additions);
        },
        onStylesAdded: function(additions) {},
        getAllStyles: function() {
          return this._styles;
        }
      }, {}));
      $__export("SharedStylesHost", SharedStylesHost);
      $__export("SharedStylesHost", SharedStylesHost = __decorate([Injectable(), __metadata('design:paramtypes', [])], SharedStylesHost));
      DomSharedStylesHost = (function($__super) {
        function $__1(doc) {
          $traceurRuntime.superConstructor($__1).call(this);
          this._hostNodes = new Set();
          this._hostNodes.add(doc.head);
        }
        return ($traceurRuntime.createClass)($__1, {
          _addStylesToHost: function(styles, host) {
            for (var i = 0; i < styles.length; i++) {
              var style = styles[i];
              DOM.appendChild(host, DOM.createStyleElement(style));
            }
          },
          addHost: function(hostNode) {
            this._addStylesToHost(this._styles, hostNode);
            this._hostNodes.add(hostNode);
          },
          removeHost: function(hostNode) {
            SetWrapper.delete(this._hostNodes, hostNode);
          },
          onStylesAdded: function(additions) {
            var $__0 = this;
            this._hostNodes.forEach((function(hostNode) {
              $__0._addStylesToHost(additions, hostNode);
            }));
          }
        }, {}, $__super);
      }(SharedStylesHost));
      $__export("DomSharedStylesHost", DomSharedStylesHost);
      $__export("DomSharedStylesHost", DomSharedStylesHost = __decorate([Injectable(), __param(0, Inject(DOCUMENT_TOKEN)), __metadata('design:paramtypes', [Object])], DomSharedStylesHost));
    }
  };
});

System.register("angular2/src/render/dom/view/proto_view_builder", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/change_detection/change_detection", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/element_binder", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/view/proto_view_builder";
  var isPresent,
      isBlank,
      BaseException,
      StringWrapper,
      ListWrapper,
      MapWrapper,
      Set,
      SetWrapper,
      StringMapWrapper,
      DOM,
      ASTWithSource,
      AstTransformer,
      AccessMember,
      LiteralArray,
      ImplicitReceiver,
      DomProtoView,
      DomProtoViewRef,
      DomElementBinder,
      Event,
      api,
      NG_BINDING_CLASS,
      EVENT_TARGET_SEPARATOR,
      queryBoundTextNodeIndices,
      camelCaseToDashCase,
      ProtoViewBuilder,
      ElementBinderBuilder,
      DirectiveBuilder,
      EventBuilder,
      PROPERTY_PARTS_SEPARATOR,
      ATTRIBUTE_PREFIX,
      CLASS_PREFIX,
      STYLE_PREFIX;
  function buildElementPropertyBindings(protoElement, isNgComponent, bindingsInTemplate, directiveTempaltePropertyNames) {
    var propertyBindings = [];
    MapWrapper.forEach(bindingsInTemplate, (function(ast, propertyNameInTemplate) {
      var propertyBinding = createElementPropertyBinding(ast, propertyNameInTemplate);
      if (isValidElementPropertyBinding(protoElement, isNgComponent, propertyBinding)) {
        propertyBindings.push(propertyBinding);
      } else if (!SetWrapper.has(directiveTempaltePropertyNames, propertyNameInTemplate)) {
        throw new BaseException(("Can't bind to '" + propertyNameInTemplate + "' since it isn't a known property of the '<" + DOM.tagName(protoElement).toLowerCase() + ">' element and there are no matching directives with a corresponding property"));
      }
    }));
    return propertyBindings;
  }
  function isValidElementPropertyBinding(protoElement, isNgComponent, binding) {
    if (binding.type === api.PropertyBindingType.PROPERTY) {
      var tagName = DOM.tagName(protoElement);
      var possibleCustomElement = tagName.indexOf('-') !== -1;
      if (possibleCustomElement && !isNgComponent) {
        return true;
      } else {
        return DOM.hasProperty(protoElement, binding.property);
      }
    }
    return true;
  }
  function createElementPropertyBinding(ast, propertyNameInTemplate) {
    var parts = StringWrapper.split(propertyNameInTemplate, PROPERTY_PARTS_SEPARATOR);
    if (parts.length === 1) {
      var propName = parts[0];
      var mappedPropName = StringMapWrapper.get(DOM.attrToPropMap, propName);
      propName = isPresent(mappedPropName) ? mappedPropName : propName;
      return new api.ElementPropertyBinding(api.PropertyBindingType.PROPERTY, ast, propName);
    } else if (parts[0] == ATTRIBUTE_PREFIX) {
      return new api.ElementPropertyBinding(api.PropertyBindingType.ATTRIBUTE, ast, parts[1]);
    } else if (parts[0] == CLASS_PREFIX) {
      return new api.ElementPropertyBinding(api.PropertyBindingType.CLASS, ast, camelCaseToDashCase(parts[1]));
    } else if (parts[0] == STYLE_PREFIX) {
      var unit = parts.length > 2 ? parts[2] : null;
      return new api.ElementPropertyBinding(api.PropertyBindingType.STYLE, ast, parts[1], unit);
    } else {
      throw new BaseException(("Invalid property name " + propertyNameInTemplate));
    }
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
      Set = $__m.Set;
      SetWrapper = $__m.SetWrapper;
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ASTWithSource = $__m.ASTWithSource;
      AstTransformer = $__m.AstTransformer;
      AccessMember = $__m.AccessMember;
      LiteralArray = $__m.LiteralArray;
      ImplicitReceiver = $__m.ImplicitReceiver;
    }, function($__m) {
      DomProtoView = $__m.DomProtoView;
      DomProtoViewRef = $__m.DomProtoViewRef;
    }, function($__m) {
      DomElementBinder = $__m.DomElementBinder;
      Event = $__m.Event;
    }, function($__m) {
      api = $__m;
    }, function($__m) {
      NG_BINDING_CLASS = $__m.NG_BINDING_CLASS;
      EVENT_TARGET_SEPARATOR = $__m.EVENT_TARGET_SEPARATOR;
      queryBoundTextNodeIndices = $__m.queryBoundTextNodeIndices;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }],
    execute: function() {
      ProtoViewBuilder = (function() {
        function ProtoViewBuilder(rootElement, type, viewEncapsulation) {
          this.rootElement = rootElement;
          this.type = type;
          this.viewEncapsulation = viewEncapsulation;
          this.variableBindings = new Map();
          this.elements = [];
          this.rootTextBindings = new Map();
          this.ngContentCount = 0;
          this.hostAttributes = new Map();
        }
        return ($traceurRuntime.createClass)(ProtoViewBuilder, {
          bindElement: function(element) {
            var description = arguments[1] !== (void 0) ? arguments[1] : null;
            var builder = new ElementBinderBuilder(this.elements.length, element, description);
            this.elements.push(builder);
            DOM.addClass(element, NG_BINDING_CLASS);
            return builder;
          },
          bindVariable: function(name, value) {
            this.variableBindings.set(value, name);
          },
          bindRootText: function(textNode, expression) {
            this.rootTextBindings.set(textNode, expression);
          },
          bindNgContent: function() {
            this.ngContentCount++;
          },
          setHostAttribute: function(name, value) {
            this.hostAttributes.set(name, value);
          },
          build: function() {
            var domElementBinders = [];
            var apiElementBinders = [];
            var textNodeExpressions = [];
            var rootTextNodeIndices = [];
            var transitiveNgContentCount = this.ngContentCount;
            queryBoundTextNodeIndices(DOM.content(this.rootElement), this.rootTextBindings, (function(node, nodeIndex, expression) {
              textNodeExpressions.push(expression);
              rootTextNodeIndices.push(nodeIndex);
            }));
            ListWrapper.forEach(this.elements, (function(ebb) {
              var directiveTemplatePropertyNames = new Set();
              var apiDirectiveBinders = ListWrapper.map(ebb.directives, (function(dbb) {
                ebb.eventBuilder.merge(dbb.eventBuilder);
                ListWrapper.forEach(dbb.templatePropertyNames, (function(name) {
                  return directiveTemplatePropertyNames.add(name);
                }));
                return new api.DirectiveBinder({
                  directiveIndex: dbb.directiveIndex,
                  propertyBindings: dbb.propertyBindings,
                  eventBindings: dbb.eventBindings,
                  hostPropertyBindings: buildElementPropertyBindings(ebb.element, isPresent(ebb.componentId), dbb.hostPropertyBindings, directiveTemplatePropertyNames)
                });
              }));
              var nestedProtoView = isPresent(ebb.nestedProtoView) ? ebb.nestedProtoView.build() : null;
              if (isPresent(nestedProtoView)) {
                transitiveNgContentCount += nestedProtoView.transitiveNgContentCount;
              }
              var parentIndex = isPresent(ebb.parent) ? ebb.parent.index : -1;
              var textNodeIndices = [];
              queryBoundTextNodeIndices(ebb.element, ebb.textBindings, (function(node, nodeIndex, expression) {
                textNodeExpressions.push(expression);
                textNodeIndices.push(nodeIndex);
              }));
              apiElementBinders.push(new api.ElementBinder({
                index: ebb.index,
                parentIndex: parentIndex,
                distanceToParent: ebb.distanceToParent,
                directives: apiDirectiveBinders,
                nestedProtoView: nestedProtoView,
                propertyBindings: buildElementPropertyBindings(ebb.element, isPresent(ebb.componentId), ebb.propertyBindings, directiveTemplatePropertyNames),
                variableBindings: ebb.variableBindings,
                eventBindings: ebb.eventBindings,
                readAttributes: ebb.readAttributes
              }));
              domElementBinders.push(new DomElementBinder({
                textNodeIndices: textNodeIndices,
                hasNestedProtoView: isPresent(nestedProtoView) || isPresent(ebb.componentId),
                hasNativeShadowRoot: false,
                eventLocals: new LiteralArray(ebb.eventBuilder.buildEventLocals()),
                localEvents: ebb.eventBuilder.buildLocalEvents(),
                globalEvents: ebb.eventBuilder.buildGlobalEvents()
              }));
            }));
            var rootNodeCount = DOM.childNodes(DOM.content(this.rootElement)).length;
            return new api.ProtoViewDto({
              render: new DomProtoViewRef(DomProtoView.create(this.type, this.rootElement, this.viewEncapsulation, [rootNodeCount], rootTextNodeIndices, domElementBinders, this.hostAttributes)),
              type: this.type,
              elementBinders: apiElementBinders,
              variableBindings: this.variableBindings,
              textBindings: textNodeExpressions,
              transitiveNgContentCount: transitiveNgContentCount
            });
          }
        }, {});
      }());
      $__export("ProtoViewBuilder", ProtoViewBuilder);
      ElementBinderBuilder = (function() {
        function ElementBinderBuilder(index, element, description) {
          this.index = index;
          this.element = element;
          this.parent = null;
          this.distanceToParent = 0;
          this.directives = [];
          this.nestedProtoView = null;
          this.propertyBindings = new Map();
          this.variableBindings = new Map();
          this.eventBindings = [];
          this.eventBuilder = new EventBuilder();
          this.textBindings = new Map();
          this.readAttributes = new Map();
          this.componentId = null;
        }
        return ($traceurRuntime.createClass)(ElementBinderBuilder, {
          setParent: function(parent, distanceToParent) {
            this.parent = parent;
            if (isPresent(parent)) {
              this.distanceToParent = distanceToParent;
            }
            return this;
          },
          readAttribute: function(attrName) {
            if (isBlank(this.readAttributes.get(attrName))) {
              this.readAttributes.set(attrName, DOM.getAttribute(this.element, attrName));
            }
          },
          bindDirective: function(directiveIndex) {
            var directive = new DirectiveBuilder(directiveIndex);
            this.directives.push(directive);
            return directive;
          },
          bindNestedProtoView: function(rootElement) {
            if (isPresent(this.nestedProtoView)) {
              throw new BaseException('Only one nested view per element is allowed');
            }
            this.nestedProtoView = new ProtoViewBuilder(rootElement, api.ViewType.EMBEDDED, api.ViewEncapsulation.NONE);
            return this.nestedProtoView;
          },
          bindProperty: function(name, expression) {
            this.propertyBindings.set(name, expression);
          },
          bindVariable: function(name, value) {
            if (isPresent(this.nestedProtoView)) {
              this.nestedProtoView.bindVariable(name, value);
            } else {
              this.variableBindings.set(value, name);
            }
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            this.eventBindings.push(this.eventBuilder.add(name, expression, target));
          },
          bindText: function(textNode, expression) {
            this.textBindings.set(textNode, expression);
          },
          setComponentId: function(componentId) {
            this.componentId = componentId;
          }
        }, {});
      }());
      $__export("ElementBinderBuilder", ElementBinderBuilder);
      DirectiveBuilder = (function() {
        function DirectiveBuilder(directiveIndex) {
          this.directiveIndex = directiveIndex;
          this.propertyBindings = new Map();
          this.templatePropertyNames = [];
          this.hostPropertyBindings = new Map();
          this.eventBindings = [];
          this.eventBuilder = new EventBuilder();
        }
        return ($traceurRuntime.createClass)(DirectiveBuilder, {
          bindProperty: function(name, expression, elProp) {
            this.propertyBindings.set(name, expression);
            if (isPresent(elProp)) {
              this.templatePropertyNames.push(elProp);
            }
          },
          bindHostProperty: function(name, expression) {
            this.hostPropertyBindings.set(name, expression);
          },
          bindEvent: function(name, expression) {
            var target = arguments[2] !== (void 0) ? arguments[2] : null;
            this.eventBindings.push(this.eventBuilder.add(name, expression, target));
          }
        }, {});
      }());
      $__export("DirectiveBuilder", DirectiveBuilder);
      EventBuilder = (function($__super) {
        function EventBuilder() {
          $traceurRuntime.superConstructor(EventBuilder).call(this);
          this.locals = [];
          this.localEvents = [];
          this.globalEvents = [];
          this._implicitReceiver = new ImplicitReceiver();
        }
        return ($traceurRuntime.createClass)(EventBuilder, {
          add: function(name, source, target) {
            var adjustedAst = source.ast;
            var fullName = isPresent(target) ? target + EVENT_TARGET_SEPARATOR + name : name;
            var result = new api.EventBinding(fullName, new ASTWithSource(adjustedAst, source.source, source.location));
            var event = new Event(name, target, fullName);
            if (isBlank(target)) {
              this.localEvents.push(event);
            } else {
              this.globalEvents.push(event);
            }
            return result;
          },
          visitAccessMember: function(ast) {
            var isEventAccess = false;
            var current = ast;
            while (!isEventAccess && (current instanceof AccessMember)) {
              var am = current;
              if (am.name == '$event') {
                isEventAccess = true;
              }
              current = am.receiver;
            }
            if (isEventAccess) {
              this.locals.push(ast);
              var index = this.locals.length - 1;
              return new AccessMember(this._implicitReceiver, ("" + index), (function(arr) {
                return arr[index];
              }), null);
            } else {
              return ast;
            }
          },
          buildEventLocals: function() {
            return this.locals;
          },
          buildLocalEvents: function() {
            return this.localEvents;
          },
          buildGlobalEvents: function() {
            return this.globalEvents;
          },
          merge: function(eventBuilder) {
            this._merge(this.localEvents, eventBuilder.localEvents);
            this._merge(this.globalEvents, eventBuilder.globalEvents);
            ListWrapper.concat(this.locals, eventBuilder.locals);
          },
          _merge: function(host, tobeAdded) {
            var names = [];
            for (var i = 0; i < host.length; i++) {
              names.push(host[i].fullName);
            }
            for (var j = 0; j < tobeAdded.length; j++) {
              if (!ListWrapper.contains(names, tobeAdded[j].fullName)) {
                host.push(tobeAdded[j]);
              }
            }
          }
        }, {}, $__super);
      }(AstTransformer));
      $__export("EventBuilder", EventBuilder);
      PROPERTY_PARTS_SEPARATOR = new RegExp('\\.');
      ATTRIBUTE_PREFIX = 'attr';
      CLASS_PREFIX = 'class';
      STYLE_PREFIX = 'style';
    }
  };
});

System.register("angular2/src/render/dom/compiler/directive_parser", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/selector", "angular2/src/render/api", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/directive_parser";
  var isPresent,
      isBlank,
      BaseException,
      StringWrapper,
      MapWrapper,
      ListWrapper,
      DOM,
      SelectorMatcher,
      CssSelector,
      DirectiveMetadata,
      dashCaseToCamelCase,
      camelCaseToDashCase,
      EVENT_TARGET_SEPARATOR,
      DirectiveParser;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      SelectorMatcher = $__m.SelectorMatcher;
      CssSelector = $__m.CssSelector;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
    }, function($__m) {
      dashCaseToCamelCase = $__m.dashCaseToCamelCase;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
      EVENT_TARGET_SEPARATOR = $__m.EVENT_TARGET_SEPARATOR;
    }],
    execute: function() {
      DirectiveParser = (function() {
        function DirectiveParser(_parser, _directives) {
          this._parser = _parser;
          this._directives = _directives;
          this._selectorMatcher = new SelectorMatcher();
          for (var i = 0; i < _directives.length; i++) {
            var directive = _directives[i];
            var selector = CssSelector.parse(directive.selector);
            this._ensureComponentOnlyHasElementSelector(selector, directive);
            this._selectorMatcher.addSelectables(selector, i);
          }
        }
        return ($traceurRuntime.createClass)(DirectiveParser, {
          processStyle: function(style) {
            return style;
          },
          _ensureComponentOnlyHasElementSelector: function(selector, directive) {
            var isElementSelector = selector.length === 1 && selector[0].isElementSelector();
            if (!isElementSelector && directive.type === DirectiveMetadata.COMPONENT_TYPE) {
              throw new BaseException(("Component '" + directive.id + "' can only have an element selector, but had '" + directive.selector + "'"));
            }
          },
          processElement: function(parent, current, control) {
            var $__0 = this;
            var attrs = current.attrs();
            var classList = current.classList();
            var cssSelector = new CssSelector();
            var foundDirectiveIndices = [];
            var elementBinder = null;
            cssSelector.setElement(DOM.nodeName(current.element));
            for (var i = 0; i < classList.length; i++) {
              cssSelector.addClassName(classList[i]);
            }
            MapWrapper.forEach(attrs, (function(attrValue, attrName) {
              cssSelector.addAttribute(attrName, attrValue);
            }));
            this._selectorMatcher.match(cssSelector, (function(selector, directiveIndex) {
              var directive = $__0._directives[directiveIndex];
              elementBinder = current.bindElement();
              if (directive.type === DirectiveMetadata.COMPONENT_TYPE) {
                $__0._ensureHasOnlyOneComponent(elementBinder, current.elementDescription);
                ListWrapper.insert(foundDirectiveIndices, 0, directiveIndex);
                elementBinder.setComponentId(directive.id);
              } else {
                foundDirectiveIndices.push(directiveIndex);
              }
            }));
            ListWrapper.forEach(foundDirectiveIndices, (function(directiveIndex) {
              var dirMetadata = $__0._directives[directiveIndex];
              var directiveBinderBuilder = elementBinder.bindDirective(directiveIndex);
              current.compileChildren = current.compileChildren && dirMetadata.compileChildren;
              if (isPresent(dirMetadata.properties)) {
                ListWrapper.forEach(dirMetadata.properties, (function(bindConfig) {
                  $__0._bindDirectiveProperty(bindConfig, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostListeners)) {
                $__0._sortedKeysForEach(dirMetadata.hostListeners, (function(action, eventName) {
                  $__0._bindDirectiveEvent(eventName, action, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostProperties)) {
                $__0._sortedKeysForEach(dirMetadata.hostProperties, (function(expression, hostPropertyName) {
                  $__0._bindHostProperty(hostPropertyName, expression, current, directiveBinderBuilder);
                }));
              }
              if (isPresent(dirMetadata.hostAttributes)) {
                $__0._sortedKeysForEach(dirMetadata.hostAttributes, (function(hostAttrValue, hostAttrName) {
                  $__0._addHostAttribute(hostAttrName, hostAttrValue, current);
                }));
              }
              if (isPresent(dirMetadata.readAttributes)) {
                ListWrapper.forEach(dirMetadata.readAttributes, (function(attrName) {
                  elementBinder.readAttribute(attrName);
                }));
              }
            }));
          },
          _sortedKeysForEach: function(map, fn) {
            var keys = MapWrapper.keys(map);
            ListWrapper.sort(keys, (function(a, b) {
              var compareVal = StringWrapper.compare(a, b);
              return compareVal == 0 ? -1 : compareVal;
            }));
            ListWrapper.forEach(keys, (function(key) {
              fn(MapWrapper.get(map, key), key);
            }));
          },
          _ensureHasOnlyOneComponent: function(elementBinder, elDescription) {
            if (isPresent(elementBinder.componentId)) {
              throw new BaseException(("Only one component directive is allowed per element - check " + elDescription));
            }
          },
          _bindDirectiveProperty: function(bindConfig, compileElement, directiveBinderBuilder) {
            var dirProperty;
            var elProp;
            var pipes;
            var assignIndex = bindConfig.indexOf(':');
            if (assignIndex > -1) {
              dirProperty = StringWrapper.substring(bindConfig, 0, assignIndex).trim();
              pipes = this._splitBindConfig(StringWrapper.substring(bindConfig, assignIndex + 1));
              elProp = ListWrapper.removeAt(pipes, 0);
            } else {
              dirProperty = bindConfig;
              elProp = bindConfig;
              pipes = [];
            }
            elProp = dashCaseToCamelCase(elProp);
            var bindingAst = compileElement.bindElement().propertyBindings.get(elProp);
            if (isBlank(bindingAst)) {
              var attributeValue = compileElement.attrs().get(camelCaseToDashCase(elProp));
              if (isPresent(attributeValue)) {
                bindingAst = this._parser.wrapLiteralPrimitive(attributeValue, compileElement.elementDescription);
              }
            }
            if (isPresent(bindingAst)) {
              directiveBinderBuilder.bindProperty(dirProperty, bindingAst, elProp);
            }
          },
          _bindDirectiveEvent: function(eventName, action, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseAction(action, compileElement.elementDescription);
            if (StringWrapper.contains(eventName, EVENT_TARGET_SEPARATOR)) {
              var parts = eventName.split(EVENT_TARGET_SEPARATOR);
              directiveBinderBuilder.bindEvent(parts[1], ast, parts[0]);
            } else {
              directiveBinderBuilder.bindEvent(eventName, ast);
            }
          },
          _bindHostProperty: function(hostPropertyName, expression, compileElement, directiveBinderBuilder) {
            var ast = this._parser.parseSimpleBinding(expression, ("hostProperties of " + compileElement.elementDescription));
            directiveBinderBuilder.bindHostProperty(hostPropertyName, ast);
          },
          _addHostAttribute: function(attrName, attrValue, compileElement) {
            if (StringWrapper.equals(attrName, 'class')) {
              ListWrapper.forEach(attrValue.split(' '), (function(className) {
                DOM.addClass(compileElement.element, className);
              }));
            } else if (!DOM.hasAttribute(compileElement.element, attrName)) {
              DOM.setAttribute(compileElement.element, attrName, attrValue);
            }
          },
          _splitBindConfig: function(bindConfig) {
            return ListWrapper.map(bindConfig.split('|'), (function(s) {
              return s.trim();
            }));
          }
        }, {});
      }());
      $__export("DirectiveParser", DirectiveParser);
    }
  };
});

System.register("angular2/src/render/dom/compiler/style_encapsulator", ["angular2/src/render/api", "angular2/src/render/dom/util", "angular2/src/dom/dom_adapter", "angular2/src/facade/lang", "angular2/src/render/dom/compiler/shadow_css"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/style_encapsulator";
  var ViewEncapsulation,
      ViewType,
      NG_CONTENT_ELEMENT_NAME,
      isElementWithTag,
      DOM,
      isBlank,
      isPresent,
      ShadowCss,
      StyleEncapsulator;
  function getHostAttribute(compId) {
    return ("_nghost-" + compId);
  }
  function getContentAttribute(compId) {
    return ("_ngcontent-" + compId);
  }
  return {
    setters: [function($__m) {
      ViewEncapsulation = $__m.ViewEncapsulation;
      ViewType = $__m.ViewType;
    }, function($__m) {
      NG_CONTENT_ELEMENT_NAME = $__m.NG_CONTENT_ELEMENT_NAME;
      isElementWithTag = $__m.isElementWithTag;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      ShadowCss = $__m.ShadowCss;
    }],
    execute: function() {
      StyleEncapsulator = (function() {
        function StyleEncapsulator(_appId, _view, _componentUIDsCache) {
          this._appId = _appId;
          this._view = _view;
          this._componentUIDsCache = _componentUIDsCache;
        }
        return ($traceurRuntime.createClass)(StyleEncapsulator, {
          processElement: function(parent, current, control) {
            if (isElementWithTag(current.element, NG_CONTENT_ELEMENT_NAME)) {
              current.inheritedProtoView.bindNgContent();
            } else {
              if (this._view.encapsulation === ViewEncapsulation.EMULATED) {
                this._processEmulatedScopedElement(current, parent);
              }
            }
          },
          processStyle: function(style) {
            var encapsulation = this._view.encapsulation;
            if (encapsulation === ViewEncapsulation.EMULATED) {
              return this._shimCssForComponent(style, this._view.componentId);
            } else {
              return style;
            }
          },
          _processEmulatedScopedElement: function(current, parent) {
            var element = current.element;
            var hostComponentId = this._view.componentId;
            var viewType = current.inheritedProtoView.type;
            if (viewType !== ViewType.HOST && isPresent(hostComponentId)) {
              var contentAttribute = getContentAttribute(this._getComponentId(hostComponentId));
              DOM.setAttribute(element, contentAttribute, '');
              if (isBlank(parent) && viewType == ViewType.COMPONENT) {
                var hostAttribute = getHostAttribute(this._getComponentId(hostComponentId));
                current.inheritedProtoView.setHostAttribute(hostAttribute, '');
              }
            }
          },
          _shimCssForComponent: function(cssText, componentId) {
            var id = this._getComponentId(componentId);
            var shadowCss = new ShadowCss();
            return shadowCss.shimCssText(cssText, getContentAttribute(id), getHostAttribute(id));
          },
          _getComponentId: function(componentStringId) {
            var id = this._componentUIDsCache.get(componentStringId);
            if (isBlank(id)) {
              id = (this._appId + "-" + this._componentUIDsCache.size);
              this._componentUIDsCache.set(componentStringId, id);
            }
            return id;
          }
        }, {});
      }());
      $__export("StyleEncapsulator", StyleEncapsulator);
    }
  };
});

System.register("angular2/src/render/dom/dom_renderer", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/view/proto_view", "angular2/src/render/dom/view/view", "angular2/src/render/dom/view/fragment", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/util", "angular2/src/render/api", "angular2/src/render/dom/dom_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/dom_renderer";
  var __decorate,
      __metadata,
      __param,
      Inject,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      DOM,
      EventManager,
      resolveInternalDomProtoView,
      DomView,
      DomViewRef,
      resolveInternalDomView,
      DomFragmentRef,
      resolveInternalDomFragment,
      DomSharedStylesHost,
      cloneAndQueryProtoView,
      camelCaseToDashCase,
      Renderer,
      RenderViewWithFragments,
      DOCUMENT_TOKEN,
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES,
      REFLECT_PREFIX,
      DomRenderer;
  function moveNodesAfterSibling(sibling, nodes) {
    if (nodes.length > 0 && isPresent(DOM.parentElement(sibling))) {
      for (var i = 0; i < nodes.length; i++) {
        DOM.insertBefore(sibling, nodes[i]);
      }
      DOM.insertBefore(nodes[nodes.length - 1], sibling);
    }
  }
  function moveChildNodes(source, target) {
    var currChild = DOM.firstChild(source);
    while (isPresent(currChild)) {
      var nextChild = DOM.nextSibling(currChild);
      DOM.appendChild(target, currChild);
      currChild = nextChild;
    }
  }
  return {
    setters: [function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      EventManager = $__m.EventManager;
    }, function($__m) {
      resolveInternalDomProtoView = $__m.resolveInternalDomProtoView;
    }, function($__m) {
      DomView = $__m.DomView;
      DomViewRef = $__m.DomViewRef;
      resolveInternalDomView = $__m.resolveInternalDomView;
    }, function($__m) {
      DomFragmentRef = $__m.DomFragmentRef;
      resolveInternalDomFragment = $__m.resolveInternalDomFragment;
    }, function($__m) {
      DomSharedStylesHost = $__m.DomSharedStylesHost;
    }, function($__m) {
      cloneAndQueryProtoView = $__m.cloneAndQueryProtoView;
      camelCaseToDashCase = $__m.camelCaseToDashCase;
    }, function($__m) {
      Renderer = $__m.Renderer;
      RenderViewWithFragments = $__m.RenderViewWithFragments;
    }, function($__m) {
      DOCUMENT_TOKEN = $__m.DOCUMENT_TOKEN;
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES = $__m.DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      REFLECT_PREFIX = 'ng-reflect-';
      DomRenderer = (function($__super) {
        function $__0(_eventManager, _domSharedStylesHost, document, reflectPropertiesAsAttributes) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._eventManager = _eventManager;
          this._domSharedStylesHost = _domSharedStylesHost;
          this._reflectPropertiesAsAttributes = reflectPropertiesAsAttributes;
          this._document = document;
        }
        return ($traceurRuntime.createClass)($__0, {
          createRootHostView: function(hostProtoViewRef, fragmentCount, hostElementSelector) {
            var hostProtoView = resolveInternalDomProtoView(hostProtoViewRef);
            var element = DOM.querySelector(this._document, hostElementSelector);
            if (isBlank(element)) {
              throw new BaseException(("The selector \"" + hostElementSelector + "\" did not match any elements"));
            }
            return this._createView(hostProtoView, element);
          },
          createView: function(protoViewRef, fragmentCount) {
            var protoView = resolveInternalDomProtoView(protoViewRef);
            return this._createView(protoView, null);
          },
          destroyView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            var elementBinders = view.proto.elementBinders;
            for (var i = 0; i < elementBinders.length; i++) {
              var binder = elementBinders[i];
              if (binder.hasNativeShadowRoot) {
                this._domSharedStylesHost.removeHost(DOM.getShadowRoot(view.boundElements[i]));
              }
            }
          },
          getNativeElementSync: function(location) {
            if (isBlank(location.renderBoundElementIndex)) {
              return null;
            }
            return resolveInternalDomView(location.renderView).boundElements[location.renderBoundElementIndex];
          },
          getRootNodes: function(fragment) {
            return resolveInternalDomFragment(fragment);
          },
          attachFragmentAfterFragment: function(previousFragmentRef, fragmentRef) {
            var previousFragmentNodes = resolveInternalDomFragment(previousFragmentRef);
            if (previousFragmentNodes.length > 0) {
              var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
              moveNodesAfterSibling(sibling, resolveInternalDomFragment(fragmentRef));
            }
          },
          attachFragmentAfterElement: function(elementRef, fragmentRef) {
            if (isBlank(elementRef.renderBoundElementIndex)) {
              return ;
            }
            var parentView = resolveInternalDomView(elementRef.renderView);
            var element = parentView.boundElements[elementRef.renderBoundElementIndex];
            moveNodesAfterSibling(element, resolveInternalDomFragment(fragmentRef));
          },
          detachFragment: function(fragmentRef) {
            var fragmentNodes = resolveInternalDomFragment(fragmentRef);
            for (var i = 0; i < fragmentNodes.length; i++) {
              DOM.remove(fragmentNodes[i]);
            }
          },
          hydrateView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            if (view.hydrated)
              throw new BaseException('The view is already hydrated.');
            view.hydrated = true;
            view.eventHandlerRemovers = [];
            var binders = view.proto.elementBinders;
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              if (isPresent(binder.globalEvents)) {
                for (var i = 0; i < binder.globalEvents.length; i++) {
                  var globalEvent = binder.globalEvents[i];
                  var remover = this._createGlobalEventListener(view, binderIdx, globalEvent.name, globalEvent.target, globalEvent.fullName);
                  view.eventHandlerRemovers.push(remover);
                }
              }
            }
          },
          dehydrateView: function(viewRef) {
            var view = resolveInternalDomView(viewRef);
            for (var i = 0; i < view.eventHandlerRemovers.length; i++) {
              view.eventHandlerRemovers[i]();
            }
            view.eventHandlerRemovers = null;
            view.hydrated = false;
          },
          setElementProperty: function(location, propertyName, propertyValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementProperty(location.renderBoundElementIndex, propertyName, propertyValue);
            if (this._reflectPropertiesAsAttributes) {
              this.setElementAttribute(location, ("" + REFLECT_PREFIX + camelCaseToDashCase(propertyName)), ("" + propertyValue));
            }
          },
          setElementAttribute: function(location, attributeName, attributeValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementAttribute(location.renderBoundElementIndex, attributeName, attributeValue);
          },
          setElementClass: function(location, className, isAdd) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementClass(location.renderBoundElementIndex, className, isAdd);
          },
          setElementStyle: function(location, styleName, styleValue) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.setElementStyle(location.renderBoundElementIndex, styleName, styleValue);
          },
          invokeElementMethod: function(location, methodName, args) {
            if (isBlank(location.renderBoundElementIndex)) {
              return ;
            }
            var view = resolveInternalDomView(location.renderView);
            view.invokeElementMethod(location.renderBoundElementIndex, methodName, args);
          },
          setText: function(viewRef, textNodeIndex, text) {
            if (isBlank(textNodeIndex)) {
              return ;
            }
            var view = resolveInternalDomView(viewRef);
            DOM.setText(view.boundTextNodes[textNodeIndex], text);
          },
          setEventDispatcher: function(viewRef, dispatcher) {
            var view = resolveInternalDomView(viewRef);
            view.eventDispatcher = dispatcher;
          },
          _createView: function(protoView, inplaceElement) {
            var clonedProtoView = cloneAndQueryProtoView(protoView, true);
            var boundElements = clonedProtoView.boundElements;
            if (isPresent(inplaceElement)) {
              if (protoView.fragmentsRootNodeCount[0] !== 1) {
                throw new BaseException('Root proto views can only contain one element!');
              }
              DOM.clearNodes(inplaceElement);
              var tempRoot = clonedProtoView.fragments[0][0];
              moveChildNodes(tempRoot, inplaceElement);
              if (boundElements.length > 0 && boundElements[0] === tempRoot) {
                boundElements[0] = inplaceElement;
              }
              clonedProtoView.fragments[0][0] = inplaceElement;
            }
            var view = new DomView(protoView, clonedProtoView.boundTextNodes, boundElements);
            var binders = protoView.elementBinders;
            for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
              var binder = binders[binderIdx];
              var element = boundElements[binderIdx];
              if (binder.hasNativeShadowRoot) {
                var shadowRootWrapper = DOM.firstChild(element);
                var shadowRoot = DOM.createShadowRoot(element);
                this._domSharedStylesHost.addHost(shadowRoot);
                moveChildNodes(shadowRootWrapper, shadowRoot);
                DOM.remove(shadowRootWrapper);
              }
              if (isPresent(binder.eventLocals) && isPresent(binder.localEvents)) {
                for (var i = 0; i < binder.localEvents.length; i++) {
                  this._createEventListener(view, element, binderIdx, binder.localEvents[i].name, binder.eventLocals);
                }
              }
            }
            return new RenderViewWithFragments(new DomViewRef(view), clonedProtoView.fragments.map((function(nodes) {
              return new DomFragmentRef(nodes);
            })));
          },
          _createEventListener: function(view, element, elementIndex, eventName, eventLocals) {
            this._eventManager.addEventListener(element, eventName, (function(event) {
              view.dispatchEvent(elementIndex, eventName, event);
            }));
          },
          _createGlobalEventListener: function(view, elementIndex, eventName, eventTarget, fullName) {
            return this._eventManager.addGlobalEventListener(eventTarget, eventName, (function(event) {
              view.dispatchEvent(elementIndex, fullName, event);
            }));
          }
        }, {}, $__super);
      }(Renderer));
      $__export("DomRenderer", DomRenderer);
      $__export("DomRenderer", DomRenderer = __decorate([Injectable(), __param(2, Inject(DOCUMENT_TOKEN)), __param(3, Inject(DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES)), __metadata('design:paramtypes', [EventManager, DomSharedStylesHost, Object, Boolean])], DomRenderer));
    }
  };
});

System.register("angular2/annotations", ["angular2/src/core/annotations/annotations", "angular2/src/core/annotations/view", "angular2/src/core/annotations/di", "angular2/src/util/decorators", "angular2/src/core/annotations/decorators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/annotations";
  return {
    setters: [function($__m) {
      $__export("ComponentAnnotation", $__m.ComponentAnnotation);
      $__export("DirectiveAnnotation", $__m.DirectiveAnnotation);
      $__export("LifecycleEvent", $__m.LifecycleEvent);
    }, function($__m) {
      $__export("ViewAnnotation", $__m.ViewAnnotation);
      $__export("ViewEncapsulation", $__m.ViewEncapsulation);
    }, function($__m) {
      $__export("QueryAnnotation", $__m.QueryAnnotation);
      $__export("AttributeAnnotation", $__m.AttributeAnnotation);
    }, function($__m) {
      $__export("Class", $__m.Class);
    }, function($__m) {
      $__export("Attribute", $__m.Attribute);
      $__export("Component", $__m.Component);
      $__export("Directive", $__m.Directive);
      $__export("View", $__m.View);
      $__export("Query", $__m.Query);
      $__export("ViewQuery", $__m.ViewQuery);
    }],
    execute: function() {}
  };
});

System.register("angular2/directives", ["angular2/src/facade/lang", "angular2/src/directives/ng_for", "angular2/src/directives/ng_if", "angular2/src/directives/ng_non_bindable", "angular2/src/directives/ng_switch", "angular2/src/directives/class", "angular2/src/directives/ng_style"], function($__export) {
  "use strict";
  var __moduleName = "angular2/directives";
  var CONST_EXPR,
      NgFor,
      NgIf,
      NgNonBindable,
      NgSwitch,
      NgSwitchWhen,
      NgSwitchDefault,
      coreDirectives;
  var $__exportNames = {coreDirectives: true};
  var $__exportNames = {coreDirectives: true};
  var $__exportNames = {coreDirectives: true};
  var $__exportNames = {coreDirectives: true};
  var $__exportNames = {coreDirectives: true};
  var $__exportNames = {coreDirectives: true};
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      NgFor = $__m.NgFor;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgIf = $__m.NgIf;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgNonBindable = $__m.NgNonBindable;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      NgSwitch = $__m.NgSwitch;
      NgSwitchWhen = $__m.NgSwitchWhen;
      NgSwitchDefault = $__m.NgSwitchDefault;
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {
      coreDirectives = CONST_EXPR([NgFor, NgIf, NgNonBindable, NgSwitch, NgSwitchWhen, NgSwitchDefault]);
      $__export("coreDirectives", coreDirectives);
    }
  };
});

System.register("angular2/src/http/static_request", ["angular2/src/http/headers", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/static_request";
  var Headers,
      isPresent,
      Request;
  return {
    setters: [function($__m) {
      Headers = $__m.Headers;
    }, function($__m) {
      isPresent = $__m.isPresent;
    }],
    execute: function() {
      Request = (function() {
        function Request(requestOptions) {
          this.url = requestOptions.url;
          this._body = requestOptions.body;
          this.method = requestOptions.method;
          this.mode = requestOptions.mode;
          this.credentials = requestOptions.credentials;
          this.headers = new Headers(requestOptions.headers);
          this.cache = requestOptions.cache;
        }
        return ($traceurRuntime.createClass)(Request, {text: function() {
            return isPresent(this._body) ? this._body.toString() : '';
          }}, {});
      }());
      $__export("Request", Request);
    }
  };
});

System.register("angular2/src/http/base_request_options", ["angular2/src/facade/lang", "angular2/src/http/headers", "angular2/src/http/enums", "angular2/di"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/base_request_options";
  var __decorate,
      __metadata,
      isPresent,
      Headers,
      RequestModesOpts,
      RequestMethods,
      Injectable,
      RequestOptions,
      BaseRequestOptions;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      Headers = $__m.Headers;
    }, function($__m) {
      RequestModesOpts = $__m.RequestModesOpts;
      RequestMethods = $__m.RequestMethods;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      RequestOptions = (function() {
        function RequestOptions() {
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              method = $__2.method,
              headers = $__2.headers,
              body = $__2.body,
              mode = $__2.mode,
              credentials = $__2.credentials,
              cache = $__2.cache,
              url = $__2.url;
          this.method = isPresent(method) ? method : null;
          this.headers = isPresent(headers) ? headers : null;
          this.body = isPresent(body) ? body : null;
          this.mode = isPresent(mode) ? mode : null;
          this.credentials = isPresent(credentials) ? credentials : null;
          this.cache = isPresent(cache) ? cache : null;
          this.url = isPresent(url) ? url : null;
        }
        return ($traceurRuntime.createClass)(RequestOptions, {merge: function(options) {
            return new RequestOptions({
              method: isPresent(options) && isPresent(options.method) ? options.method : this.method,
              headers: isPresent(options) && isPresent(options.headers) ? options.headers : this.headers,
              body: isPresent(options) && isPresent(options.body) ? options.body : this.body,
              mode: isPresent(options) && isPresent(options.mode) ? options.mode : this.mode,
              credentials: isPresent(options) && isPresent(options.credentials) ? options.credentials : this.credentials,
              cache: isPresent(options) && isPresent(options.cache) ? options.cache : this.cache,
              url: isPresent(options) && isPresent(options.url) ? options.url : this.url
            });
          }}, {});
      }());
      $__export("RequestOptions", RequestOptions);
      BaseRequestOptions = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).call(this, {
            method: RequestMethods.GET,
            headers: new Headers(),
            mode: RequestModesOpts.Cors
          });
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(RequestOptions));
      $__export("BaseRequestOptions", BaseRequestOptions);
      $__export("BaseRequestOptions", BaseRequestOptions = __decorate([Injectable(), __metadata('design:paramtypes', [])], BaseRequestOptions));
    }
  };
});

System.register("angular2/src/http/static_response", ["angular2/src/facade/lang", "angular2/src/http/http_utils"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/static_response";
  var BaseException,
      isString,
      Json,
      isJsObject,
      Response;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
      isString = $__m.isString;
      Json = $__m.Json;
    }, function($__m) {
      isJsObject = $__m.isJsObject;
    }],
    execute: function() {
      Response = (function() {
        function Response(responseOptions) {
          this._body = responseOptions.body;
          this.status = responseOptions.status;
          this.statusText = responseOptions.statusText;
          this.headers = responseOptions.headers;
          this.type = responseOptions.type;
          this.url = responseOptions.url;
        }
        return ($traceurRuntime.createClass)(Response, {
          blob: function() {
            throw new BaseException('"blob()" method not implemented on Response superclass');
          },
          json: function() {
            var jsonResponse;
            if (isJsObject(this._body)) {
              jsonResponse = this._body;
            } else if (isString(this._body)) {
              jsonResponse = Json.parse(this._body);
            }
            return jsonResponse;
          },
          text: function() {
            return this._body.toString();
          },
          arrayBuffer: function() {
            throw new BaseException('"arrayBuffer()" method not implemented on Response superclass');
          }
        }, {});
      }());
      $__export("Response", Response);
    }
  };
});

System.register("angular2/src/http/backends/jsonp_backend", ["angular2/src/http/enums", "angular2/src/http/static_response", "angular2/src/http/base_response_options", "angular2/di", "angular2/src/http/backends/browser_jsonp", "angular2/src/facade/async", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/backends/jsonp_backend";
  var __decorate,
      __metadata,
      ReadyStates,
      RequestMethods,
      Response,
      ResponseOptions,
      Injectable,
      BrowserJsonp,
      EventEmitter,
      ObservableWrapper,
      StringWrapper,
      isPresent,
      makeTypeError,
      JSONPConnection,
      JSONPBackend;
  return {
    setters: [function($__m) {
      ReadyStates = $__m.ReadyStates;
      RequestMethods = $__m.RequestMethods;
    }, function($__m) {
      Response = $__m.Response;
    }, function($__m) {
      ResponseOptions = $__m.ResponseOptions;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      BrowserJsonp = $__m.BrowserJsonp;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      makeTypeError = $__m.makeTypeError;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      JSONPConnection = (function() {
        function JSONPConnection(req, _dom, baseResponseOptions) {
          var $__0 = this;
          this._dom = _dom;
          this.baseResponseOptions = baseResponseOptions;
          this._finished = false;
          if (req.method !== RequestMethods.GET) {
            throw makeTypeError("JSONP requests must use GET request method.");
          }
          this.request = req;
          this.response = new EventEmitter();
          this.readyState = ReadyStates.LOADING;
          this._id = _dom.nextRequestID();
          _dom.exposeConnection(this._id, this);
          var callback = _dom.requestCallback(this._id);
          var url = req.url;
          if (url.indexOf('=JSONP_CALLBACK&') > -1) {
            url = StringWrapper.replace(url, '=JSONP_CALLBACK&', ("=" + callback + "&"));
          } else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
            url = StringWrapper.substring(url, 0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
          }
          var script = this._script = _dom.build(url);
          script.addEventListener('load', (function(event) {
            if ($__0.readyState === ReadyStates.CANCELLED)
              return ;
            $__0.readyState = ReadyStates.DONE;
            _dom.cleanup(script);
            if (!$__0._finished) {
              ObservableWrapper.callThrow($__0.response, makeTypeError('JSONP injected script did not invoke callback.'));
              return ;
            }
            var responseOptions = new ResponseOptions({body: $__0._responseData});
            if (isPresent($__0.baseResponseOptions)) {
              responseOptions = $__0.baseResponseOptions.merge(responseOptions);
            }
            ObservableWrapper.callNext($__0.response, new Response(responseOptions));
          }));
          script.addEventListener('error', (function(error) {
            if ($__0.readyState === ReadyStates.CANCELLED)
              return ;
            $__0.readyState = ReadyStates.DONE;
            _dom.cleanup(script);
            ObservableWrapper.callThrow($__0.response, error);
          }));
          _dom.send(script);
        }
        return ($traceurRuntime.createClass)(JSONPConnection, {
          finished: function(data) {
            this._finished = true;
            this._dom.removeConnection(this._id);
            if (this.readyState === ReadyStates.CANCELLED)
              return ;
            this._responseData = data;
          },
          dispose: function() {
            this.readyState = ReadyStates.CANCELLED;
            var script = this._script;
            this._script = null;
            if (isPresent(script)) {
              this._dom.cleanup(script);
            }
            ObservableWrapper.callReturn(this.response);
          }
        }, {});
      }());
      $__export("JSONPConnection", JSONPConnection);
      JSONPBackend = (($traceurRuntime.createClass)(function(_browserJSONP, _baseResponseOptions) {
        this._browserJSONP = _browserJSONP;
        this._baseResponseOptions = _baseResponseOptions;
      }, {createConnection: function(request) {
          return new JSONPConnection(request, this._browserJSONP, this._baseResponseOptions);
        }}, {}));
      $__export("JSONPBackend", JSONPBackend);
      $__export("JSONPBackend", JSONPBackend = __decorate([Injectable(), __metadata('design:paramtypes', [BrowserJsonp, ResponseOptions])], JSONPBackend));
    }
  };
});

System.register("angular2/src/forms/model", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/forms/validators"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/model";
  var StringWrapper,
      isPresent,
      isBlank,
      EventEmitter,
      ObservableWrapper,
      StringMapWrapper,
      ListWrapper,
      List,
      Validators,
      VALID,
      INVALID,
      AbstractControl,
      Control,
      ControlGroup,
      ControlArray;
  function isControl(c) {
    return c instanceof AbstractControl;
  }
  function _find(c, path) {
    if (isBlank(path))
      return null;
    if (!(path instanceof List)) {
      path = StringWrapper.split(path, new RegExp("/"));
    }
    if (path instanceof List && ListWrapper.isEmpty(path))
      return null;
    return ListWrapper.reduce(path, (function(v, name) {
      if (v instanceof ControlGroup) {
        return isPresent(v.controls[name]) ? v.controls[name] : null;
      } else if (v instanceof ControlArray) {
        var index = name;
        return isPresent(v.at(index)) ? v.at(index) : null;
      } else {
        return null;
      }
    }), c);
  }
  $__export("isControl", isControl);
  return {
    setters: [function($__m) {
      StringWrapper = $__m.StringWrapper;
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
      ListWrapper = $__m.ListWrapper;
      List = $__m.List;
    }, function($__m) {
      Validators = $__m.Validators;
    }],
    execute: function() {
      VALID = "VALID";
      $__export("VALID", VALID);
      INVALID = "INVALID";
      $__export("INVALID", INVALID);
      AbstractControl = (function() {
        function AbstractControl(validator) {
          this.validator = validator;
          this._pristine = true;
          this._touched = false;
        }
        return ($traceurRuntime.createClass)(AbstractControl, {
          get value() {
            return this._value;
          },
          get status() {
            return this._status;
          },
          get valid() {
            return this._status === VALID;
          },
          get errors() {
            return this._errors;
          },
          get pristine() {
            return this._pristine;
          },
          get dirty() {
            return !this.pristine;
          },
          get touched() {
            return this._touched;
          },
          get untouched() {
            return !this._touched;
          },
          get valueChanges() {
            return this._valueChanges;
          },
          markAsTouched: function() {
            this._touched = true;
          },
          markAsDirty: function() {
            var onlySelf = (arguments[0] !== (void 0) ? arguments[0] : {}).onlySelf;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            this._pristine = false;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.markAsDirty({onlySelf: onlySelf});
            }
          },
          setParent: function(parent) {
            this._parent = parent;
          },
          updateValidity: function() {
            var onlySelf = (arguments[0] !== (void 0) ? arguments[0] : {}).onlySelf;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.updateValidity({onlySelf: onlySelf});
            }
          },
          updateValueAndValidity: function() {
            var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
                onlySelf = $__2.onlySelf,
                emitEvent = $__2.emitEvent;
            onlySelf = isPresent(onlySelf) ? onlySelf : false;
            emitEvent = isPresent(emitEvent) ? emitEvent : true;
            this._updateValue();
            if (emitEvent) {
              ObservableWrapper.callNext(this._valueChanges, this._value);
            }
            this._errors = this.validator(this);
            this._status = isPresent(this._errors) ? INVALID : VALID;
            if (isPresent(this._parent) && !onlySelf) {
              this._parent.updateValueAndValidity({
                onlySelf: onlySelf,
                emitEvent: emitEvent
              });
            }
          },
          find: function(path) {
            return _find(this, path);
          },
          getError: function(errorCode) {
            var path = arguments[1] !== (void 0) ? arguments[1] : null;
            var c = isPresent(path) && !ListWrapper.isEmpty(path) ? this.find(path) : this;
            if (isPresent(c) && isPresent(c._errors)) {
              return StringMapWrapper.get(c._errors, errorCode);
            } else {
              return null;
            }
          },
          hasError: function(errorCode) {
            var path = arguments[1] !== (void 0) ? arguments[1] : null;
            return isPresent(this.getError(errorCode, path));
          },
          _updateValue: function() {}
        }, {});
      }());
      $__export("AbstractControl", AbstractControl);
      Control = (function($__super) {
        function Control() {
          var value = arguments[0] !== (void 0) ? arguments[0] : null;
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.nullValidator;
          $traceurRuntime.superConstructor(Control).call(this, validator);
          this._value = value;
          this.updateValidity({onlySelf: true});
          this._valueChanges = new EventEmitter();
        }
        return ($traceurRuntime.createClass)(Control, {
          updateValue: function(value) {
            var $__2 = arguments[1] !== (void 0) ? arguments[1] : {},
                onlySelf = $__2.onlySelf,
                emitEvent = $__2.emitEvent,
                emitModelToViewChange = $__2.emitModelToViewChange;
            emitModelToViewChange = isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
            this._value = value;
            if (isPresent(this._onChange) && emitModelToViewChange)
              this._onChange(this._value);
            this.updateValueAndValidity({
              onlySelf: onlySelf,
              emitEvent: emitEvent
            });
          },
          registerOnChange: function(fn) {
            this._onChange = fn;
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("Control", Control);
      ControlGroup = (function($__super) {
        function ControlGroup(controls) {
          var optionals = arguments[1] !== (void 0) ? arguments[1] : null;
          var validator = arguments[2] !== (void 0) ? arguments[2] : Validators.group;
          $traceurRuntime.superConstructor(ControlGroup).call(this, validator);
          this.controls = controls;
          this._optionals = isPresent(optionals) ? optionals : {};
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._value = this._reduceValue();
          this.updateValidity({onlySelf: true});
        }
        return ($traceurRuntime.createClass)(ControlGroup, {
          addControl: function(name, c) {
            this.controls[name] = c;
            c.setParent(this);
          },
          removeControl: function(name) {
            StringMapWrapper.delete(this.controls, name);
          },
          include: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, true);
            this.updateValueAndValidity();
          },
          exclude: function(controlName) {
            StringMapWrapper.set(this._optionals, controlName, false);
            this.updateValueAndValidity();
          },
          contains: function(controlName) {
            var c = StringMapWrapper.contains(this.controls, controlName);
            return c && this._included(controlName);
          },
          _setParentForControls: function() {
            var $__0 = this;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              control.setParent($__0);
            }));
          },
          _updateValue: function() {
            this._value = this._reduceValue();
          },
          _reduceValue: function() {
            return this._reduceChildren({}, (function(acc, control, name) {
              acc[name] = control.value;
              return acc;
            }));
          },
          _reduceChildren: function(initValue, fn) {
            var $__0 = this;
            var res = initValue;
            StringMapWrapper.forEach(this.controls, (function(control, name) {
              if ($__0._included(name)) {
                res = fn(res, control, name);
              }
            }));
            return res;
          },
          _included: function(controlName) {
            var isOptional = StringMapWrapper.contains(this._optionals, controlName);
            return !isOptional || StringMapWrapper.get(this._optionals, controlName);
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlGroup", ControlGroup);
      ControlArray = (function($__super) {
        function ControlArray(controls) {
          var validator = arguments[1] !== (void 0) ? arguments[1] : Validators.array;
          $traceurRuntime.superConstructor(ControlArray).call(this, validator);
          this.controls = controls;
          this._valueChanges = new EventEmitter();
          this._setParentForControls();
          this._updateValue();
          this.updateValidity({onlySelf: true});
        }
        return ($traceurRuntime.createClass)(ControlArray, {
          at: function(index) {
            return this.controls[index];
          },
          push: function(control) {
            this.controls.push(control);
            control.setParent(this);
            this.updateValueAndValidity();
          },
          insert: function(index, control) {
            ListWrapper.insert(this.controls, index, control);
            control.setParent(this);
            this.updateValueAndValidity();
          },
          removeAt: function(index) {
            ListWrapper.removeAt(this.controls, index);
            this.updateValueAndValidity();
          },
          get length() {
            return this.controls.length;
          },
          _updateValue: function() {
            this._value = ListWrapper.map(this.controls, (function(c) {
              return c.value;
            }));
          },
          _setParentForControls: function() {
            var $__0 = this;
            ListWrapper.forEach(this.controls, (function(control) {
              control.setParent($__0);
            }));
          }
        }, {}, $__super);
      }(AbstractControl));
      $__export("ControlArray", ControlArray);
    }
  };
});

System.register("angular2/src/forms/directives/ng_control_name", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/core", "angular2/annotations", "angular2/di", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/validators", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/ng_control_name";
  var __decorate,
      __metadata,
      __param,
      CONST_EXPR,
      EventEmitter,
      ObservableWrapper,
      QueryList,
      Query,
      Directive,
      LifecycleEvent,
      forwardRef,
      Ancestor,
      Binding,
      ControlContainer,
      NgControl,
      NgValidator,
      controlPath,
      composeNgValidator,
      isPropertyUpdated,
      controlNameBinding,
      NgControlName;
  return {
    setters: [function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      Query = $__m.Query;
      Directive = $__m.Directive;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      forwardRef = $__m.forwardRef;
      Ancestor = $__m.Ancestor;
      Binding = $__m.Binding;
    }, function($__m) {
      ControlContainer = $__m.ControlContainer;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      NgValidator = $__m.NgValidator;
    }, function($__m) {
      controlPath = $__m.controlPath;
      composeNgValidator = $__m.composeNgValidator;
      isPropertyUpdated = $__m.isPropertyUpdated;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      controlNameBinding = CONST_EXPR(new Binding(NgControl, {toAlias: forwardRef((function() {
          return NgControlName;
        }))}));
      NgControlName = (function($__super) {
        function $__0(parent, ngValidators) {
          $traceurRuntime.superConstructor($__0).call(this);
          this.update = new EventEmitter();
          this._added = false;
          this._parent = parent;
          this.ngValidators = ngValidators;
        }
        return ($traceurRuntime.createClass)($__0, {
          onChange: function(c) {
            if (!this._added) {
              this.formDirective.addControl(this);
              this._added = true;
            }
            if (isPropertyUpdated(c, this.viewModel)) {
              this.viewModel = this.model;
              this.formDirective.updateModel(this, this.model);
            }
          },
          onDestroy: function() {
            this.formDirective.removeControl(this);
          },
          viewToModelUpdate: function(newValue) {
            this.viewModel = newValue;
            ObservableWrapper.callNext(this.update, newValue);
          },
          get path() {
            return controlPath(this.name, this._parent);
          },
          get formDirective() {
            return this._parent.formDirective;
          },
          get control() {
            return this.formDirective.getControl(this);
          },
          get validator() {
            return composeNgValidator(this.ngValidators);
          }
        }, {}, $__super);
      }(NgControl));
      $__export("NgControlName", NgControlName);
      $__export("NgControlName", NgControlName = __decorate([Directive({
        selector: '[ng-control]',
        hostInjector: [controlNameBinding],
        properties: ['name: ngControl', 'model: ngModel'],
        events: ['update: ngModel'],
        lifecycle: [LifecycleEvent.onDestroy, LifecycleEvent.onChange],
        exportAs: 'form'
      }), __param(0, Ancestor()), __param(1, Query(NgValidator)), __metadata('design:paramtypes', [ControlContainer, QueryList])], NgControlName));
    }
  };
});

System.register("angular2/src/forms/directives/default_value_accessor", ["angular2/render", "angular2/annotations", "angular2/core", "angular2/di", "angular2/src/forms/directives/ng_control", "angular2/src/facade/lang", "angular2/src/forms/directives/shared"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/forms/directives/default_value_accessor";
  var __decorate,
      __metadata,
      __param,
      Renderer,
      Directive,
      ElementRef,
      Self,
      NgControl,
      isBlank,
      isPresent,
      setProperty,
      DefaultValueAccessor;
  return {
    setters: [function($__m) {
      Renderer = $__m.Renderer;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      Self = $__m.Self;
    }, function($__m) {
      NgControl = $__m.NgControl;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
    }, function($__m) {
      setProperty = $__m.setProperty;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      DefaultValueAccessor = (($traceurRuntime.createClass)(function(cd, renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.onChange = (function(_) {});
        this.onTouched = (function() {});
        this.cd = cd;
        cd.valueAccessor = this;
      }, {
        writeValue: function(value) {
          var normalizedValue = isBlank(value) ? '' : value;
          setProperty(this.renderer, this.elementRef, 'value', normalizedValue);
        },
        get ngClassUntouched() {
          return isPresent(this.cd.control) ? this.cd.control.untouched : false;
        },
        get ngClassTouched() {
          return isPresent(this.cd.control) ? this.cd.control.touched : false;
        },
        get ngClassPristine() {
          return isPresent(this.cd.control) ? this.cd.control.pristine : false;
        },
        get ngClassDirty() {
          return isPresent(this.cd.control) ? this.cd.control.dirty : false;
        },
        get ngClassValid() {
          return isPresent(this.cd.control) ? this.cd.control.valid : false;
        },
        get ngClassInvalid() {
          return isPresent(this.cd.control) ? !this.cd.control.valid : false;
        },
        registerOnChange: function(fn) {
          this.onChange = fn;
        },
        registerOnTouched: function(fn) {
          this.onTouched = fn;
        }
      }, {}));
      $__export("DefaultValueAccessor", DefaultValueAccessor);
      $__export("DefaultValueAccessor", DefaultValueAccessor = __decorate([Directive({
        selector: 'input:not([type=checkbox])[ng-control],textarea[ng-control],input:not([type=checkbox])[ng-form-control],textarea[ng-form-control],input:not([type=checkbox])[ng-model],textarea[ng-model]',
        host: {
          '(change)': 'onChange($event.target.value)',
          '(input)': 'onChange($event.target.value)',
          '(blur)': 'onTouched()',
          '[class.ng-untouched]': 'ngClassUntouched',
          '[class.ng-touched]': 'ngClassTouched',
          '[class.ng-pristine]': 'ngClassPristine',
          '[class.ng-dirty]': 'ngClassDirty',
          '[class.ng-valid]': 'ngClassValid',
          '[class.ng-invalid]': 'ngClassInvalid'
        }
      }), __param(0, Self()), __metadata('design:paramtypes', [NgControl, Renderer, ElementRef])], DefaultValueAccessor));
    }
  };
});

System.register("angular2/src/di/binding", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/reflection/reflection", "angular2/src/di/key", "angular2/src/di/metadata", "angular2/src/di/exceptions", "angular2/src/di/forward_ref"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/binding";
  var __decorate,
      __metadata,
      Type,
      isBlank,
      isPresent,
      CONST,
      CONST_EXPR,
      BaseException,
      stringify,
      isArray,
      ListWrapper,
      reflector,
      Key,
      InjectMetadata,
      VisibilityMetadata,
      OptionalMetadata,
      DEFAULT_VISIBILITY,
      DependencyMetadata,
      NoAnnotationError,
      resolveForwardRef,
      Dependency,
      _EMPTY_LIST,
      Binding,
      ResolvedBinding,
      BindingBuilder;
  function bind(token) {
    return new BindingBuilder(token);
  }
  function _constructDependencies(factoryFunction, dependencies) {
    if (isBlank(dependencies)) {
      return _dependenciesFor(factoryFunction);
    } else {
      var params = ListWrapper.map(dependencies, (function(t) {
        return [t];
      }));
      return ListWrapper.map(dependencies, (function(t) {
        return _extractToken(factoryFunction, t, params);
      }));
    }
  }
  function _dependenciesFor(typeOrFunc) {
    var params = reflector.parameters(typeOrFunc);
    if (isBlank(params))
      return [];
    if (ListWrapper.any(params, (function(p) {
      return isBlank(p);
    }))) {
      throw new NoAnnotationError(typeOrFunc, params);
    }
    return ListWrapper.map(params, (function(p) {
      return _extractToken(typeOrFunc, p, params);
    }));
  }
  function _extractToken(typeOrFunc, annotations, params) {
    var depProps = [];
    var token = null;
    var optional = false;
    if (!isArray(annotations)) {
      return _createDependency(annotations, optional, DEFAULT_VISIBILITY, depProps);
    }
    var visibility = DEFAULT_VISIBILITY;
    for (var i = 0; i < annotations.length; ++i) {
      var paramAnnotation = annotations[i];
      if (paramAnnotation instanceof Type) {
        token = paramAnnotation;
      } else if (paramAnnotation instanceof InjectMetadata) {
        token = paramAnnotation.token;
      } else if (paramAnnotation instanceof OptionalMetadata) {
        optional = true;
      } else if (paramAnnotation instanceof VisibilityMetadata) {
        visibility = paramAnnotation;
      } else if (paramAnnotation instanceof DependencyMetadata) {
        if (isPresent(paramAnnotation.token)) {
          token = paramAnnotation.token;
        }
        depProps.push(paramAnnotation);
      }
    }
    token = resolveForwardRef(token);
    if (isPresent(token)) {
      return _createDependency(token, optional, visibility, depProps);
    } else {
      throw new NoAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, visibility, depProps) {
    return new Dependency(Key.get(token), optional, visibility, depProps);
  }
  $__export("bind", bind);
  return {
    setters: [function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      CONST = $__m.CONST;
      CONST_EXPR = $__m.CONST_EXPR;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
      isArray = $__m.isArray;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      Key = $__m.Key;
    }, function($__m) {
      InjectMetadata = $__m.InjectMetadata;
      VisibilityMetadata = $__m.VisibilityMetadata;
      OptionalMetadata = $__m.OptionalMetadata;
      DEFAULT_VISIBILITY = $__m.DEFAULT_VISIBILITY;
      DependencyMetadata = $__m.DependencyMetadata;
    }, function($__m) {
      NoAnnotationError = $__m.NoAnnotationError;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Dependency = (function() {
        function Dependency(key, optional, visibility, properties) {
          this.key = key;
          this.optional = optional;
          this.visibility = visibility;
          this.properties = properties;
        }
        return ($traceurRuntime.createClass)(Dependency, {}, {fromKey: function(key) {
            return new Dependency(key, false, DEFAULT_VISIBILITY, []);
          }});
      }());
      $__export("Dependency", Dependency);
      _EMPTY_LIST = CONST_EXPR([]);
      Binding = (($traceurRuntime.createClass)(function(token, $__3) {
        var $__4 = $__3,
            toClass = $__4.toClass,
            toValue = $__4.toValue,
            toAlias = $__4.toAlias,
            toFactory = $__4.toFactory,
            deps = $__4.deps;
        this.token = token;
        this.toClass = toClass;
        this.toValue = toValue;
        this.toAlias = toAlias;
        this.toFactory = toFactory;
        this.dependencies = deps;
      }, {resolve: function() {
          var $__0 = this;
          var factoryFn;
          var resolvedDeps;
          if (isPresent(this.toClass)) {
            var toClass = resolveForwardRef(this.toClass);
            factoryFn = reflector.factory(toClass);
            resolvedDeps = _dependenciesFor(toClass);
          } else if (isPresent(this.toAlias)) {
            factoryFn = (function(aliasInstance) {
              return aliasInstance;
            });
            resolvedDeps = [Dependency.fromKey(Key.get(this.toAlias))];
          } else if (isPresent(this.toFactory)) {
            factoryFn = this.toFactory;
            resolvedDeps = _constructDependencies(this.toFactory, this.dependencies);
          } else {
            factoryFn = (function() {
              return $__0.toValue;
            });
            resolvedDeps = _EMPTY_LIST;
          }
          return new ResolvedBinding(Key.get(this.token), factoryFn, resolvedDeps);
        }}, {}));
      $__export("Binding", Binding);
      $__export("Binding", Binding = __decorate([CONST(), __metadata('design:paramtypes', [Object, Object])], Binding));
      ResolvedBinding = (function() {
        function ResolvedBinding(key, factory, dependencies) {
          this.key = key;
          this.factory = factory;
          this.dependencies = dependencies;
        }
        return ($traceurRuntime.createClass)(ResolvedBinding, {}, {});
      }());
      $__export("ResolvedBinding", ResolvedBinding);
      BindingBuilder = (function() {
        function BindingBuilder(token) {
          this.token = token;
        }
        return ($traceurRuntime.createClass)(BindingBuilder, {
          toClass: function(type) {
            return new Binding(this.token, {toClass: type});
          },
          toValue: function(value) {
            return new Binding(this.token, {toValue: value});
          },
          toAlias: function(aliasToken) {
            if (isBlank(aliasToken)) {
              throw new BaseException(("Can not alias " + stringify(this.token) + " to a blank value!"));
            }
            return new Binding(this.token, {toAlias: aliasToken});
          },
          toFactory: function(factoryFunction, dependencies) {
            return new Binding(this.token, {
              toFactory: factoryFunction,
              deps: dependencies
            });
          }
        }, {});
      }());
      $__export("BindingBuilder", BindingBuilder);
    }
  };
});

System.register("angular2/src/change_detection/abstract_change_detector", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/constants"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/abstract_change_detector";
  var isPresent,
      BaseException,
      ListWrapper,
      ChangeDetectorRef,
      ChangeDetectionError,
      CHECK_ONCE,
      CHECKED,
      DETACHED,
      _Context,
      AbstractChangeDetector;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
    }, function($__m) {
      ChangeDetectionError = $__m.ChangeDetectionError;
    }, function($__m) {
      CHECK_ONCE = $__m.CHECK_ONCE;
      CHECKED = $__m.CHECKED;
      DETACHED = $__m.DETACHED;
    }],
    execute: function() {
      _Context = (function() {
        function _Context(element, componentElement, instance, context, locals, injector, expression) {
          this.element = element;
          this.componentElement = componentElement;
          this.instance = instance;
          this.context = context;
          this.locals = locals;
          this.injector = injector;
          this.expression = expression;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      AbstractChangeDetector = (function() {
        function AbstractChangeDetector(id, dispatcher) {
          this.id = id;
          this.dispatcher = dispatcher;
          this.lightDomChildren = [];
          this.shadowDomChildren = [];
          this.mode = null;
          this.ref = new ChangeDetectorRef(this);
        }
        return ($traceurRuntime.createClass)(AbstractChangeDetector, {
          addChild: function(cd) {
            this.lightDomChildren.push(cd);
            cd.parent = this;
          },
          removeChild: function(cd) {
            ListWrapper.remove(this.lightDomChildren, cd);
          },
          addShadowDomChild: function(cd) {
            this.shadowDomChildren.push(cd);
            cd.parent = this;
          },
          removeShadowDomChild: function(cd) {
            ListWrapper.remove(this.shadowDomChildren, cd);
          },
          remove: function() {
            this.parent.removeChild(this);
          },
          detectChanges: function() {
            this.runDetectChanges(false);
          },
          checkNoChanges: function() {
            throw new BaseException("Not implemented");
          },
          runDetectChanges: function(throwOnChange) {
            if (this.mode === DETACHED || this.mode === CHECKED)
              return ;
            this.detectChangesInRecords(throwOnChange);
            this._detectChangesInLightDomChildren(throwOnChange);
            if (throwOnChange === false)
              this.callOnAllChangesDone();
            this._detectChangesInShadowDomChildren(throwOnChange);
            if (this.mode === CHECK_ONCE)
              this.mode = CHECKED;
          },
          detectChangesInRecords: function(throwOnChange) {},
          hydrate: function(context, locals, directives, pipes) {},
          hydrateDirectives: function(directives) {},
          dehydrate: function() {},
          dehydrateDirectives: function(destroyPipes) {},
          callOnAllChangesDone: function() {},
          _detectChangesInLightDomChildren: function(throwOnChange) {
            var c = this.lightDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i].runDetectChanges(throwOnChange);
            }
          },
          _detectChangesInShadowDomChildren: function(throwOnChange) {
            var c = this.shadowDomChildren;
            for (var i = 0; i < c.length; ++i) {
              c[i].runDetectChanges(throwOnChange);
            }
          },
          markAsCheckOnce: function() {
            this.mode = CHECK_ONCE;
          },
          markPathToRootAsCheckOnce: function() {
            var c = this;
            while (isPresent(c) && c.mode != DETACHED) {
              if (c.mode === CHECKED)
                c.mode = CHECK_ONCE;
              c = c.parent;
            }
          },
          throwError: function(proto, exception, stack) {
            var c = this.dispatcher.getDebugContext(proto.bindingRecord.elementIndex, proto.directiveIndex);
            var context = isPresent(c) ? new _Context(c.element, c.componentElement, c.directive, c.context, c.locals, c.injector, proto.expressionAsString) : null;
            throw new ChangeDetectionError(proto, exception, stack, context);
          }
        }, {});
      }());
      $__export("AbstractChangeDetector", AbstractChangeDetector);
    }
  };
});

System.register("angular2/src/core/compiler/view_manager", ["angular2/di", "angular2/src/facade/lang", "angular2/src/core/compiler/view_ref", "angular2/src/render/api", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_listener"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/view_manager";
  var __decorate,
      __metadata,
      Injectable,
      isPresent,
      isBlank,
      BaseException,
      internalView,
      internalProtoView,
      Renderer,
      ViewType,
      AppViewManagerUtils,
      AppViewPool,
      AppViewListener,
      AppViewManager;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
    }, function($__m) {
      internalView = $__m.internalView;
      internalProtoView = $__m.internalProtoView;
    }, function($__m) {
      Renderer = $__m.Renderer;
      ViewType = $__m.ViewType;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
    }, function($__m) {
      AppViewListener = $__m.AppViewListener;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      AppViewManager = (($traceurRuntime.createClass)(function(_viewPool, _viewListener, _utils, _renderer) {
        this._viewPool = _viewPool;
        this._viewListener = _viewListener;
        this._utils = _utils;
        this._renderer = _renderer;
      }, {
        getViewContainer: function(location) {
          var hostView = internalView(location.parentView);
          return hostView.elementInjectors[location.boundElementIndex].getViewContainerRef();
        },
        getHostElement: function(hostViewRef) {
          var hostView = internalView(hostViewRef);
          if (hostView.proto.type !== ViewType.HOST) {
            throw new BaseException('This operation is only allowed on host views');
          }
          return hostView.elementRefs[hostView.elementOffset];
        },
        getNamedElementInComponentView: function(hostLocation, variableName) {
          var hostView = internalView(hostLocation.parentView);
          var boundElementIndex = hostLocation.boundElementIndex;
          var componentView = hostView.getNestedView(boundElementIndex);
          if (isBlank(componentView)) {
            throw new BaseException(("There is no component directive at element " + boundElementIndex));
          }
          var binderIdx = componentView.proto.variableLocations.get(variableName);
          if (isBlank(binderIdx)) {
            throw new BaseException(("Could not find variable " + variableName));
          }
          return componentView.elementRefs[componentView.elementOffset + binderIdx];
        },
        getComponent: function(hostLocation) {
          var hostView = internalView(hostLocation.parentView);
          var boundElementIndex = hostLocation.boundElementIndex;
          return this._utils.getComponentInstance(hostView, boundElementIndex);
        },
        createRootHostView: function(hostProtoViewRef, overrideSelector, injector) {
          var hostProtoView = internalProtoView(hostProtoViewRef);
          var hostElementSelector = overrideSelector;
          if (isBlank(hostElementSelector)) {
            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
          }
          var renderViewWithFragments = this._renderer.createRootHostView(hostProtoView.mergeMapping.renderProtoViewRef, hostProtoView.mergeMapping.renderFragmentCount, hostElementSelector);
          var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
          this._renderer.hydrateView(hostView.render);
          this._utils.hydrateRootHostView(hostView, injector);
          return hostView.ref;
        },
        destroyRootHostView: function(hostViewRef) {
          var hostView = internalView(hostViewRef);
          this._renderer.detachFragment(hostView.renderFragment);
          this._renderer.dehydrateView(hostView.render);
          this._viewDehydrateRecurse(hostView);
          this._viewListener.viewDestroyed(hostView);
          this._renderer.destroyView(hostView.render);
        },
        createEmbeddedViewInContainer: function(viewContainerLocation, atIndex, templateRef) {
          var protoView = internalProtoView(templateRef.protoViewRef);
          if (protoView.type !== ViewType.EMBEDDED) {
            throw new BaseException('This method can only be called with embedded ProtoViews!');
          }
          return this._createViewInContainer(viewContainerLocation, atIndex, protoView, templateRef.elementRef, null);
        },
        createHostViewInContainer: function(viewContainerLocation, atIndex, protoViewRef, imperativelyCreatedInjector) {
          var protoView = internalProtoView(protoViewRef);
          if (protoView.type !== ViewType.HOST) {
            throw new BaseException('This method can only be called with host ProtoViews!');
          }
          return this._createViewInContainer(viewContainerLocation, atIndex, protoView, viewContainerLocation, imperativelyCreatedInjector);
        },
        _createViewInContainer: function(viewContainerLocation, atIndex, protoView, context, imperativelyCreatedInjector) {
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          var contextView = internalView(context.parentView);
          var contextBoundElementIndex = context.boundElementIndex;
          var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
          var view;
          if (protoView.type === ViewType.EMBEDDED && isPresent(embeddedFragmentView) && !embeddedFragmentView.hydrated()) {
            view = embeddedFragmentView;
            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
          } else {
            view = this._createPooledView(protoView);
            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
            this._renderer.hydrateView(view.render);
          }
          this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view);
          this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedInjector);
          return view.ref;
        },
        _attachRenderView: function(parentView, boundElementIndex, atIndex, view) {
          var elementRef = parentView.elementRefs[boundElementIndex];
          if (atIndex === 0) {
            this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
          } else {
            var prevView = parentView.viewContainers[boundElementIndex].views[atIndex - 1];
            this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
          }
        },
        destroyViewInContainer: function(viewContainerLocation, atIndex) {
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          this._destroyViewInContainer(parentView, boundElementIndex, atIndex);
        },
        attachViewInContainer: function(viewContainerLocation, atIndex, viewRef) {
          var view = internalView(viewRef);
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, atIndex, view);
          this._attachRenderView(parentView, boundElementIndex, atIndex, view);
          return viewRef;
        },
        detachViewInContainer: function(viewContainerLocation, atIndex) {
          var parentView = internalView(viewContainerLocation.parentView);
          var boundElementIndex = viewContainerLocation.boundElementIndex;
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
          this._renderer.detachFragment(view.renderFragment);
          return view.ref;
        },
        _createMainView: function(protoView, renderViewWithFragments) {
          var mergedParentView = this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
          this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
          this._viewListener.viewCreated(mergedParentView);
          return mergedParentView;
        },
        _createPooledView: function(protoView) {
          var view = this._viewPool.getView(protoView);
          if (isBlank(view)) {
            view = this._createMainView(protoView, this._renderer.createView(protoView.mergeMapping.renderProtoViewRef, protoView.mergeMapping.renderFragmentCount));
          }
          return view;
        },
        _destroyPooledView: function(view) {
          var wasReturned = this._viewPool.returnView(view);
          if (!wasReturned) {
            this._viewListener.viewDestroyed(view);
            this._renderer.destroyView(view.render);
          }
        },
        _destroyViewInContainer: function(parentView, boundElementIndex, atIndex) {
          var viewContainer = parentView.viewContainers[boundElementIndex];
          var view = viewContainer.views[atIndex];
          this._viewDehydrateRecurse(view);
          this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
          if (view.viewOffset > 0) {
            this._renderer.detachFragment(view.renderFragment);
          } else {
            this._renderer.dehydrateView(view.render);
            this._renderer.detachFragment(view.renderFragment);
            this._destroyPooledView(view);
          }
        },
        _viewDehydrateRecurse: function(view) {
          if (view.hydrated()) {
            this._utils.dehydrateView(view);
          }
          var viewContainers = view.viewContainers;
          var startViewOffset = view.viewOffset;
          var endViewOffset = view.viewOffset + view.mainMergeMapping.nestedViewCountByViewIndex[view.viewOffset];
          var elementOffset = view.elementOffset;
          for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
            var currView = view.views[viewIdx];
            for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length; binderIdx++, elementOffset++) {
              var vc = viewContainers[elementOffset];
              if (isPresent(vc)) {
                for (var j = vc.views.length - 1; j >= 0; j--) {
                  this._destroyViewInContainer(currView, elementOffset, j);
                }
              }
            }
          }
        }
      }, {}));
      $__export("AppViewManager", AppViewManager);
      $__export("AppViewManager", AppViewManager = __decorate([Injectable(), __metadata('design:paramtypes', [AppViewPool, AppViewListener, AppViewManagerUtils, Renderer])], AppViewManager));
    }
  };
});

System.register("angular2/src/render/dom/compiler/view_loader", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/dom/dom_adapter", "angular2/src/render/xhr", "angular2/src/render/dom/compiler/style_inliner", "angular2/src/render/dom/compiler/style_url_resolver"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/view_loader";
  var __decorate,
      __metadata,
      Injectable,
      isBlank,
      isPresent,
      BaseException,
      isPromise,
      StringWrapper,
      Map,
      MapWrapper,
      ListWrapper,
      PromiseWrapper,
      DOM,
      XHR,
      StyleInliner,
      StyleUrlResolver,
      TemplateAndStyles,
      ViewLoader;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      isPromise = $__m.isPromise;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      TemplateAndStyles = (function() {
        function TemplateAndStyles(template, styles) {
          this.template = template;
          this.styles = styles;
        }
        return ($traceurRuntime.createClass)(TemplateAndStyles, {}, {});
      }());
      $__export("TemplateAndStyles", TemplateAndStyles);
      ViewLoader = (($traceurRuntime.createClass)(function(_xhr, _styleInliner, _styleUrlResolver) {
        this._xhr = _xhr;
        this._styleInliner = _styleInliner;
        this._styleUrlResolver = _styleUrlResolver;
        this._cache = new Map();
      }, {
        load: function(viewDef) {
          var $__0 = this;
          var tplAndStyles = [this._loadHtml(viewDef.template, viewDef.templateAbsUrl)];
          if (isPresent(viewDef.styles)) {
            viewDef.styles.forEach((function(cssText) {
              var textOrPromise = $__0._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl);
              tplAndStyles.push(textOrPromise);
            }));
          }
          if (isPresent(viewDef.styleAbsUrls)) {
            viewDef.styleAbsUrls.forEach((function(url) {
              var promise = $__0._loadText(url).then((function(cssText) {
                return $__0._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl);
              }));
              tplAndStyles.push(promise);
            }));
          }
          return PromiseWrapper.all(tplAndStyles).then((function(res) {
            var loadedTplAndStyles = res[0];
            var styles = ListWrapper.slice(res, 1);
            return new TemplateAndStyles(loadedTplAndStyles.template, loadedTplAndStyles.styles.concat(styles));
          }));
        },
        _loadText: function(url) {
          var response = this._cache.get(url);
          if (isBlank(response)) {
            response = PromiseWrapper.catchError(this._xhr.get(url), (function(_) {
              return PromiseWrapper.reject(new BaseException(("Failed to fetch url \"" + url + "\"")), null);
            }));
            this._cache.set(url, response);
          }
          return response;
        },
        _loadHtml: function(template, templateAbsUrl) {
          var $__0 = this;
          var html;
          if (isPresent(template)) {
            html = PromiseWrapper.resolve(template);
          } else if (isPresent(templateAbsUrl)) {
            html = this._loadText(templateAbsUrl);
          } else {
            throw new BaseException('View should have either the templateUrl or template property set');
          }
          return html.then((function(html) {
            var tplEl = DOM.createTemplate(html);
            if (isPresent(templateAbsUrl) && templateAbsUrl.indexOf("/") >= 0) {
              var baseUrl = templateAbsUrl.substring(0, templateAbsUrl.lastIndexOf("/"));
              $__0._substituteBaseUrl(DOM.content(tplEl), baseUrl);
            }
            var styleEls = DOM.querySelectorAll(DOM.content(tplEl), 'STYLE');
            var unresolvedStyles = [];
            for (var i = 0; i < styleEls.length; i++) {
              var styleEl = styleEls[i];
              unresolvedStyles.push(DOM.getText(styleEl));
              DOM.remove(styleEl);
            }
            var syncStyles = [];
            var asyncStyles = [];
            for (var i$__3 = 0; i$__3 < styleEls.length; i$__3++) {
              var styleEl = styleEls[i$__3];
              var resolvedStyled = $__0._resolveAndInlineCssText(DOM.getText(styleEl), templateAbsUrl);
              if (isPromise(resolvedStyled)) {
                asyncStyles.push(resolvedStyled);
              } else {
                syncStyles.push(resolvedStyled);
              }
            }
            if (asyncStyles.length === 0) {
              return PromiseWrapper.resolve(new TemplateAndStyles(DOM.getInnerHTML(tplEl), syncStyles));
            } else {
              return PromiseWrapper.all(asyncStyles).then((function(loadedStyles) {
                return new TemplateAndStyles(DOM.getInnerHTML(tplEl), syncStyles.concat(loadedStyles));
              }));
            }
          }));
        },
        _substituteBaseUrl: function(element, baseUrl) {
          if (DOM.isElementNode(element)) {
            var attrs = DOM.attributeMap(element);
            MapWrapper.forEach(attrs, (function(v, k) {
              if (isPresent(v) && v.indexOf('$baseUrl') >= 0) {
                DOM.setAttribute(element, k, StringWrapper.replaceAll(v, /\$baseUrl/g, baseUrl));
              }
            }));
          }
          var children = DOM.childNodes(element);
          for (var i = 0; i < children.length; i++) {
            if (DOM.isElementNode(children[i])) {
              this._substituteBaseUrl(children[i], baseUrl);
            }
          }
        },
        _resolveAndInlineCssText: function(cssText, baseUrl) {
          cssText = this._styleUrlResolver.resolveUrls(cssText, baseUrl);
          return this._styleInliner.inlineImports(cssText, baseUrl);
        }
      }, {}));
      $__export("ViewLoader", ViewLoader);
      $__export("ViewLoader", ViewLoader = __decorate([Injectable(), __metadata('design:paramtypes', [XHR, StyleInliner, StyleUrlResolver])], ViewLoader));
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_pipeline", ["angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/dom/compiler/compile_element", "angular2/src/render/dom/compiler/compile_control", "angular2/src/render/dom/view/proto_view_builder"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_pipeline";
  var isPresent,
      DOM,
      CompileElement,
      CompileControl,
      ProtoViewBuilder,
      CompilePipeline;
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      CompileElement = $__m.CompileElement;
    }, function($__m) {
      CompileControl = $__m.CompileControl;
    }, function($__m) {
      ProtoViewBuilder = $__m.ProtoViewBuilder;
    }],
    execute: function() {
      CompilePipeline = (function() {
        function CompilePipeline(steps) {
          this.steps = steps;
          this._control = new CompileControl(steps);
        }
        return ($traceurRuntime.createClass)(CompilePipeline, {
          processStyles: function(styles) {
            var $__0 = this;
            return styles.map((function(style) {
              $__0.steps.forEach((function(step) {
                style = step.processStyle(style);
              }));
              return style;
            }));
          },
          processElements: function(rootElement, protoViewType, viewDef) {
            var results = [];
            var compilationCtxtDescription = viewDef.componentId;
            var rootCompileElement = new CompileElement(rootElement, compilationCtxtDescription);
            rootCompileElement.inheritedProtoView = new ProtoViewBuilder(rootElement, protoViewType, viewDef.encapsulation);
            rootCompileElement.isViewRoot = true;
            this._processElement(results, null, rootCompileElement, compilationCtxtDescription);
            return results;
          },
          _processElement: function(results, parent, current) {
            var compilationCtxtDescription = arguments[3] !== (void 0) ? arguments[3] : '';
            var additionalChildren = this._control.internalProcess(results, 0, parent, current);
            if (current.compileChildren) {
              var node = DOM.firstChild(DOM.templateAwareRoot(current.element));
              while (isPresent(node)) {
                var nextNode = DOM.nextSibling(node);
                if (DOM.isElementNode(node)) {
                  var childCompileElement = new CompileElement(node, compilationCtxtDescription);
                  childCompileElement.inheritedProtoView = current.inheritedProtoView;
                  childCompileElement.inheritedElementBinder = current.inheritedElementBinder;
                  childCompileElement.distanceToInheritedBinder = current.distanceToInheritedBinder + 1;
                  this._processElement(results, current, childCompileElement);
                }
                node = nextNode;
              }
            }
            if (isPresent(additionalChildren)) {
              for (var i = 0; i < additionalChildren.length; i++) {
                this._processElement(results, current, additionalChildren[i]);
              }
            }
          }
        }, {});
      }());
      $__export("CompilePipeline", CompilePipeline);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compile_step_factory", ["angular2/src/render/dom/compiler/property_binding_parser", "angular2/src/render/dom/compiler/text_interpolation_parser", "angular2/src/render/dom/compiler/directive_parser", "angular2/src/render/dom/compiler/view_splitter", "angular2/src/render/dom/compiler/style_encapsulator"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compile_step_factory";
  var PropertyBindingParser,
      TextInterpolationParser,
      DirectiveParser,
      ViewSplitter,
      StyleEncapsulator,
      CompileStepFactory,
      DefaultStepFactory;
  return {
    setters: [function($__m) {
      PropertyBindingParser = $__m.PropertyBindingParser;
    }, function($__m) {
      TextInterpolationParser = $__m.TextInterpolationParser;
    }, function($__m) {
      DirectiveParser = $__m.DirectiveParser;
    }, function($__m) {
      ViewSplitter = $__m.ViewSplitter;
    }, function($__m) {
      StyleEncapsulator = $__m.StyleEncapsulator;
    }],
    execute: function() {
      CompileStepFactory = (function() {
        function CompileStepFactory() {}
        return ($traceurRuntime.createClass)(CompileStepFactory, {createSteps: function(view) {
            return null;
          }}, {});
      }());
      $__export("CompileStepFactory", CompileStepFactory);
      DefaultStepFactory = (function($__super) {
        function DefaultStepFactory(_parser, _appId) {
          $traceurRuntime.superConstructor(DefaultStepFactory).call(this);
          this._parser = _parser;
          this._appId = _appId;
          this._componentUIDsCache = new Map();
        }
        return ($traceurRuntime.createClass)(DefaultStepFactory, {createSteps: function(view) {
            return [new ViewSplitter(this._parser), new PropertyBindingParser(this._parser), new DirectiveParser(this._parser, view.directives), new TextInterpolationParser(this._parser), new StyleEncapsulator(this._appId, view, this._componentUIDsCache)];
          }}, {}, $__super);
      }(CompileStepFactory));
      $__export("DefaultStepFactory", DefaultStepFactory);
    }
  };
});

System.register("angular2/src/http/http", ["angular2/src/facade/lang", "angular2/src/di/decorators", "angular2/src/http/interfaces", "angular2/src/http/static_request", "angular2/src/http/base_request_options", "angular2/src/http/enums"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/http";
  var __decorate,
      __metadata,
      isString,
      isPresent,
      makeTypeError,
      Injectable,
      ConnectionBackend,
      Request,
      RequestOptions,
      RequestMethods,
      Http,
      Jsonp;
  function httpRequest(backend, request) {
    return backend.createConnection(request).response;
  }
  function mergeOptions(defaultOpts, providedOpts, method, url) {
    var newOptions = defaultOpts;
    if (isPresent(providedOpts)) {
      newOptions = newOptions.merge(new RequestOptions({
        method: providedOpts.method,
        url: providedOpts.url,
        headers: providedOpts.headers,
        body: providedOpts.body,
        mode: providedOpts.mode,
        credentials: providedOpts.credentials,
        cache: providedOpts.cache
      }));
    }
    if (isPresent(method)) {
      return newOptions.merge(new RequestOptions({
        method: method,
        url: url
      }));
    } else {
      return newOptions.merge(new RequestOptions({url: url}));
    }
  }
  return {
    setters: [function($__m) {
      isString = $__m.isString;
      isPresent = $__m.isPresent;
      makeTypeError = $__m.makeTypeError;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      ConnectionBackend = $__m.ConnectionBackend;
    }, function($__m) {
      Request = $__m.Request;
    }, function($__m) {
      RequestOptions = $__m.RequestOptions;
    }, function($__m) {
      RequestMethods = $__m.RequestMethods;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Http = (($traceurRuntime.createClass)(function(_backend, _defaultOptions) {
        this._backend = _backend;
        this._defaultOptions = _defaultOptions;
      }, {
        request: function(url, options) {
          var responseObservable;
          if (isString(url)) {
            responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethods.GET, url)));
          } else if (url instanceof Request) {
            responseObservable = httpRequest(this._backend, url);
          }
          return responseObservable;
        },
        get: function(url, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethods.GET, url)));
        },
        post: function(url, body, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, RequestMethods.POST, url)));
        },
        put: function(url, body, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, RequestMethods.PUT, url)));
        },
        delete: function(url, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethods.DELETE, url)));
        },
        patch: function(url, body, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({body: body})), options, RequestMethods.PATCH, url)));
        },
        head: function(url, options) {
          return httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethods.HEAD, url)));
        }
      }, {}));
      $__export("Http", Http);
      $__export("Http", Http = __decorate([Injectable(), __metadata('design:paramtypes', [ConnectionBackend, RequestOptions])], Http));
      Jsonp = (function($__super) {
        function $__0(backend, defaultOptions) {
          $traceurRuntime.superConstructor($__0).call(this, backend, defaultOptions);
        }
        return ($traceurRuntime.createClass)($__0, {request: function(url, options) {
            var responseObservable;
            if (isString(url)) {
              url = new Request(mergeOptions(this._defaultOptions, options, RequestMethods.GET, url));
            }
            if (url instanceof Request) {
              if (url.method !== RequestMethods.GET) {
                makeTypeError('JSONP requests must use GET request method.');
              }
              responseObservable = httpRequest(this._backend, url);
            }
            return responseObservable;
          }}, {}, $__super);
      }(Http));
      $__export("Jsonp", Jsonp);
      $__export("Jsonp", Jsonp = __decorate([Injectable(), __metadata('design:paramtypes', [ConnectionBackend, RequestOptions])], Jsonp));
    }
  };
});

System.register("angular2/src/http/backends/xhr_backend", ["angular2/src/http/enums", "angular2/src/http/static_response", "angular2/src/http/base_response_options", "angular2/di", "angular2/src/http/backends/browser_xhr", "angular2/src/facade/async", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/http/backends/xhr_backend";
  var __decorate,
      __metadata,
      RequestMethodsMap,
      Response,
      ResponseOptions,
      Injectable,
      BrowserXhr,
      EventEmitter,
      ObservableWrapper,
      isPresent,
      ENUM_INDEX,
      XHRConnection,
      XHRBackend;
  return {
    setters: [function($__m) {
      RequestMethodsMap = $__m.RequestMethodsMap;
    }, function($__m) {
      Response = $__m.Response;
    }, function($__m) {
      ResponseOptions = $__m.ResponseOptions;
    }, function($__m) {
      Injectable = $__m.Injectable;
    }, function($__m) {
      BrowserXhr = $__m.BrowserXhr;
    }, function($__m) {
      EventEmitter = $__m.EventEmitter;
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      isPresent = $__m.isPresent;
      ENUM_INDEX = $__m.ENUM_INDEX;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      XHRConnection = (function() {
        function XHRConnection(req, browserXHR, baseResponseOptions) {
          var $__0 = this;
          var requestMethodsMap = new RequestMethodsMap();
          this.request = req;
          this.response = new EventEmitter();
          this._xhr = browserXHR.build();
          this._xhr.open(requestMethodsMap.getMethod(ENUM_INDEX(req.method)), req.url);
          this._xhr.addEventListener('load', (function(_) {
            var responseOptions = new ResponseOptions({body: isPresent($__0._xhr.response) ? $__0._xhr.response : $__0._xhr.responseText});
            if (isPresent(baseResponseOptions)) {
              responseOptions = baseResponseOptions.merge(responseOptions);
            }
            ObservableWrapper.callNext($__0.response, new Response(responseOptions));
            ObservableWrapper.callReturn($__0.response);
          }));
          if (isPresent(req.headers)) {
            req.headers.forEach((function(value, name) {
              $__0._xhr.setRequestHeader(name, value);
            }));
          }
          this._xhr.send(this.request.text());
        }
        return ($traceurRuntime.createClass)(XHRConnection, {dispose: function() {
            this._xhr.abort();
          }}, {});
      }());
      $__export("XHRConnection", XHRConnection);
      XHRBackend = (($traceurRuntime.createClass)(function(_browserXHR, _baseResponseOptions) {
        this._browserXHR = _browserXHR;
        this._baseResponseOptions = _baseResponseOptions;
      }, {createConnection: function(request) {
          return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
        }}, {}));
      $__export("XHRBackend", XHRBackend);
      $__export("XHRBackend", XHRBackend = __decorate([Injectable(), __metadata('design:paramtypes', [BrowserXhr, ResponseOptions])], XHRBackend));
    }
  };
});

System.register("angular2/forms", ["angular2/src/forms/model", "angular2/src/forms/directives/abstract_control_directive", "angular2/src/forms/directives/control_container", "angular2/src/forms/directives/ng_control_name", "angular2/src/forms/directives/ng_form_control", "angular2/src/forms/directives/ng_model", "angular2/src/forms/directives/ng_control", "angular2/src/forms/directives/ng_control_group", "angular2/src/forms/directives/ng_form_model", "angular2/src/forms/directives/ng_form", "angular2/src/forms/directives/default_value_accessor", "angular2/src/forms/directives/checkbox_value_accessor", "angular2/src/forms/directives/select_control_value_accessor", "angular2/src/forms/directives", "angular2/src/forms/validators", "angular2/src/forms/directives/validators", "angular2/src/forms/form_builder", "angular2/src/facade/lang"], function($__export) {
  "use strict";
  var __moduleName = "angular2/forms";
  var FormBuilder,
      CONST_EXPR,
      formInjectables;
  return {
    setters: [function($__m) {
      $__export("AbstractControl", $__m.AbstractControl);
      $__export("Control", $__m.Control);
      $__export("ControlGroup", $__m.ControlGroup);
      $__export("ControlArray", $__m.ControlArray);
    }, function($__m) {
      $__export("AbstractControlDirective", $__m.AbstractControlDirective);
    }, function($__m) {
      $__export("ControlContainer", $__m.ControlContainer);
    }, function($__m) {
      $__export("NgControlName", $__m.NgControlName);
    }, function($__m) {
      $__export("NgFormControl", $__m.NgFormControl);
    }, function($__m) {
      $__export("NgModel", $__m.NgModel);
    }, function($__m) {
      $__export("NgControl", $__m.NgControl);
    }, function($__m) {
      $__export("NgControlGroup", $__m.NgControlGroup);
    }, function($__m) {
      $__export("NgFormModel", $__m.NgFormModel);
    }, function($__m) {
      $__export("NgForm", $__m.NgForm);
    }, function($__m) {
      $__export("DefaultValueAccessor", $__m.DefaultValueAccessor);
    }, function($__m) {
      $__export("CheckboxControlValueAccessor", $__m.CheckboxControlValueAccessor);
    }, function($__m) {
      $__export("NgSelectOption", $__m.NgSelectOption);
      $__export("SelectControlValueAccessor", $__m.SelectControlValueAccessor);
    }, function($__m) {
      $__export("formDirectives", $__m.formDirectives);
    }, function($__m) {
      $__export("Validators", $__m.Validators);
    }, function($__m) {
      $__export("NgValidator", $__m.NgValidator);
      $__export("NgRequiredValidator", $__m.NgRequiredValidator);
    }, function($__m) {
      FormBuilder = $__m.FormBuilder;
      $__export("FormBuilder", $__m.FormBuilder);
    }, function($__m) {
      CONST_EXPR = $__m.CONST_EXPR;
    }],
    execute: function() {
      formInjectables = CONST_EXPR([FormBuilder]);
      $__export("formInjectables", formInjectables);
    }
  };
});

System.register("angular2/src/di/injector", ["angular2/src/facade/collection", "angular2/src/di/binding", "angular2/src/di/exceptions", "angular2/src/facade/lang", "angular2/src/di/key", "angular2/src/di/forward_ref", "angular2/src/di/metadata"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/di/injector";
  var Map,
      List,
      MapWrapper,
      ListWrapper,
      ResolvedBinding,
      Binding,
      BindingBuilder,
      bind,
      AbstractBindingError,
      NoBindingError,
      CyclicDependencyError,
      InstantiationError,
      InvalidBindingError,
      OutOfBoundsError,
      Type,
      isPresent,
      CONST_EXPR,
      Key,
      resolveForwardRef,
      DEFAULT_VISIBILITY,
      SelfMetadata,
      AncestorMetadata,
      _constructing,
      _notFound,
      _MAX_CONSTRUCTION_COUNTER,
      undefinedValue,
      PUBLIC,
      PRIVATE,
      PUBLIC_AND_PRIVATE,
      ProtoInjectorInlineStrategy,
      ProtoInjectorDynamicStrategy,
      ProtoInjector,
      InjectorInlineStrategy,
      InjectorDynamicStrategy,
      BindingWithVisibility,
      Injector,
      INJECTOR_KEY;
  function _resolveBindings(bindings) {
    var resolvedList = ListWrapper.createFixedSize(bindings.length);
    for (var i = 0; i < bindings.length; i++) {
      var unresolved = resolveForwardRef(bindings[i]);
      var resolved = void 0;
      if (unresolved instanceof ResolvedBinding) {
        resolved = unresolved;
      } else if (unresolved instanceof Type) {
        resolved = bind(unresolved).toClass(unresolved).resolve();
      } else if (unresolved instanceof Binding) {
        resolved = unresolved.resolve();
      } else if (unresolved instanceof List) {
        resolved = _resolveBindings(unresolved);
      } else if (unresolved instanceof BindingBuilder) {
        throw new InvalidBindingError(unresolved.token);
      } else {
        throw new InvalidBindingError(unresolved);
      }
      resolvedList[i] = resolved;
    }
    return resolvedList;
  }
  function _createListOfBindings(flattenedBindings) {
    return MapWrapper.values(flattenedBindings);
  }
  function _flattenBindings(bindings, res) {
    ListWrapper.forEach(bindings, function(b) {
      if (b instanceof ResolvedBinding) {
        res.set(b.key.id, b);
      } else if (b instanceof List) {
        _flattenBindings(b, res);
      }
    });
    return res;
  }
  function _mapBindings(injector, fn) {
    var res = [];
    for (var i = 0; i < injector._proto.numberOfBindings; ++i) {
      res.push(fn(injector._proto.getBindingAtIndex(i)));
    }
    return res;
  }
  return {
    setters: [function($__m) {
      Map = $__m.Map;
      List = $__m.List;
      MapWrapper = $__m.MapWrapper;
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ResolvedBinding = $__m.ResolvedBinding;
      Binding = $__m.Binding;
      BindingBuilder = $__m.BindingBuilder;
      bind = $__m.bind;
    }, function($__m) {
      AbstractBindingError = $__m.AbstractBindingError;
      NoBindingError = $__m.NoBindingError;
      CyclicDependencyError = $__m.CyclicDependencyError;
      InstantiationError = $__m.InstantiationError;
      InvalidBindingError = $__m.InvalidBindingError;
      OutOfBoundsError = $__m.OutOfBoundsError;
    }, function($__m) {
      Type = $__m.Type;
      isPresent = $__m.isPresent;
      CONST_EXPR = $__m.CONST_EXPR;
    }, function($__m) {
      Key = $__m.Key;
    }, function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
    }, function($__m) {
      DEFAULT_VISIBILITY = $__m.DEFAULT_VISIBILITY;
      SelfMetadata = $__m.SelfMetadata;
      AncestorMetadata = $__m.AncestorMetadata;
    }],
    execute: function() {
      _constructing = CONST_EXPR(new Object());
      _notFound = CONST_EXPR(new Object());
      _MAX_CONSTRUCTION_COUNTER = 10;
      undefinedValue = CONST_EXPR(new Object());
      $__export("undefinedValue", undefinedValue);
      PUBLIC = 1;
      $__export("PUBLIC", PUBLIC);
      PRIVATE = 2;
      $__export("PRIVATE", PRIVATE);
      PUBLIC_AND_PRIVATE = 3;
      $__export("PUBLIC_AND_PRIVATE", PUBLIC_AND_PRIVATE);
      ProtoInjectorInlineStrategy = (function() {
        function ProtoInjectorInlineStrategy(protoEI, bwv) {
          this.binding0 = null;
          this.binding1 = null;
          this.binding2 = null;
          this.binding3 = null;
          this.binding4 = null;
          this.binding5 = null;
          this.binding6 = null;
          this.binding7 = null;
          this.binding8 = null;
          this.binding9 = null;
          this.keyId0 = null;
          this.keyId1 = null;
          this.keyId2 = null;
          this.keyId3 = null;
          this.keyId4 = null;
          this.keyId5 = null;
          this.keyId6 = null;
          this.keyId7 = null;
          this.keyId8 = null;
          this.keyId9 = null;
          this.visibility0 = null;
          this.visibility1 = null;
          this.visibility2 = null;
          this.visibility3 = null;
          this.visibility4 = null;
          this.visibility5 = null;
          this.visibility6 = null;
          this.visibility7 = null;
          this.visibility8 = null;
          this.visibility9 = null;
          var length = bwv.length;
          if (length > 0) {
            this.binding0 = bwv[0].binding;
            this.keyId0 = bwv[0].getKeyId();
            this.visibility0 = bwv[0].visibility;
          }
          if (length > 1) {
            this.binding1 = bwv[1].binding;
            this.keyId1 = bwv[1].getKeyId();
            this.visibility1 = bwv[1].visibility;
          }
          if (length > 2) {
            this.binding2 = bwv[2].binding;
            this.keyId2 = bwv[2].getKeyId();
            this.visibility2 = bwv[2].visibility;
          }
          if (length > 3) {
            this.binding3 = bwv[3].binding;
            this.keyId3 = bwv[3].getKeyId();
            this.visibility3 = bwv[3].visibility;
          }
          if (length > 4) {
            this.binding4 = bwv[4].binding;
            this.keyId4 = bwv[4].getKeyId();
            this.visibility4 = bwv[4].visibility;
          }
          if (length > 5) {
            this.binding5 = bwv[5].binding;
            this.keyId5 = bwv[5].getKeyId();
            this.visibility5 = bwv[5].visibility;
          }
          if (length > 6) {
            this.binding6 = bwv[6].binding;
            this.keyId6 = bwv[6].getKeyId();
            this.visibility6 = bwv[6].visibility;
          }
          if (length > 7) {
            this.binding7 = bwv[7].binding;
            this.keyId7 = bwv[7].getKeyId();
            this.visibility7 = bwv[7].visibility;
          }
          if (length > 8) {
            this.binding8 = bwv[8].binding;
            this.keyId8 = bwv[8].getKeyId();
            this.visibility8 = bwv[8].visibility;
          }
          if (length > 9) {
            this.binding9 = bwv[9].binding;
            this.keyId9 = bwv[9].getKeyId();
            this.visibility9 = bwv[9].visibility;
          }
        }
        return ($traceurRuntime.createClass)(ProtoInjectorInlineStrategy, {
          getBindingAtIndex: function(index) {
            if (index == 0)
              return this.binding0;
            if (index == 1)
              return this.binding1;
            if (index == 2)
              return this.binding2;
            if (index == 3)
              return this.binding3;
            if (index == 4)
              return this.binding4;
            if (index == 5)
              return this.binding5;
            if (index == 6)
              return this.binding6;
            if (index == 7)
              return this.binding7;
            if (index == 8)
              return this.binding8;
            if (index == 9)
              return this.binding9;
            throw new OutOfBoundsError(index);
          },
          createInjectorStrategy: function(injector) {
            return new InjectorInlineStrategy(injector, this);
          }
        }, {});
      }());
      $__export("ProtoInjectorInlineStrategy", ProtoInjectorInlineStrategy);
      ProtoInjectorDynamicStrategy = (function() {
        function ProtoInjectorDynamicStrategy(protoInj, bwv) {
          var len = bwv.length;
          this.bindings = ListWrapper.createFixedSize(len);
          this.keyIds = ListWrapper.createFixedSize(len);
          this.visibilities = ListWrapper.createFixedSize(len);
          for (var i = 0; i < len; i++) {
            this.bindings[i] = bwv[i].binding;
            this.keyIds[i] = bwv[i].getKeyId();
            this.visibilities[i] = bwv[i].visibility;
          }
        }
        return ($traceurRuntime.createClass)(ProtoInjectorDynamicStrategy, {
          getBindingAtIndex: function(index) {
            if (index < 0 || index >= this.bindings.length) {
              throw new OutOfBoundsError(index);
            }
            return this.bindings[index];
          },
          createInjectorStrategy: function(ei) {
            return new InjectorDynamicStrategy(this, ei);
          }
        }, {});
      }());
      $__export("ProtoInjectorDynamicStrategy", ProtoInjectorDynamicStrategy);
      ProtoInjector = (function() {
        function ProtoInjector(bwv) {
          this.numberOfBindings = bwv.length;
          this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ? new ProtoInjectorDynamicStrategy(this, bwv) : new ProtoInjectorInlineStrategy(this, bwv);
        }
        return ($traceurRuntime.createClass)(ProtoInjector, {getBindingAtIndex: function(index) {
            return this._strategy.getBindingAtIndex(index);
          }}, {});
      }());
      $__export("ProtoInjector", ProtoInjector);
      InjectorInlineStrategy = (function() {
        function InjectorInlineStrategy(injector, protoStrategy) {
          this.injector = injector;
          this.protoStrategy = protoStrategy;
          this.obj0 = undefinedValue;
          this.obj1 = undefinedValue;
          this.obj2 = undefinedValue;
          this.obj3 = undefinedValue;
          this.obj4 = undefinedValue;
          this.obj5 = undefinedValue;
          this.obj6 = undefinedValue;
          this.obj7 = undefinedValue;
          this.obj8 = undefinedValue;
          this.obj9 = undefinedValue;
        }
        return ($traceurRuntime.createClass)(InjectorInlineStrategy, {
          resetConstructionCounter: function() {
            this.injector._constructionCounter = 0;
          },
          instantiateBinding: function(binding, visibility) {
            return this.injector._new(binding, visibility);
          },
          attach: function(parent, isBoundary) {
            var inj = this.injector;
            inj._parent = parent;
            inj._isBoundary = isBoundary;
          },
          getObjByKeyId: function(keyId, visibility) {
            var p = this.protoStrategy;
            var inj = this.injector;
            if (p.keyId0 === keyId && (p.visibility0 & visibility) > 0) {
              if (this.obj0 === undefinedValue) {
                this.obj0 = inj._new(p.binding0, p.visibility0);
              }
              return this.obj0;
            }
            if (p.keyId1 === keyId && (p.visibility1 & visibility) > 0) {
              if (this.obj1 === undefinedValue) {
                this.obj1 = inj._new(p.binding1, p.visibility1);
              }
              return this.obj1;
            }
            if (p.keyId2 === keyId && (p.visibility2 & visibility) > 0) {
              if (this.obj2 === undefinedValue) {
                this.obj2 = inj._new(p.binding2, p.visibility2);
              }
              return this.obj2;
            }
            if (p.keyId3 === keyId && (p.visibility3 & visibility) > 0) {
              if (this.obj3 === undefinedValue) {
                this.obj3 = inj._new(p.binding3, p.visibility3);
              }
              return this.obj3;
            }
            if (p.keyId4 === keyId && (p.visibility4 & visibility) > 0) {
              if (this.obj4 === undefinedValue) {
                this.obj4 = inj._new(p.binding4, p.visibility4);
              }
              return this.obj4;
            }
            if (p.keyId5 === keyId && (p.visibility5 & visibility) > 0) {
              if (this.obj5 === undefinedValue) {
                this.obj5 = inj._new(p.binding5, p.visibility5);
              }
              return this.obj5;
            }
            if (p.keyId6 === keyId && (p.visibility6 & visibility) > 0) {
              if (this.obj6 === undefinedValue) {
                this.obj6 = inj._new(p.binding6, p.visibility6);
              }
              return this.obj6;
            }
            if (p.keyId7 === keyId && (p.visibility7 & visibility) > 0) {
              if (this.obj7 === undefinedValue) {
                this.obj7 = inj._new(p.binding7, p.visibility7);
              }
              return this.obj7;
            }
            if (p.keyId8 === keyId && (p.visibility8 & visibility) > 0) {
              if (this.obj8 === undefinedValue) {
                this.obj8 = inj._new(p.binding8, p.visibility8);
              }
              return this.obj8;
            }
            if (p.keyId9 === keyId && (p.visibility9 & visibility) > 0) {
              if (this.obj9 === undefinedValue) {
                this.obj9 = inj._new(p.binding9, p.visibility9);
              }
              return this.obj9;
            }
            return undefinedValue;
          },
          getObjAtIndex: function(index) {
            if (index == 0)
              return this.obj0;
            if (index == 1)
              return this.obj1;
            if (index == 2)
              return this.obj2;
            if (index == 3)
              return this.obj3;
            if (index == 4)
              return this.obj4;
            if (index == 5)
              return this.obj5;
            if (index == 6)
              return this.obj6;
            if (index == 7)
              return this.obj7;
            if (index == 8)
              return this.obj8;
            if (index == 9)
              return this.obj9;
            throw new OutOfBoundsError(index);
          },
          getMaxNumberOfObjects: function() {
            return _MAX_CONSTRUCTION_COUNTER;
          }
        }, {});
      }());
      $__export("InjectorInlineStrategy", InjectorInlineStrategy);
      InjectorDynamicStrategy = (function() {
        function InjectorDynamicStrategy(protoStrategy, injector) {
          this.protoStrategy = protoStrategy;
          this.injector = injector;
          this.objs = ListWrapper.createFixedSize(protoStrategy.bindings.length);
          ListWrapper.fill(this.objs, undefinedValue);
        }
        return ($traceurRuntime.createClass)(InjectorDynamicStrategy, {
          resetConstructionCounter: function() {
            this.injector._constructionCounter = 0;
          },
          instantiateBinding: function(binding, visibility) {
            return this.injector._new(binding, visibility);
          },
          attach: function(parent, isBoundary) {
            var inj = this.injector;
            inj._parent = parent;
            inj._isBoundary = isBoundary;
          },
          getObjByKeyId: function(keyId, visibility) {
            var p = this.protoStrategy;
            for (var i = 0; i < p.keyIds.length; i++) {
              if (p.keyIds[i] === keyId && (p.visibilities[i] & visibility) > 0) {
                if (this.objs[i] === undefinedValue) {
                  this.objs[i] = this.injector._new(p.bindings[i], p.visibilities[i]);
                }
                return this.objs[i];
              }
            }
            return undefinedValue;
          },
          getObjAtIndex: function(index) {
            if (index < 0 || index >= this.objs.length) {
              throw new OutOfBoundsError(index);
            }
            return this.objs[index];
          },
          getMaxNumberOfObjects: function() {
            return this.objs.length;
          }
        }, {});
      }());
      $__export("InjectorDynamicStrategy", InjectorDynamicStrategy);
      BindingWithVisibility = (function() {
        function BindingWithVisibility(binding, visibility) {
          this.binding = binding;
          this.visibility = visibility;
        }
        return ($traceurRuntime.createClass)(BindingWithVisibility, {getKeyId: function() {
            return this.binding.key.id;
          }}, {});
      }());
      $__export("BindingWithVisibility", BindingWithVisibility);
      Injector = (function() {
        function Injector(_proto) {
          var _parent = arguments[1] !== (void 0) ? arguments[1] : null;
          var _depProvider = arguments[2] !== (void 0) ? arguments[2] : null;
          var _debugContext = arguments[3] !== (void 0) ? arguments[3] : null;
          this._proto = _proto;
          this._parent = _parent;
          this._depProvider = _depProvider;
          this._debugContext = _debugContext;
          this._isBoundary = false;
          this._constructionCounter = 0;
          this._strategy = _proto._strategy.createInjectorStrategy(this);
        }
        return ($traceurRuntime.createClass)(Injector, {
          debugContext: function() {
            return this._debugContext();
          },
          get: function(token) {
            return this._getByKey(Key.get(token), DEFAULT_VISIBILITY, false, PUBLIC_AND_PRIVATE);
          },
          getOptional: function(token) {
            return this._getByKey(Key.get(token), DEFAULT_VISIBILITY, true, PUBLIC_AND_PRIVATE);
          },
          getAt: function(index) {
            return this._strategy.getObjAtIndex(index);
          },
          get parent() {
            return this._parent;
          },
          get internalStrategy() {
            return this._strategy;
          },
          resolveAndCreateChild: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var resovledBindings = Injector.resolve(bindings);
            return this.createChildFromResolved(resovledBindings, depProvider);
          },
          createChildFromResolved: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var bd = bindings.map((function(b) {
              return new BindingWithVisibility(b, PUBLIC);
            }));
            var proto = new ProtoInjector(bd);
            var inj = new Injector(proto, null, depProvider);
            inj._parent = this;
            return inj;
          },
          _new: function(binding, visibility) {
            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
              throw new CyclicDependencyError(this, binding.key);
            }
            var factory = binding.factory;
            var deps = binding.dependencies;
            var length = deps.length;
            var d0,
                d1,
                d2,
                d3,
                d4,
                d5,
                d6,
                d7,
                d8,
                d9,
                d10,
                d11,
                d12,
                d13,
                d14,
                d15,
                d16,
                d17,
                d18,
                d19;
            try {
              d0 = length > 0 ? this._getByDependency(binding, deps[0], visibility) : null;
              d1 = length > 1 ? this._getByDependency(binding, deps[1], visibility) : null;
              d2 = length > 2 ? this._getByDependency(binding, deps[2], visibility) : null;
              d3 = length > 3 ? this._getByDependency(binding, deps[3], visibility) : null;
              d4 = length > 4 ? this._getByDependency(binding, deps[4], visibility) : null;
              d5 = length > 5 ? this._getByDependency(binding, deps[5], visibility) : null;
              d6 = length > 6 ? this._getByDependency(binding, deps[6], visibility) : null;
              d7 = length > 7 ? this._getByDependency(binding, deps[7], visibility) : null;
              d8 = length > 8 ? this._getByDependency(binding, deps[8], visibility) : null;
              d9 = length > 9 ? this._getByDependency(binding, deps[9], visibility) : null;
              d10 = length > 10 ? this._getByDependency(binding, deps[10], visibility) : null;
              d11 = length > 11 ? this._getByDependency(binding, deps[11], visibility) : null;
              d12 = length > 12 ? this._getByDependency(binding, deps[12], visibility) : null;
              d13 = length > 13 ? this._getByDependency(binding, deps[13], visibility) : null;
              d14 = length > 14 ? this._getByDependency(binding, deps[14], visibility) : null;
              d15 = length > 15 ? this._getByDependency(binding, deps[15], visibility) : null;
              d16 = length > 16 ? this._getByDependency(binding, deps[16], visibility) : null;
              d17 = length > 17 ? this._getByDependency(binding, deps[17], visibility) : null;
              d18 = length > 18 ? this._getByDependency(binding, deps[18], visibility) : null;
              d19 = length > 19 ? this._getByDependency(binding, deps[19], visibility) : null;
            } catch (e) {
              if (e instanceof AbstractBindingError) {
                e.addKey(this, binding.key);
              }
              throw e;
            }
            var obj;
            try {
              switch (length) {
                case 0:
                  obj = factory();
                  break;
                case 1:
                  obj = factory(d0);
                  break;
                case 2:
                  obj = factory(d0, d1);
                  break;
                case 3:
                  obj = factory(d0, d1, d2);
                  break;
                case 4:
                  obj = factory(d0, d1, d2, d3);
                  break;
                case 5:
                  obj = factory(d0, d1, d2, d3, d4);
                  break;
                case 6:
                  obj = factory(d0, d1, d2, d3, d4, d5);
                  break;
                case 7:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6);
                  break;
                case 8:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                  break;
                case 9:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                  break;
                case 10:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                  break;
                case 11:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                  break;
                case 12:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                  break;
                case 13:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                  break;
                case 14:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                  break;
                case 15:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                  break;
                case 16:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                  break;
                case 17:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                  break;
                case 18:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                  break;
                case 19:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                  break;
                case 20:
                  obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                  break;
              }
            } catch (e) {
              throw new InstantiationError(this, e, e.stack, binding.key);
            }
            return obj;
          },
          _getByDependency: function(binding, dep, bindingVisibility) {
            var special = isPresent(this._depProvider) ? this._depProvider.getDependency(this, binding, dep) : undefinedValue;
            if (special !== undefinedValue) {
              return special;
            } else {
              return this._getByKey(dep.key, dep.visibility, dep.optional, bindingVisibility);
            }
          },
          _getByKey: function(key, depVisibility, optional, bindingVisibility) {
            if (key === INJECTOR_KEY) {
              return this;
            }
            if (depVisibility instanceof SelfMetadata) {
              return this._getByKeySelf(key, optional, bindingVisibility);
            } else if (depVisibility instanceof AncestorMetadata) {
              return this._getByKeyAncestor(key, optional, bindingVisibility, depVisibility.includeSelf);
            } else {
              return this._getByKeyUnbounded(key, optional, bindingVisibility, depVisibility.includeSelf);
            }
          },
          _throwOrNull: function(key, optional) {
            if (optional) {
              return null;
            } else {
              throw new NoBindingError(this, key);
            }
          },
          _getByKeySelf: function(key, optional, bindingVisibility) {
            var obj = this._strategy.getObjByKeyId(key.id, bindingVisibility);
            return (obj !== undefinedValue) ? obj : this._throwOrNull(key, optional);
          },
          _getByKeyAncestor: function(key, optional, bindingVisibility, includeSelf) {
            var inj = this;
            if (!includeSelf) {
              if (inj._isBoundary) {
                return this._getPrivateDependency(key, optional, inj);
              } else {
                inj = inj._parent;
              }
            }
            while (inj != null) {
              var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
              if (obj !== undefinedValue)
                return obj;
              if (isPresent(inj._parent) && inj._isBoundary) {
                return this._getPrivateDependency(key, optional, inj);
              } else {
                inj = inj._parent;
              }
            }
            return this._throwOrNull(key, optional);
          },
          _getPrivateDependency: function(key, optional, inj) {
            var obj = inj._parent._strategy.getObjByKeyId(key.id, PRIVATE);
            return (obj !== undefinedValue) ? obj : this._throwOrNull(key, optional);
          },
          _getByKeyUnbounded: function(key, optional, bindingVisibility, includeSelf) {
            var inj = this;
            if (!includeSelf) {
              bindingVisibility = inj._isBoundary ? PUBLIC_AND_PRIVATE : PUBLIC;
              inj = inj._parent;
            }
            while (inj != null) {
              var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
              if (obj !== undefinedValue)
                return obj;
              bindingVisibility = inj._isBoundary ? PUBLIC_AND_PRIVATE : PUBLIC;
              inj = inj._parent;
            }
            return this._throwOrNull(key, optional);
          },
          get displayName() {
            return ("Injector(bindings: [" + _mapBindings(this, (function(b) {
              return (" \"" + b.key.displayName + "\" ");
            })).join(", ") + "])");
          },
          toString: function() {
            return this.displayName;
          }
        }, {
          resolve: function(bindings) {
            var resolvedBindings = _resolveBindings(bindings);
            var flatten = _flattenBindings(resolvedBindings, new Map());
            return _createListOfBindings(flatten);
          },
          resolveAndCreate: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var resolvedBindings = Injector.resolve(bindings);
            return Injector.fromResolvedBindings(resolvedBindings, depProvider);
          },
          fromResolvedBindings: function(bindings) {
            var depProvider = arguments[1] !== (void 0) ? arguments[1] : null;
            var bd = bindings.map((function(b) {
              return new BindingWithVisibility(b, PUBLIC);
            }));
            var proto = new ProtoInjector(bd);
            var inj = new Injector(proto, null, depProvider);
            return inj;
          }
        });
      }());
      $__export("Injector", Injector);
      INJECTOR_KEY = Key.get(Injector);
    }
  };
});

System.register("angular2/src/change_detection/change_detection_jit_generator", ["angular2/src/facade/lang", "angular2/src/facade/collection", "angular2/src/change_detection/abstract_change_detector", "angular2/src/change_detection/change_detection_util", "angular2/src/change_detection/proto_record", "angular2/src/change_detection/codegen_name_util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection_jit_generator";
  var BaseException,
      ListWrapper,
      AbstractChangeDetector,
      ChangeDetectionUtil,
      RecordType,
      CodegenNameUtil,
      sanitizeName,
      ABSTRACT_CHANGE_DETECTOR,
      UTIL,
      DISPATCHER_ACCESSOR,
      PIPES_ACCESSOR,
      PROTOS_ACCESSOR,
      DIRECTIVES_ACCESSOR,
      IS_CHANGED_LOCAL,
      CHANGES_LOCAL,
      LOCALS_ACCESSOR,
      MODE_ACCESSOR,
      CURRENT_PROTO,
      ALREADY_CHECKED_ACCESSOR,
      ChangeDetectorJITGenerator;
  return {
    setters: [function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      AbstractChangeDetector = $__m.AbstractChangeDetector;
    }, function($__m) {
      ChangeDetectionUtil = $__m.ChangeDetectionUtil;
    }, function($__m) {
      RecordType = $__m.RecordType;
    }, function($__m) {
      CodegenNameUtil = $__m.CodegenNameUtil;
      sanitizeName = $__m.sanitizeName;
    }],
    execute: function() {
      ABSTRACT_CHANGE_DETECTOR = "AbstractChangeDetector";
      UTIL = "ChangeDetectionUtil";
      DISPATCHER_ACCESSOR = "this.dispatcher";
      PIPES_ACCESSOR = "this.pipes";
      PROTOS_ACCESSOR = "this.protos";
      DIRECTIVES_ACCESSOR = "this.directiveRecords";
      IS_CHANGED_LOCAL = "isChanged";
      CHANGES_LOCAL = "changes";
      LOCALS_ACCESSOR = "this.locals";
      MODE_ACCESSOR = "this.mode";
      CURRENT_PROTO = "this.currentProto";
      ALREADY_CHECKED_ACCESSOR = "this.alreadyChecked";
      ChangeDetectorJITGenerator = (function() {
        function ChangeDetectorJITGenerator(id, changeDetectionStrategy, records, directiveRecords, generateCheckNoChanges) {
          this.id = id;
          this.changeDetectionStrategy = changeDetectionStrategy;
          this.records = records;
          this.directiveRecords = directiveRecords;
          this.generateCheckNoChanges = generateCheckNoChanges;
          this._names = new CodegenNameUtil(this.records, this.directiveRecords, 'this._', UTIL);
          this._typeName = sanitizeName(("ChangeDetector_" + this.id));
        }
        return ($traceurRuntime.createClass)(ChangeDetectorJITGenerator, {
          generate: function() {
            var $__0 = this;
            var classDefinition = ("\n      var " + this._typeName + " = function " + this._typeName + "(dispatcher, protos, directiveRecords) {\n        " + ABSTRACT_CHANGE_DETECTOR + ".call(this, " + JSON.stringify(this.id) + ", dispatcher);\n        " + PROTOS_ACCESSOR + " = protos;\n        " + DIRECTIVES_ACCESSOR + " = directiveRecords;\n        " + LOCALS_ACCESSOR + " = null;\n        " + CURRENT_PROTO + " = null;\n        " + PIPES_ACCESSOR + " = null;\n        " + ALREADY_CHECKED_ACCESSOR + " = false;\n        this.dehydrateDirectives(false);\n      }\n\n      " + this._typeName + ".prototype = Object.create(" + ABSTRACT_CHANGE_DETECTOR + ".prototype);\n\n      " + this._typeName + ".prototype.detectChangesInRecords = function(throwOnChange) {\n        if (!this.hydrated()) {\n          " + UTIL + ".throwDehydrated();\n        }\n        try {\n          this.__detectChangesInRecords(throwOnChange);\n        } catch (e) {\n          this.throwError(" + CURRENT_PROTO + ", e, e.stack);\n        }\n      }\n\n      " + this._typeName + ".prototype.__detectChangesInRecords = function(throwOnChange) {\n        " + CURRENT_PROTO + " = null;\n\n        " + this._names.genInitLocals() + "\n        var " + IS_CHANGED_LOCAL + " = false;\n        var " + CHANGES_LOCAL + " = null;\n\n        context = " + this._names.getContextName() + ";\n\n        " + this.records.map((function(r) {
              return $__0._genRecord(r);
            })).join("\n") + "\n\n        " + ALREADY_CHECKED_ACCESSOR + " = true;\n      }\n\n      " + this._genCheckNoChanges() + "\n\n      " + this._typeName + ".prototype.callOnAllChangesDone = function() {\n        " + this._genCallOnAllChangesDoneBody() + "\n      }\n\n      " + this._typeName + ".prototype.hydrate = function(context, locals, directives, pipes) {\n        " + MODE_ACCESSOR + " = \"" + ChangeDetectionUtil.changeDetectionMode(this.changeDetectionStrategy) + "\";\n        " + this._names.getContextName() + " = context;\n        " + LOCALS_ACCESSOR + " = locals;\n        this.hydrateDirectives(directives);\n        " + PIPES_ACCESSOR + " = pipes;\n        " + ALREADY_CHECKED_ACCESSOR + " = false;\n      }\n\n      " + this._maybeGenHydrateDirectives() + "\n\n      " + this._typeName + ".prototype.dehydrate = function() {\n        this.dehydrateDirectives(true);\n        " + LOCALS_ACCESSOR + " = null;\n        " + PIPES_ACCESSOR + " = null;\n      }\n\n      " + this._maybeGenDehydrateDirectives() + "\n\n      " + this._typeName + ".prototype.hydrated = function() {\n        return " + this._names.getContextName() + " !== null;\n      }\n\n      return function(dispatcher) {\n        return new " + this._typeName + "(dispatcher, protos, directiveRecords);\n      }\n    ");
            return new Function('AbstractChangeDetector', 'ChangeDetectionUtil', 'protos', 'directiveRecords', classDefinition)(AbstractChangeDetector, ChangeDetectionUtil, this.records, this.directiveRecords);
          },
          _maybeGenDehydrateDirectives: function() {
            var destroyPipesCode = this._names.genPipeOnDestroy();
            if (destroyPipesCode) {
              destroyPipesCode = ("if (destroyPipes) { " + destroyPipesCode + " }");
            }
            var dehydrateFieldsCode = this._names.genDehydrateFields();
            if (!destroyPipesCode && !dehydrateFieldsCode)
              return '';
            return (this._typeName + ".prototype.dehydrateDirectives = function(destroyPipes) {\n        " + destroyPipesCode + "\n        " + dehydrateFieldsCode + "\n    }");
          },
          _maybeGenHydrateDirectives: function() {
            var hydrateDirectivesCode = this._genHydrateDirectives();
            var hydrateDetectorsCode = this._genHydrateDetectors();
            if (!hydrateDirectivesCode && !hydrateDetectorsCode)
              return '';
            return (this._typeName + ".prototype.hydrateDirectives = function(directives) {\n      " + hydrateDirectivesCode + "\n      " + hydrateDetectorsCode + "\n    }");
          },
          _genHydrateDirectives: function() {
            var directiveFieldNames = this._names.getAllDirectiveNames();
            var lines = ListWrapper.createFixedSize(directiveFieldNames.length);
            for (var i = 0,
                iLen = directiveFieldNames.length; i < iLen; ++i) {
              lines[i] = (directiveFieldNames[i] + " = directives.getDirectiveFor(" + DIRECTIVES_ACCESSOR + "[" + i + "].directiveIndex);");
            }
            return lines.join('\n');
          },
          _genHydrateDetectors: function() {
            var detectorFieldNames = this._names.getAllDetectorNames();
            var lines = ListWrapper.createFixedSize(detectorFieldNames.length);
            for (var i = 0,
                iLen = detectorFieldNames.length; i < iLen; ++i) {
              lines[i] = (detectorFieldNames[i] + " =\n          directives.getDetectorFor(" + DIRECTIVES_ACCESSOR + "[" + i + "].directiveIndex);");
            }
            return lines.join('\n');
          },
          _genCallOnAllChangesDoneBody: function() {
            var notifications = [];
            var dirs = this.directiveRecords;
            for (var i = dirs.length - 1; i >= 0; --i) {
              var dir = dirs[i];
              if (dir.callOnAllChangesDone) {
                notifications.push((this._names.getDirectiveName(dir.directiveIndex) + ".onAllChangesDone();"));
              }
            }
            var directiveNotifications = notifications.join("\n");
            return ("\n      this.dispatcher.notifyOnAllChangesDone();\n      " + directiveNotifications + "\n    ");
          },
          _genRecord: function(r) {
            var rec;
            if (r.isLifeCycleRecord()) {
              rec = this._genDirectiveLifecycle(r);
            } else if (r.isPipeRecord()) {
              rec = this._genPipeCheck(r);
            } else {
              rec = this._genReferenceCheck(r);
            }
            return ("" + rec + this._maybeGenLastInDirective(r));
          },
          _genDirectiveLifecycle: function(r) {
            if (r.name === "onCheck") {
              return this._genOnCheck(r);
            } else if (r.name === "onInit") {
              return this._genOnInit(r);
            } else if (r.name === "onChange") {
              return this._genOnChange(r);
            } else {
              throw new BaseException(("Unknown lifecycle event '" + r.name + "'"));
            }
          },
          _genPipeCheck: function(r) {
            var $__0 = this;
            var context = this._names.getLocalName(r.contextIndex);
            var argString = r.args.map((function(arg) {
              return $__0._names.getLocalName(arg);
            })).join(", ");
            var oldValue = this._names.getFieldName(r.selfIndex);
            var newValue = this._names.getLocalName(r.selfIndex);
            var change = this._names.getChangeName(r.selfIndex);
            var pipe = this._names.getPipeName(r.selfIndex);
            var cdRef = "this.ref";
            var protoIndex = r.selfIndex - 1;
            var pipeType = r.name;
            return ("\n      " + CURRENT_PROTO + " = " + PROTOS_ACCESSOR + "[" + protoIndex + "];\n      if (" + pipe + " === " + UTIL + ".uninitialized) {\n        " + pipe + " = " + PIPES_ACCESSOR + ".get('" + pipeType + "', " + context + ", " + cdRef + ");\n      } else if (!" + pipe + ".supports(" + context + ")) {\n        " + pipe + ".onDestroy();\n        " + pipe + " = " + PIPES_ACCESSOR + ".get('" + pipeType + "', " + context + ", " + cdRef + ");\n      }\n\n      " + newValue + " = " + pipe + ".transform(" + context + ", [" + argString + "]);\n      if (" + oldValue + " !== " + newValue + ") {\n        " + newValue + " = " + UTIL + ".unwrapValue(" + newValue + ");\n        " + change + " = true;\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ");
          },
          _genReferenceCheck: function(r) {
            var $__0 = this;
            var oldValue = this._names.getFieldName(r.selfIndex);
            var newValue = this._names.getLocalName(r.selfIndex);
            var protoIndex = r.selfIndex - 1;
            var check = ("\n      " + CURRENT_PROTO + " = " + PROTOS_ACCESSOR + "[" + protoIndex + "];\n      " + this._genUpdateCurrentValue(r) + "\n      if (" + newValue + " !== " + oldValue + ") {\n        " + this._names.getChangeName(r.selfIndex) + " = true;\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ");
            if (r.isPureFunction()) {
              var condition = r.args.map((function(a) {
                return $__0._names.getChangeName(a);
              })).join(" || ");
              return ("if (" + condition + ") { " + check + " } else { " + newValue + " = " + oldValue + "; }");
            } else {
              return check;
            }
          },
          _genUpdateCurrentValue: function(r) {
            var $__0 = this;
            var context = (r.contextIndex == -1) ? this._names.getDirectiveName(r.directiveIndex) : this._names.getLocalName(r.contextIndex);
            var newValue = this._names.getLocalName(r.selfIndex);
            var argString = r.args.map((function(arg) {
              return $__0._names.getLocalName(arg);
            })).join(", ");
            var rhs;
            switch (r.mode) {
              case RecordType.SELF:
                rhs = context;
                break;
              case RecordType.CONST:
                rhs = JSON.stringify(r.funcOrValue);
                break;
              case RecordType.PROPERTY:
                rhs = (context + "." + r.name);
                break;
              case RecordType.SAFE_PROPERTY:
                rhs = (UTIL + ".isValueBlank(" + context + ") ? null : " + context + "." + r.name);
                break;
              case RecordType.LOCAL:
                rhs = (LOCALS_ACCESSOR + ".get('" + r.name + "')");
                break;
              case RecordType.INVOKE_METHOD:
                rhs = (context + "." + r.name + "(" + argString + ")");
                break;
              case RecordType.SAFE_INVOKE_METHOD:
                rhs = (UTIL + ".isValueBlank(" + context + ") ? null : " + context + "." + r.name + "(" + argString + ")");
                break;
              case RecordType.INVOKE_CLOSURE:
                rhs = (context + "(" + argString + ")");
                break;
              case RecordType.PRIMITIVE_OP:
                rhs = (UTIL + "." + r.name + "(" + argString + ")");
                break;
              case RecordType.INTERPOLATE:
                rhs = this._genInterpolation(r);
                break;
              case RecordType.KEYED_ACCESS:
                rhs = (context + "[" + this._names.getLocalName(r.args[0]) + "]");
                break;
              default:
                throw new BaseException(("Unknown operation " + r.mode));
            }
            return (newValue + " = " + rhs);
          },
          _genInterpolation: function(r) {
            var res = "";
            for (var i = 0; i < r.args.length; ++i) {
              res += JSON.stringify(r.fixedArgs[i]);
              res += " + ";
              res += (UTIL + ".s(" + this._names.getLocalName(r.args[i]) + ")");
              res += " + ";
            }
            res += JSON.stringify(r.fixedArgs[r.args.length]);
            return res;
          },
          _genUpdateDirectiveOrElement: function(r) {
            if (!r.lastInBinding)
              return "";
            var newValue = this._names.getLocalName(r.selfIndex);
            var oldValue = this._names.getFieldName(r.selfIndex);
            var br = r.bindingRecord;
            if (br.isDirective()) {
              var directiveProperty = (this._names.getDirectiveName(br.directiveRecord.directiveIndex) + "." + br.propertyName);
              return ("\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + directiveProperty + " = " + newValue + ";\n        " + IS_CHANGED_LOCAL + " = true;\n      ");
            } else {
              return ("\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + DISPATCHER_ACCESSOR + ".notifyOnBinding(" + CURRENT_PROTO + ".bindingRecord, " + newValue + ");\n      ");
            }
          },
          _genThrowOnChangeCheck: function(oldValue, newValue) {
            if (this.generateCheckNoChanges) {
              return ("\n        if(throwOnChange) {\n          " + UTIL + ".throwOnChange(" + CURRENT_PROTO + ", " + UTIL + ".simpleChange(" + oldValue + ", " + newValue + "));\n        }\n        ");
            } else {
              return '';
            }
          },
          _genCheckNoChanges: function() {
            if (this.generateCheckNoChanges) {
              return (this._typeName + ".prototype.checkNoChanges = function() { this.runDetectChanges(true); }");
            } else {
              return '';
            }
          },
          _genAddToChanges: function(r) {
            var newValue = this._names.getLocalName(r.selfIndex);
            var oldValue = this._names.getFieldName(r.selfIndex);
            if (!r.bindingRecord.callOnChange())
              return "";
            return ("\n      " + CHANGES_LOCAL + " = " + UTIL + ".addChange(\n          " + CHANGES_LOCAL + ", " + CURRENT_PROTO + ".bindingRecord.propertyName,\n          " + UTIL + ".simpleChange(" + oldValue + ", " + newValue + "));\n    ");
          },
          _maybeGenLastInDirective: function(r) {
            if (!r.lastInDirective)
              return "";
            return ("\n      " + CHANGES_LOCAL + " = null;\n      " + this._genNotifyOnPushDetectors(r) + "\n      " + IS_CHANGED_LOCAL + " = false;\n    ");
          },
          _genOnCheck: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange) " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onCheck();");
          },
          _genOnInit: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange && !" + ALREADY_CHECKED_ACCESSOR + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onInit();");
          },
          _genOnChange: function(r) {
            var br = r.bindingRecord;
            return ("if (!throwOnChange && " + CHANGES_LOCAL + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onChange(" + CHANGES_LOCAL + ");");
          },
          _genNotifyOnPushDetectors: function(r) {
            var br = r.bindingRecord;
            if (!r.lastInDirective || !br.isOnPushChangeDetection())
              return "";
            var retVal = ("\n      if(" + IS_CHANGED_LOCAL + ") {\n        " + this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markAsCheckOnce();\n      }\n    ");
            return retVal;
          }
        }, {});
      }());
      $__export("ChangeDetectorJITGenerator", ChangeDetectorJITGenerator);
    }
  };
});

System.register("angular2/src/core/compiler/element_injector", ["angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/di", "angular2/src/di/injector", "angular2/src/core/annotations_impl/di", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_container_ref", "angular2/src/core/compiler/element_ref", "angular2/src/core/compiler/template_ref", "angular2/src/core/annotations_impl/annotations", "angular2/src/core/compiler/directive_lifecycle_reflector", "angular2/src/change_detection/change_detection", "angular2/src/core/compiler/query_list", "angular2/src/reflection/reflection", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/element_injector";
  var isPresent,
      isBlank,
      BaseException,
      stringify,
      StringWrapper,
      ObservableWrapper,
      ListWrapper,
      MapWrapper,
      Injector,
      ProtoInjector,
      PUBLIC_AND_PRIVATE,
      PUBLIC,
      PRIVATE,
      undefinedValue,
      Key,
      Dependency,
      Binding,
      ResolvedBinding,
      NoBindingError,
      InjectorInlineStrategy,
      BindingWithVisibility,
      Attribute,
      Query,
      avmModule,
      ViewContainerRef,
      ElementRef,
      TemplateRef,
      Directive,
      Component,
      LifecycleEvent,
      hasLifecycleHook,
      ChangeDetectorRef,
      Pipes,
      QueryList,
      reflector,
      DirectiveMetadata,
      _staticKeys,
      StaticKeys,
      TreeNode,
      DirectiveDependency,
      DirectiveBinding,
      PreBuiltObjects,
      EventEmitterAccessor,
      HostActionAccessor,
      ProtoElementInjector,
      _Context,
      ElementInjector,
      ElementInjectorInlineStrategy,
      ElementInjectorDynamicStrategy,
      QueryError,
      QueryRef;
  function _createEventEmitterAccessors(bwv) {
    var binding = bwv.binding;
    if (!(binding instanceof DirectiveBinding))
      return [];
    var db = binding;
    return ListWrapper.map(db.eventEmitters, (function(eventConfig) {
      var fieldName;
      var eventName;
      var colonIdx = eventConfig.indexOf(':');
      if (colonIdx > -1) {
        fieldName = StringWrapper.substring(eventConfig, 0, colonIdx).trim();
        eventName = StringWrapper.substring(eventConfig, colonIdx + 1).trim();
      } else {
        fieldName = eventName = eventConfig;
      }
      return new EventEmitterAccessor(eventName, reflector.getter(fieldName));
    }));
  }
  function _createHostActionAccessors(bwv) {
    var binding = bwv.binding;
    if (!(binding instanceof DirectiveBinding))
      return [];
    var res = [];
    var db = binding;
    MapWrapper.forEach(db.hostActions, (function(actionExpression, actionName) {
      res.push(new HostActionAccessor(actionExpression, reflector.getter(actionName)));
    }));
    return res;
  }
  return {
    setters: [function($__m) {
      isPresent = $__m.isPresent;
      isBlank = $__m.isBlank;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
      StringWrapper = $__m.StringWrapper;
    }, function($__m) {
      ObservableWrapper = $__m.ObservableWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      Injector = $__m.Injector;
      ProtoInjector = $__m.ProtoInjector;
      PUBLIC_AND_PRIVATE = $__m.PUBLIC_AND_PRIVATE;
      PUBLIC = $__m.PUBLIC;
      PRIVATE = $__m.PRIVATE;
      undefinedValue = $__m.undefinedValue;
      Key = $__m.Key;
      Dependency = $__m.Dependency;
      Binding = $__m.Binding;
      ResolvedBinding = $__m.ResolvedBinding;
      NoBindingError = $__m.NoBindingError;
    }, function($__m) {
      InjectorInlineStrategy = $__m.InjectorInlineStrategy;
      BindingWithVisibility = $__m.BindingWithVisibility;
    }, function($__m) {
      Attribute = $__m.Attribute;
      Query = $__m.Query;
    }, function($__m) {
      avmModule = $__m;
    }, function($__m) {
      ViewContainerRef = $__m.ViewContainerRef;
    }, function($__m) {
      ElementRef = $__m.ElementRef;
    }, function($__m) {
      TemplateRef = $__m.TemplateRef;
    }, function($__m) {
      Directive = $__m.Directive;
      Component = $__m.Component;
      LifecycleEvent = $__m.LifecycleEvent;
    }, function($__m) {
      hasLifecycleHook = $__m.hasLifecycleHook;
    }, function($__m) {
      ChangeDetectorRef = $__m.ChangeDetectorRef;
      Pipes = $__m.Pipes;
    }, function($__m) {
      QueryList = $__m.QueryList;
    }, function($__m) {
      reflector = $__m.reflector;
    }, function($__m) {
      DirectiveMetadata = $__m.DirectiveMetadata;
    }],
    execute: function() {
      StaticKeys = (function() {
        function StaticKeys() {
          this.viewManagerId = Key.get(avmModule.AppViewManager).id;
          this.templateRefId = Key.get(TemplateRef).id;
          this.viewContainerId = Key.get(ViewContainerRef).id;
          this.changeDetectorRefId = Key.get(ChangeDetectorRef).id;
          this.elementRefId = Key.get(ElementRef).id;
          this.pipesKey = Key.get(Pipes);
        }
        return ($traceurRuntime.createClass)(StaticKeys, {}, {instance: function() {
            if (isBlank(_staticKeys))
              _staticKeys = new StaticKeys();
            return _staticKeys;
          }});
      }());
      $__export("StaticKeys", StaticKeys);
      TreeNode = (function() {
        function TreeNode(parent) {
          this._head = null;
          this._tail = null;
          this._next = null;
          if (isPresent(parent))
            parent.addChild(this);
        }
        return ($traceurRuntime.createClass)(TreeNode, {
          addChild: function(child) {
            if (isPresent(this._tail)) {
              this._tail._next = child;
              this._tail = child;
            } else {
              this._tail = this._head = child;
            }
            child._next = null;
            child._parent = this;
          },
          addChildAfter: function(child, prevSibling) {
            if (isBlank(prevSibling)) {
              var prevHead = this._head;
              this._head = child;
              child._next = prevHead;
              if (isBlank(this._tail))
                this._tail = child;
            } else if (isBlank(prevSibling._next)) {
              this.addChild(child);
              return ;
            } else {
              child._next = prevSibling._next;
              prevSibling._next = child;
            }
            child._parent = this;
          },
          remove: function() {
            if (isBlank(this.parent))
              return ;
            var nextSibling = this._next;
            var prevSibling = this._findPrev();
            if (isBlank(prevSibling)) {
              this.parent._head = this._next;
            } else {
              prevSibling._next = this._next;
            }
            if (isBlank(nextSibling)) {
              this._parent._tail = prevSibling;
            }
            this._parent = null;
            this._next = null;
          },
          _findPrev: function() {
            var node = this.parent._head;
            if (node == this)
              return null;
            while (node._next !== this)
              node = node._next;
            return node;
          },
          get parent() {
            return this._parent;
          },
          get children() {
            var res = [];
            var child = this._head;
            while (child != null) {
              res.push(child);
              child = child._next;
            }
            return res;
          }
        }, {});
      }());
      $__export("TreeNode", TreeNode);
      DirectiveDependency = (function($__super) {
        function DirectiveDependency(key, optional, visibility, properties, attributeName, queryDecorator) {
          $traceurRuntime.superConstructor(DirectiveDependency).call(this, key, optional, visibility, properties);
          this.attributeName = attributeName;
          this.queryDecorator = queryDecorator;
          this._verify();
        }
        return ($traceurRuntime.createClass)(DirectiveDependency, {_verify: function() {
            var count = 0;
            if (isPresent(this.queryDecorator))
              count++;
            if (isPresent(this.attributeName))
              count++;
            if (count > 1)
              throw new BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
          }}, {
          createFrom: function(d) {
            return new DirectiveDependency(d.key, d.optional, d.visibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
          },
          _attributeName: function(properties) {
            var p = ListWrapper.find(properties, (function(p) {
              return p instanceof Attribute;
            }));
            return isPresent(p) ? p.attributeName : null;
          },
          _query: function(properties) {
            return ListWrapper.find(properties, (function(p) {
              return p instanceof Query;
            }));
          }
        }, $__super);
      }(Dependency));
      $__export("DirectiveDependency", DirectiveDependency);
      DirectiveBinding = (function($__super) {
        function DirectiveBinding(key, factory, dependencies, resolvedHostInjectables, resolvedViewInjectables, metadata) {
          $traceurRuntime.superConstructor(DirectiveBinding).call(this, key, factory, dependencies);
          this.resolvedHostInjectables = resolvedHostInjectables;
          this.resolvedViewInjectables = resolvedViewInjectables;
          this.metadata = metadata;
        }
        return ($traceurRuntime.createClass)(DirectiveBinding, {
          get callOnDestroy() {
            return this.metadata.callOnDestroy;
          },
          get callOnChange() {
            return this.metadata.callOnChange;
          },
          get callOnAllChangesDone() {
            return this.metadata.callOnAllChangesDone;
          },
          get displayName() {
            return this.key.displayName;
          },
          get eventEmitters() {
            return isPresent(this.metadata) && isPresent(this.metadata.events) ? this.metadata.events : [];
          },
          get hostActions() {
            return isPresent(this.metadata) && isPresent(this.metadata.hostActions) ? this.metadata.hostActions : new Map();
          },
          get changeDetection() {
            return this.metadata.changeDetection;
          }
        }, {
          createFromBinding: function(binding, ann) {
            if (isBlank(ann)) {
              ann = new Directive();
            }
            var rb = binding.resolve();
            var deps = ListWrapper.map(rb.dependencies, DirectiveDependency.createFrom);
            var resolvedHostInjectables = isPresent(ann.hostInjector) ? Injector.resolve(ann.hostInjector) : [];
            var resolvedViewInjectables = ann instanceof Component && isPresent(ann.viewInjector) ? Injector.resolve(ann.viewInjector) : [];
            var metadata = DirectiveMetadata.create({
              id: stringify(rb.key.token),
              type: ann instanceof Component ? DirectiveMetadata.COMPONENT_TYPE : DirectiveMetadata.DIRECTIVE_TYPE,
              selector: ann.selector,
              compileChildren: ann.compileChildren,
              events: ann.events,
              host: isPresent(ann.host) ? MapWrapper.createFromStringMap(ann.host) : null,
              properties: ann.properties,
              readAttributes: DirectiveBinding._readAttributes(deps),
              callOnDestroy: hasLifecycleHook(LifecycleEvent.onDestroy, rb.key.token, ann),
              callOnChange: hasLifecycleHook(LifecycleEvent.onChange, rb.key.token, ann),
              callOnCheck: hasLifecycleHook(LifecycleEvent.onCheck, rb.key.token, ann),
              callOnInit: hasLifecycleHook(LifecycleEvent.onInit, rb.key.token, ann),
              callOnAllChangesDone: hasLifecycleHook(LifecycleEvent.onAllChangesDone, rb.key.token, ann),
              changeDetection: ann instanceof Component ? ann.changeDetection : null,
              exportAs: ann.exportAs
            });
            return new DirectiveBinding(rb.key, rb.factory, deps, resolvedHostInjectables, resolvedViewInjectables, metadata);
          },
          _readAttributes: function(deps) {
            var readAttributes = [];
            ListWrapper.forEach(deps, (function(dep) {
              if (isPresent(dep.attributeName)) {
                readAttributes.push(dep.attributeName);
              }
            }));
            return readAttributes;
          },
          createFromType: function(type, annotation) {
            var binding = new Binding(type, {toClass: type});
            return DirectiveBinding.createFromBinding(binding, annotation);
          }
        }, $__super);
      }(ResolvedBinding));
      $__export("DirectiveBinding", DirectiveBinding);
      PreBuiltObjects = (function() {
        function PreBuiltObjects(viewManager, view, elementRef, templateRef) {
          this.viewManager = viewManager;
          this.view = view;
          this.elementRef = elementRef;
          this.templateRef = templateRef;
        }
        return ($traceurRuntime.createClass)(PreBuiltObjects, {}, {});
      }());
      $__export("PreBuiltObjects", PreBuiltObjects);
      EventEmitterAccessor = (function() {
        function EventEmitterAccessor(eventName, getter) {
          this.eventName = eventName;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(EventEmitterAccessor, {subscribe: function(view, boundElementIndex, directive) {
            var $__0 = this;
            var eventEmitter = this.getter(directive);
            return ObservableWrapper.subscribe(eventEmitter, (function(eventObj) {
              return view.triggerEventHandlers($__0.eventName, eventObj, boundElementIndex);
            }));
          }}, {});
      }());
      $__export("EventEmitterAccessor", EventEmitterAccessor);
      HostActionAccessor = (function() {
        function HostActionAccessor(methodName, getter) {
          this.methodName = methodName;
          this.getter = getter;
        }
        return ($traceurRuntime.createClass)(HostActionAccessor, {subscribe: function(view, boundElementIndex, directive) {
            var $__0 = this;
            var eventEmitter = this.getter(directive);
            return ObservableWrapper.subscribe(eventEmitter, (function(actionArgs) {
              return view.invokeElementMethod(boundElementIndex, $__0.methodName, actionArgs);
            }));
          }}, {});
      }());
      $__export("HostActionAccessor", HostActionAccessor);
      ProtoElementInjector = (function() {
        function ProtoElementInjector(parent, index, bwv, distanceToParent, _firstBindingIsComponent, directiveVariableBindings) {
          this.parent = parent;
          this.index = index;
          this.distanceToParent = distanceToParent;
          this._firstBindingIsComponent = _firstBindingIsComponent;
          this.directiveVariableBindings = directiveVariableBindings;
          var length = bwv.length;
          this.protoInjector = new ProtoInjector(bwv);
          this.eventEmitterAccessors = ListWrapper.createFixedSize(length);
          this.hostActionAccessors = ListWrapper.createFixedSize(length);
          for (var i = 0; i < length; ++i) {
            this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
            this.hostActionAccessors[i] = _createHostActionAccessors(bwv[i]);
          }
        }
        return ($traceurRuntime.createClass)(ProtoElementInjector, {
          instantiate: function(parent) {
            return new ElementInjector(this, parent);
          },
          directParent: function() {
            return this.distanceToParent < 2 ? this.parent : null;
          },
          get hasBindings() {
            return this.eventEmitterAccessors.length > 0;
          },
          getBindingAtIndex: function(index) {
            return this.protoInjector.getBindingAtIndex(index);
          }
        }, {
          create: function(parent, index, bindings, firstBindingIsComponent, distanceToParent, directiveVariableBindings) {
            var bd = [];
            ProtoElementInjector._createDirectiveBindingWithVisibility(bindings, bd, firstBindingIsComponent);
            if (firstBindingIsComponent) {
              ProtoElementInjector._createViewInjectorBindingWithVisibility(bindings, bd);
            }
            ProtoElementInjector._createHostInjectorBindingWithVisibility(bindings, bd, firstBindingIsComponent);
            return new ProtoElementInjector(parent, index, bd, distanceToParent, firstBindingIsComponent, directiveVariableBindings);
          },
          _createDirectiveBindingWithVisibility: function(dirBindings, bd, firstBindingIsComponent) {
            ListWrapper.forEach(dirBindings, (function(dirBinding) {
              bd.push(ProtoElementInjector._createBindingWithVisibility(firstBindingIsComponent, dirBinding, dirBindings, dirBinding));
            }));
          },
          _createHostInjectorBindingWithVisibility: function(dirBindings, bd, firstBindingIsComponent) {
            ListWrapper.forEach(dirBindings, (function(dirBinding) {
              ListWrapper.forEach(dirBinding.resolvedHostInjectables, (function(b) {
                bd.push(ProtoElementInjector._createBindingWithVisibility(firstBindingIsComponent, dirBinding, dirBindings, b));
              }));
            }));
          },
          _createBindingWithVisibility: function(firstBindingIsComponent, dirBinding, dirBindings, binding) {
            var isComponent = firstBindingIsComponent && dirBindings[0] === dirBinding;
            return new BindingWithVisibility(binding, isComponent ? PUBLIC_AND_PRIVATE : PUBLIC);
          },
          _createViewInjectorBindingWithVisibility: function(bindings, bd) {
            var db = bindings[0];
            ListWrapper.forEach(db.resolvedViewInjectables, (function(b) {
              return bd.push(new BindingWithVisibility(b, PRIVATE));
            }));
          }
        });
      }());
      $__export("ProtoElementInjector", ProtoElementInjector);
      _Context = (function() {
        function _Context(element, componentElement, injector) {
          this.element = element;
          this.componentElement = componentElement;
          this.injector = injector;
        }
        return ($traceurRuntime.createClass)(_Context, {}, {});
      }());
      ElementInjector = (function($__super) {
        function ElementInjector(_proto, parent) {
          var $__0;
          $traceurRuntime.superConstructor(ElementInjector).call(this, parent);
          this._proto = _proto;
          this._preBuiltObjects = null;
          this._injector = new Injector(this._proto.protoInjector, null, this, ($__0 = this, function() {
            return $__0._debugContext();
          }));
          var injectorStrategy = this._injector.internalStrategy;
          this._strategy = injectorStrategy instanceof InjectorInlineStrategy ? new ElementInjectorInlineStrategy(injectorStrategy, this) : new ElementInjectorDynamicStrategy(injectorStrategy, this);
          this.hydrated = false;
          this._buildQueries();
          this._addParentQueries();
        }
        return ($traceurRuntime.createClass)(ElementInjector, {
          dehydrate: function() {
            this.hydrated = false;
            this._host = null;
            this._preBuiltObjects = null;
            this._strategy.callOnDestroy();
            this._strategy.dehydrate();
          },
          onAllChangesDone: function() {
            if (isPresent(this._query0) && this._query0.originator === this) {
              this._query0.list.fireCallbacks();
            }
            if (isPresent(this._query1) && this._query1.originator === this) {
              this._query1.list.fireCallbacks();
            }
            if (isPresent(this._query2) && this._query2.originator === this) {
              this._query2.list.fireCallbacks();
            }
          },
          hydrate: function(imperativelyCreatedInjector, host, preBuiltObjects) {
            this._host = host;
            this._preBuiltObjects = preBuiltObjects;
            this._reattachInjectors(imperativelyCreatedInjector);
            this._strategy.hydrate();
            if (isPresent(host)) {
              this._addViewQueries(host);
            }
            this._addDirectivesToQueries();
            this._addVarBindingsToQueries();
            this.hydrated = true;
          },
          _debugContext: function() {
            var p = this._preBuiltObjects;
            var index = p.elementRef.boundElementIndex - p.view.elementOffset;
            var c = this._preBuiltObjects.view.getDebugContext(index, null);
            return isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
          },
          _reattachInjectors: function(imperativelyCreatedInjector) {
            if (isPresent(this._parent)) {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
              } else {
                this._reattachInjector(this._injector, this._parent._injector, false);
              }
            } else if (isPresent(this._host)) {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
                this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
              } else {
                this._reattachInjector(this._injector, this._host._injector, true);
              }
            } else {
              if (isPresent(imperativelyCreatedInjector)) {
                this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
              }
            }
          },
          _reattachInjector: function(injector, parentInjector, isBoundary) {
            injector.internalStrategy.attach(parentInjector, isBoundary);
          },
          getPipes: function() {
            var pipesKey = StaticKeys.instance().pipesKey;
            return this._injector.getOptional(pipesKey);
          },
          hasVariableBinding: function(name) {
            var vb = this._proto.directiveVariableBindings;
            return isPresent(vb) && vb.has(name);
          },
          getVariableBinding: function(name) {
            var index = this._proto.directiveVariableBindings.get(name);
            return isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();
          },
          get: function(token) {
            return this._injector.get(token);
          },
          hasDirective: function(type) {
            return isPresent(this._injector.getOptional(type));
          },
          getEventEmitterAccessors: function() {
            return this._proto.eventEmitterAccessors;
          },
          getHostActionAccessors: function() {
            return this._proto.hostActionAccessors;
          },
          getDirectiveVariableBindings: function() {
            return this._proto.directiveVariableBindings;
          },
          getComponent: function() {
            return this._strategy.getComponent();
          },
          getInjector: function() {
            return this._injector;
          },
          getElementRef: function() {
            return this._preBuiltObjects.elementRef;
          },
          getViewContainerRef: function() {
            return new ViewContainerRef(this._preBuiltObjects.viewManager, this.getElementRef());
          },
          directParent: function() {
            return this._proto.distanceToParent < 2 ? this.parent : null;
          },
          isComponentKey: function(key) {
            return this._strategy.isComponentKey(key);
          },
          getDependency: function(injector, binding, dep) {
            var key = dep.key;
            if (!(dep instanceof DirectiveDependency))
              return undefinedValue;
            if (!(binding instanceof DirectiveBinding))
              return undefinedValue;
            var dirDep = dep;
            var dirBin = binding;
            var staticKeys = StaticKeys.instance();
            if (key.id === staticKeys.viewManagerId)
              return this._preBuiltObjects.viewManager;
            if (isPresent(dirDep.attributeName))
              return this._buildAttribute(dirDep);
            if (isPresent(dirDep.queryDecorator))
              return this._findQuery(dirDep.queryDecorator).list;
            if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
              if (dirBin.metadata.type === DirectiveMetadata.COMPONENT_TYPE) {
                var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
                return componentView.changeDetector.ref;
              } else {
                return this._preBuiltObjects.view.changeDetector.ref;
              }
            }
            if (dirDep.key.id === StaticKeys.instance().elementRefId) {
              return this.getElementRef();
            }
            if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
              return this.getViewContainerRef();
            }
            if (dirDep.key.id === StaticKeys.instance().templateRefId) {
              if (isBlank(this._preBuiltObjects.templateRef)) {
                if (dirDep.optional) {
                  return null;
                }
                throw new NoBindingError(null, dirDep.key);
              }
              return this._preBuiltObjects.templateRef;
            }
            return undefinedValue;
          },
          _buildAttribute: function(dep) {
            var attributes = this._proto.attributes;
            if (isPresent(attributes) && attributes.has(dep.attributeName)) {
              return attributes.get(dep.attributeName);
            } else {
              return null;
            }
          },
          _buildQueriesForDeps: function(deps) {
            for (var i = 0; i < deps.length; i++) {
              var dep = deps[i];
              if (isPresent(dep.queryDecorator)) {
                this._createQueryRef(dep.queryDecorator);
              }
            }
          },
          _addViewQueries: function(host) {
            if (isPresent(host._query0) && host._query0.originator == host && host._query0.query.isViewQuery)
              this._addViewQuery(host._query0);
            if (isPresent(host._query1) && host._query1.originator == host && host._query1.query.isViewQuery)
              this._addViewQuery(host._query1);
            if (isPresent(host._query2) && host._query2.originator == host && host._query2.query.isViewQuery)
              this._addViewQuery(host._query2);
          },
          _addViewQuery: function(queryRef) {
            if (!queryRef.query.descendants && isPresent(this.parent))
              return ;
            this._assignQueryRef(queryRef);
          },
          _addVarBindingsToQueries: function() {
            this._addVarBindingsToQuery(this._query0);
            this._addVarBindingsToQuery(this._query1);
            this._addVarBindingsToQuery(this._query2);
          },
          _addDirectivesToQueries: function() {
            this._addDirectivesToQuery(this._query0);
            this._addDirectivesToQuery(this._query1);
            this._addDirectivesToQuery(this._query2);
          },
          _addVarBindingsToQuery: function(queryRef) {
            if (isBlank(queryRef) || !queryRef.query.isVarBindingQuery)
              return ;
            var vb = queryRef.query.varBindings;
            for (var i = 0; i < vb.length; ++i) {
              if (this.hasVariableBinding(vb[i])) {
                queryRef.list.add(this.getVariableBinding(vb[i]));
              }
            }
          },
          _addDirectivesToQuery: function(queryRef) {
            if (isBlank(queryRef) || queryRef.query.isVarBindingQuery)
              return ;
            var matched = [];
            this.addDirectivesMatchingQuery(queryRef.query, matched);
            matched.forEach((function(s) {
              return queryRef.list.add(s);
            }));
          },
          _createQueryRef: function(query) {
            var queryList = new QueryList();
            if (isBlank(this._query0)) {
              this._query0 = new QueryRef(query, queryList, this);
            } else if (isBlank(this._query1)) {
              this._query1 = new QueryRef(query, queryList, this);
            } else if (isBlank(this._query2)) {
              this._query2 = new QueryRef(query, queryList, this);
            } else {
              throw new QueryError();
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            this._strategy.addDirectivesMatchingQuery(query, list);
          },
          _buildQueries: function() {
            if (isPresent(this._proto)) {
              this._strategy.buildQueries();
            }
          },
          _findQuery: function(query) {
            if (isPresent(this._query0) && this._query0.query === query) {
              return this._query0;
            }
            if (isPresent(this._query1) && this._query1.query === query) {
              return this._query1;
            }
            if (isPresent(this._query2) && this._query2.query === query) {
              return this._query2;
            }
            throw new BaseException(("Cannot find query for directive " + query + "."));
          },
          _hasQuery: function(query) {
            return this._query0 == query || this._query1 == query || this._query2 == query;
          },
          link: function(parent) {
            parent.addChild(this);
            this._addParentQueries();
          },
          linkAfter: function(parent, prevSibling) {
            parent.addChildAfter(this, prevSibling);
            this._addParentQueries();
          },
          _addParentQueries: function() {
            if (isBlank(this.parent))
              return ;
            if (isPresent(this.parent._query0) && !this.parent._query0.query.isViewQuery) {
              this._addQueryToTree(this.parent._query0);
              if (this.hydrated)
                this.parent._query0.update();
            }
            if (isPresent(this.parent._query1) && !this.parent._query1.query.isViewQuery) {
              this._addQueryToTree(this.parent._query1);
              if (this.hydrated)
                this.parent._query1.update();
            }
            if (isPresent(this.parent._query2) && !this.parent._query2.query.isViewQuery) {
              this._addQueryToTree(this.parent._query2);
              if (this.hydrated)
                this.parent._query2.update();
            }
          },
          unlink: function() {
            var queriesToUpdate = [];
            if (isPresent(this.parent._query0)) {
              this._pruneQueryFromTree(this.parent._query0);
              queriesToUpdate.push(this.parent._query0);
            }
            if (isPresent(this.parent._query1)) {
              this._pruneQueryFromTree(this.parent._query1);
              queriesToUpdate.push(this.parent._query1);
            }
            if (isPresent(this.parent._query2)) {
              this._pruneQueryFromTree(this.parent._query2);
              queriesToUpdate.push(this.parent._query2);
            }
            this.remove();
            ListWrapper.forEach(queriesToUpdate, (function(q) {
              return q.update();
            }));
          },
          _pruneQueryFromTree: function(query) {
            this._removeQueryRef(query);
            var child = this._head;
            while (isPresent(child)) {
              child._pruneQueryFromTree(query);
              child = child._next;
            }
          },
          _addQueryToTree: function(queryRef) {
            if (queryRef.query.descendants == false) {
              if (this == queryRef.originator) {
                this._addQueryToTreeSelfAndRecurse(queryRef);
              } else if (this.parent == queryRef.originator) {
                this._assignQueryRef(queryRef);
              }
            } else {
              this._addQueryToTreeSelfAndRecurse(queryRef);
            }
          },
          _addQueryToTreeSelfAndRecurse: function(queryRef) {
            this._assignQueryRef(queryRef);
            var child = this._head;
            while (isPresent(child)) {
              child._addQueryToTree(queryRef);
              child = child._next;
            }
          },
          _assignQueryRef: function(query) {
            if (isBlank(this._query0)) {
              this._query0 = query;
              return ;
            } else if (isBlank(this._query1)) {
              this._query1 = query;
              return ;
            } else if (isBlank(this._query2)) {
              this._query2 = query;
              return ;
            }
            throw new QueryError();
          },
          _removeQueryRef: function(query) {
            if (this._query0 == query)
              this._query0 = null;
            if (this._query1 == query)
              this._query1 = null;
            if (this._query2 == query)
              this._query2 = null;
          },
          getDirectiveAtIndex: function(index) {
            return this._injector.getAt(index);
          },
          hasInstances: function() {
            return this._proto.hasBindings && this.hydrated;
          },
          getHost: function() {
            return this._host;
          },
          getBoundElementIndex: function() {
            return this._proto.index;
          }
        }, {}, $__super);
      }(TreeNode));
      $__export("ElementInjector", ElementInjector);
      ElementInjectorInlineStrategy = (function() {
        function ElementInjectorInlineStrategy(injectorStrategy, _ei) {
          this.injectorStrategy = injectorStrategy;
          this._ei = _ei;
        }
        return ($traceurRuntime.createClass)(ElementInjectorInlineStrategy, {
          hydrate: function() {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            i.resetConstructionCounter();
            if (p.binding0 instanceof DirectiveBinding && isPresent(p.keyId0) && i.obj0 === undefinedValue)
              i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
            if (p.binding1 instanceof DirectiveBinding && isPresent(p.keyId1) && i.obj1 === undefinedValue)
              i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
            if (p.binding2 instanceof DirectiveBinding && isPresent(p.keyId2) && i.obj2 === undefinedValue)
              i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
            if (p.binding3 instanceof DirectiveBinding && isPresent(p.keyId3) && i.obj3 === undefinedValue)
              i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
            if (p.binding4 instanceof DirectiveBinding && isPresent(p.keyId4) && i.obj4 === undefinedValue)
              i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
            if (p.binding5 instanceof DirectiveBinding && isPresent(p.keyId5) && i.obj5 === undefinedValue)
              i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
            if (p.binding6 instanceof DirectiveBinding && isPresent(p.keyId6) && i.obj6 === undefinedValue)
              i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
            if (p.binding7 instanceof DirectiveBinding && isPresent(p.keyId7) && i.obj7 === undefinedValue)
              i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
            if (p.binding8 instanceof DirectiveBinding && isPresent(p.keyId8) && i.obj8 === undefinedValue)
              i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
            if (p.binding9 instanceof DirectiveBinding && isPresent(p.keyId9) && i.obj9 === undefinedValue)
              i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
          },
          dehydrate: function() {
            var i = this.injectorStrategy;
            i.obj0 = undefinedValue;
            i.obj1 = undefinedValue;
            i.obj2 = undefinedValue;
            i.obj3 = undefinedValue;
            i.obj4 = undefinedValue;
            i.obj5 = undefinedValue;
            i.obj6 = undefinedValue;
            i.obj7 = undefinedValue;
            i.obj8 = undefinedValue;
            i.obj9 = undefinedValue;
          },
          callOnDestroy: function() {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            if (p.binding0 instanceof DirectiveBinding && p.binding0.callOnDestroy) {
              i.obj0.onDestroy();
            }
            if (p.binding1 instanceof DirectiveBinding && p.binding1.callOnDestroy) {
              i.obj1.onDestroy();
            }
            if (p.binding2 instanceof DirectiveBinding && p.binding2.callOnDestroy) {
              i.obj2.onDestroy();
            }
            if (p.binding3 instanceof DirectiveBinding && p.binding3.callOnDestroy) {
              i.obj3.onDestroy();
            }
            if (p.binding4 instanceof DirectiveBinding && p.binding4.callOnDestroy) {
              i.obj4.onDestroy();
            }
            if (p.binding5 instanceof DirectiveBinding && p.binding5.callOnDestroy) {
              i.obj5.onDestroy();
            }
            if (p.binding6 instanceof DirectiveBinding && p.binding6.callOnDestroy) {
              i.obj6.onDestroy();
            }
            if (p.binding7 instanceof DirectiveBinding && p.binding7.callOnDestroy) {
              i.obj7.onDestroy();
            }
            if (p.binding8 instanceof DirectiveBinding && p.binding8.callOnDestroy) {
              i.obj8.onDestroy();
            }
            if (p.binding9 instanceof DirectiveBinding && p.binding9.callOnDestroy) {
              i.obj9.onDestroy();
            }
          },
          getComponent: function() {
            return this.injectorStrategy.obj0;
          },
          isComponentKey: function(key) {
            return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === this.injectorStrategy.protoStrategy.keyId0;
          },
          buildQueries: function() {
            var p = this.injectorStrategy.protoStrategy;
            if (p.binding0 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding0.dependencies);
            }
            if (p.binding1 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding1.dependencies);
            }
            if (p.binding2 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding2.dependencies);
            }
            if (p.binding3 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding3.dependencies);
            }
            if (p.binding4 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding4.dependencies);
            }
            if (p.binding5 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding5.dependencies);
            }
            if (p.binding6 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding6.dependencies);
            }
            if (p.binding7 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding7.dependencies);
            }
            if (p.binding8 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding8.dependencies);
            }
            if (p.binding9 instanceof DirectiveBinding) {
              this._ei._buildQueriesForDeps(p.binding9.dependencies);
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            var i = this.injectorStrategy;
            var p = i.protoStrategy;
            if (isPresent(p.binding0) && p.binding0.key.token === query.selector) {
              if (i.obj0 === undefinedValue)
                i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
              list.push(i.obj0);
            }
            if (isPresent(p.binding1) && p.binding1.key.token === query.selector) {
              if (i.obj1 === undefinedValue)
                i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
              list.push(i.obj1);
            }
            if (isPresent(p.binding2) && p.binding2.key.token === query.selector) {
              if (i.obj2 === undefinedValue)
                i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
              list.push(i.obj2);
            }
            if (isPresent(p.binding3) && p.binding3.key.token === query.selector) {
              if (i.obj3 === undefinedValue)
                i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
              list.push(i.obj3);
            }
            if (isPresent(p.binding4) && p.binding4.key.token === query.selector) {
              if (i.obj4 === undefinedValue)
                i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
              list.push(i.obj4);
            }
            if (isPresent(p.binding5) && p.binding5.key.token === query.selector) {
              if (i.obj5 === undefinedValue)
                i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
              list.push(i.obj5);
            }
            if (isPresent(p.binding6) && p.binding6.key.token === query.selector) {
              if (i.obj6 === undefinedValue)
                i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
              list.push(i.obj6);
            }
            if (isPresent(p.binding7) && p.binding7.key.token === query.selector) {
              if (i.obj7 === undefinedValue)
                i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
              list.push(i.obj7);
            }
            if (isPresent(p.binding8) && p.binding8.key.token === query.selector) {
              if (i.obj8 === undefinedValue)
                i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
              list.push(i.obj8);
            }
            if (isPresent(p.binding9) && p.binding9.key.token === query.selector) {
              if (i.obj9 === undefinedValue)
                i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
              list.push(i.obj9);
            }
          },
          getComponentBinding: function() {
            var p = this.injectorStrategy.protoStrategy;
            return p.binding0;
          }
        }, {});
      }());
      ElementInjectorDynamicStrategy = (function() {
        function ElementInjectorDynamicStrategy(injectorStrategy, _ei) {
          this.injectorStrategy = injectorStrategy;
          this._ei = _ei;
        }
        return ($traceurRuntime.createClass)(ElementInjectorDynamicStrategy, {
          hydrate: function() {
            var inj = this.injectorStrategy;
            var p = inj.protoStrategy;
            for (var i = 0; i < p.keyIds.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding && isPresent(p.keyIds[i]) && inj.objs[i] === undefinedValue) {
                inj.objs[i] = inj.instantiateBinding(p.bindings[i], p.visibilities[i]);
              }
            }
          },
          dehydrate: function() {
            var inj = this.injectorStrategy;
            ListWrapper.fill(inj.objs, undefinedValue);
          },
          callOnDestroy: function() {
            var ist = this.injectorStrategy;
            var p = ist.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding && p.bindings[i].callOnDestroy) {
                ist.objs[i].onDestroy();
              }
            }
          },
          getComponent: function() {
            return this.injectorStrategy.objs[0];
          },
          isComponentKey: function(key) {
            var p = this.injectorStrategy.protoStrategy;
            return this._ei._proto._firstBindingIsComponent && isPresent(key) && key.id === p.keyIds[0];
          },
          buildQueries: function() {
            var inj = this.injectorStrategy;
            var p = inj.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i] instanceof DirectiveBinding) {
                this._ei._buildQueriesForDeps(p.bindings[i].dependencies);
              }
            }
          },
          addDirectivesMatchingQuery: function(query, list) {
            var ist = this.injectorStrategy;
            var p = ist.protoStrategy;
            for (var i = 0; i < p.bindings.length; i++) {
              if (p.bindings[i].key.token === query.selector) {
                if (ist.objs[i] === undefinedValue) {
                  ist.objs[i] = ist.instantiateBinding(p.bindings[i], p.visibilities[i]);
                }
                list.push(ist.objs[i]);
              }
            }
          },
          getComponentBinding: function() {
            var p = this.injectorStrategy.protoStrategy;
            return p.bindings[0];
          }
        }, {});
      }());
      QueryError = (function($__super) {
        function QueryError() {
          $traceurRuntime.superConstructor(QueryError).call(this);
          this.message = 'Only 3 queries can be concurrently active in a template.';
        }
        return ($traceurRuntime.createClass)(QueryError, {toString: function() {
            return this.message;
          }}, {}, $__super);
      }(BaseException));
      $__export("QueryError", QueryError);
      QueryRef = (function() {
        function QueryRef(query, list, originator) {
          this.query = query;
          this.list = list;
          this.originator = originator;
        }
        return ($traceurRuntime.createClass)(QueryRef, {
          update: function() {
            var aggregator = [];
            this.visit(this.originator, aggregator);
            this.list.reset(aggregator);
          },
          visit: function(inj, aggregator) {
            if (isBlank(inj) || !inj._hasQuery(this))
              return ;
            if (this.query.isVarBindingQuery) {
              this._aggregateVariableBindings(inj, aggregator);
            } else {
              this._aggregateDirective(inj, aggregator);
            }
            var child = inj._head;
            while (isPresent(child)) {
              this.visit(child, aggregator);
              child = child._next;
            }
          },
          _aggregateVariableBindings: function(inj, aggregator) {
            var vb = this.query.varBindings;
            for (var i = 0; i < vb.length; ++i) {
              if (inj.hasVariableBinding(vb[i])) {
                aggregator.push(inj.getVariableBinding(vb[i]));
              }
            }
          },
          _aggregateDirective: function(inj, aggregator) {
            inj.addDirectivesMatchingQuery(this.query, aggregator);
          }
        }, {});
      }());
      $__export("QueryRef", QueryRef);
    }
  };
});

System.register("angular2/src/render/dom/compiler/compiler", ["angular2/di", "angular2/src/facade/async", "angular2/src/facade/lang", "angular2/src/dom/dom_adapter", "angular2/src/render/api", "angular2/src/render/dom/compiler/compile_pipeline", "angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/compiler/compile_step_factory", "angular2/src/change_detection/change_detection", "angular2/src/render/dom/view/proto_view_merger", "angular2/src/render/dom/dom_tokens", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/util"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/dom/compiler/compiler";
  var __decorate,
      __metadata,
      __param,
      Injectable,
      PromiseWrapper,
      BaseException,
      DOM,
      ViewDefinition,
      ViewType,
      RenderCompiler,
      ViewEncapsulation,
      CompilePipeline,
      ViewLoader,
      TemplateAndStyles,
      DefaultStepFactory,
      Parser,
      pvm,
      APP_ID_TOKEN,
      Inject,
      SharedStylesHost,
      prependAll,
      DomCompiler,
      DefaultDomCompiler;
  return {
    setters: [function($__m) {
      Injectable = $__m.Injectable;
      Inject = $__m.Inject;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      BaseException = $__m.BaseException;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      ViewDefinition = $__m.ViewDefinition;
      ViewType = $__m.ViewType;
      RenderCompiler = $__m.RenderCompiler;
      ViewEncapsulation = $__m.ViewEncapsulation;
    }, function($__m) {
      CompilePipeline = $__m.CompilePipeline;
    }, function($__m) {
      ViewLoader = $__m.ViewLoader;
      TemplateAndStyles = $__m.TemplateAndStyles;
    }, function($__m) {
      DefaultStepFactory = $__m.DefaultStepFactory;
    }, function($__m) {
      Parser = $__m.Parser;
    }, function($__m) {
      pvm = $__m;
    }, function($__m) {
      APP_ID_TOKEN = $__m.APP_ID_TOKEN;
    }, function($__m) {
      SharedStylesHost = $__m.SharedStylesHost;
    }, function($__m) {
      prependAll = $__m.prependAll;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      DomCompiler = (function($__super) {
        function DomCompiler(_stepFactory, _viewLoader, _sharedStylesHost) {
          $traceurRuntime.superConstructor(DomCompiler).call(this);
          this._stepFactory = _stepFactory;
          this._viewLoader = _viewLoader;
          this._sharedStylesHost = _sharedStylesHost;
        }
        return ($traceurRuntime.createClass)(DomCompiler, {
          compile: function(view) {
            var $__0 = this;
            var tplPromise = this._viewLoader.load(view);
            return PromiseWrapper.then(tplPromise, (function(tplAndStyles) {
              return $__0._compileView(view, tplAndStyles, ViewType.COMPONENT);
            }), (function(e) {
              throw new BaseException(("Failed to load the template for \"" + view.componentId + "\" : " + e));
              return null;
            }));
          },
          compileHost: function(directiveMetadata) {
            var hostViewDef = new ViewDefinition({
              componentId: directiveMetadata.id,
              templateAbsUrl: null,
              template: null,
              styles: null,
              styleAbsUrls: null,
              directives: [directiveMetadata],
              encapsulation: ViewEncapsulation.NONE
            });
            return this._compileView(hostViewDef, new TemplateAndStyles(("<" + directiveMetadata.selector + "></" + directiveMetadata.selector + ">"), []), ViewType.HOST);
          },
          mergeProtoViewsRecursively: function(protoViewRefs) {
            return PromiseWrapper.resolve(pvm.mergeProtoViewsRecursively(protoViewRefs));
          },
          _compileView: function(viewDef, templateAndStyles, protoViewType) {
            if (viewDef.encapsulation === ViewEncapsulation.EMULATED && templateAndStyles.styles.length === 0) {
              viewDef = this._normalizeViewEncapsulationIfThereAreNoStyles(viewDef);
            }
            var pipeline = new CompilePipeline(this._stepFactory.createSteps(viewDef));
            var compiledStyles = pipeline.processStyles(templateAndStyles.styles);
            var compileElements = pipeline.processElements(DOM.createTemplate(templateAndStyles.template), protoViewType, viewDef);
            if (viewDef.encapsulation === ViewEncapsulation.NATIVE) {
              prependAll(DOM.content(compileElements[0].element), compiledStyles.map((function(style) {
                return DOM.createStyleElement(style);
              })));
            } else {
              this._sharedStylesHost.addStyles(compiledStyles);
            }
            return PromiseWrapper.resolve(compileElements[0].inheritedProtoView.build());
          },
          _normalizeViewEncapsulationIfThereAreNoStyles: function(viewDef) {
            if (viewDef.encapsulation === ViewEncapsulation.EMULATED) {
              return new ViewDefinition({
                componentId: viewDef.componentId,
                templateAbsUrl: viewDef.templateAbsUrl,
                template: viewDef.template,
                styleAbsUrls: viewDef.styleAbsUrls,
                styles: viewDef.styles,
                directives: viewDef.directives,
                encapsulation: ViewEncapsulation.NONE
              });
            } else {
              return viewDef;
            }
          }
        }, {}, $__super);
      }(RenderCompiler));
      $__export("DomCompiler", DomCompiler);
      DefaultDomCompiler = (function($__super) {
        function $__1(parser, viewLoader, sharedStylesHost, appId) {
          $traceurRuntime.superConstructor($__1).call(this, new DefaultStepFactory(parser, appId), viewLoader, sharedStylesHost);
        }
        return ($traceurRuntime.createClass)($__1, {}, {}, $__super);
      }(DomCompiler));
      $__export("DefaultDomCompiler", DefaultDomCompiler);
      $__export("DefaultDomCompiler", DefaultDomCompiler = __decorate([Injectable(), __param(3, Inject(APP_ID_TOKEN)), __metadata('design:paramtypes', [Parser, ViewLoader, SharedStylesHost, Object])], DefaultDomCompiler));
    }
  };
});

System.register("angular2/http", ["angular2/di", "angular2/src/http/http", "angular2/src/http/backends/xhr_backend", "angular2/src/http/backends/jsonp_backend", "angular2/src/http/backends/browser_xhr", "angular2/src/http/backends/browser_jsonp", "angular2/src/http/base_request_options", "angular2/src/http/interfaces", "angular2/src/http/base_response_options", "angular2/src/http/backends/mock_backend", "angular2/src/http/static_request", "angular2/src/http/static_response", "angular2/src/http/headers", "angular2/src/http/enums", "angular2/src/http/url_search_params"], function($__export) {
  "use strict";
  var __moduleName = "angular2/http";
  var bind,
      Http,
      Jsonp,
      XHRBackend,
      JSONPBackend,
      BrowserXhr,
      BrowserJsonp,
      BaseRequestOptions,
      RequestOptions,
      ConnectionBackend,
      BaseResponseOptions,
      ResponseOptions,
      httpInjectables,
      jsonpInjectables;
  return {
    setters: [function($__m) {
      bind = $__m.bind;
    }, function($__m) {
      Http = $__m.Http;
      Jsonp = $__m.Jsonp;
      $__export("Http", $__m.Http);
      $__export("Jsonp", $__m.Jsonp);
    }, function($__m) {
      XHRBackend = $__m.XHRBackend;
      $__export("XHRBackend", $__m.XHRBackend);
      $__export("XHRConnection", $__m.XHRConnection);
    }, function($__m) {
      JSONPBackend = $__m.JSONPBackend;
      $__export("JSONPBackend", $__m.JSONPBackend);
      $__export("JSONPConnection", $__m.JSONPConnection);
    }, function($__m) {
      BrowserXhr = $__m.BrowserXhr;
      $__export("BrowserXhr", $__m.BrowserXhr);
    }, function($__m) {
      BrowserJsonp = $__m.BrowserJsonp;
    }, function($__m) {
      BaseRequestOptions = $__m.BaseRequestOptions;
      RequestOptions = $__m.RequestOptions;
      $__export("BaseRequestOptions", $__m.BaseRequestOptions);
      $__export("RequestOptions", $__m.RequestOptions);
    }, function($__m) {
      ConnectionBackend = $__m.ConnectionBackend;
      $__export("Connection", $__m.Connection);
      $__export("ConnectionBackend", $__m.ConnectionBackend);
    }, function($__m) {
      BaseResponseOptions = $__m.BaseResponseOptions;
      ResponseOptions = $__m.ResponseOptions;
      $__export("BaseResponseOptions", $__m.BaseResponseOptions);
      $__export("ResponseOptions", $__m.ResponseOptions);
    }, function($__m) {
      $__export("MockConnection", $__m.MockConnection);
      $__export("MockBackend", $__m.MockBackend);
    }, function($__m) {
      $__export("Request", $__m.Request);
    }, function($__m) {
      $__export("Response", $__m.Response);
    }, function($__m) {
      $__export("Headers", $__m.Headers);
    }, function($__m) {
      $__export("ResponseTypes", $__m.ResponseTypes);
      $__export("ReadyStates", $__m.ReadyStates);
      $__export("RequestMethods", $__m.RequestMethods);
      $__export("RequestCredentialsOpts", $__m.RequestCredentialsOpts);
      $__export("RequestCacheOpts", $__m.RequestCacheOpts);
      $__export("RequestModesOpts", $__m.RequestModesOpts);
    }, function($__m) {
      $__export("URLSearchParams", $__m.URLSearchParams);
    }],
    execute: function() {
      httpInjectables = [bind(ConnectionBackend).toClass(XHRBackend), BrowserXhr, bind(RequestOptions).toClass(BaseRequestOptions), bind(ResponseOptions).toClass(BaseResponseOptions), Http];
      $__export("httpInjectables", httpInjectables);
      jsonpInjectables = [bind(ConnectionBackend).toClass(JSONPBackend), BrowserJsonp, bind(RequestOptions).toClass(BaseRequestOptions), bind(ResponseOptions).toClass(BaseResponseOptions), Jsonp];
      $__export("jsonpInjectables", jsonpInjectables);
    }
  };
});

System.register("angular2/di", ["angular2/src/di/metadata", "angular2/src/di/decorators", "angular2/src/di/forward_ref", "angular2/src/di/injector", "angular2/src/di/binding", "angular2/src/di/key", "angular2/src/di/exceptions", "angular2/src/di/opaque_token"], function($__export) {
  "use strict";
  var __moduleName = "angular2/di";
  var $__exportNames = {undefined: true};
  return {
    setters: [function($__m) {
      $__export("InjectMetadata", $__m.InjectMetadata);
      $__export("OptionalMetadata", $__m.OptionalMetadata);
      $__export("InjectableMetadata", $__m.InjectableMetadata);
      $__export("VisibilityMetadata", $__m.VisibilityMetadata);
      $__export("SelfMetadata", $__m.SelfMetadata);
      $__export("AncestorMetadata", $__m.AncestorMetadata);
      $__export("UnboundedMetadata", $__m.UnboundedMetadata);
      $__export("DependencyMetadata", $__m.DependencyMetadata);
      $__export("DEFAULT_VISIBILITY", $__m.DEFAULT_VISIBILITY);
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      $__export("forwardRef", $__m.forwardRef);
      $__export("resolveForwardRef", $__m.resolveForwardRef);
    }, function($__m) {
      $__export("Injector", $__m.Injector);
      $__export("ProtoInjector", $__m.ProtoInjector);
      $__export("BindingWithVisibility", $__m.BindingWithVisibility);
      $__export("PUBLIC_AND_PRIVATE", $__m.PUBLIC_AND_PRIVATE);
      $__export("PUBLIC", $__m.PUBLIC);
      $__export("PRIVATE", $__m.PRIVATE);
      $__export("undefinedValue", $__m.undefinedValue);
    }, function($__m) {
      $__export("Binding", $__m.Binding);
      $__export("BindingBuilder", $__m.BindingBuilder);
      $__export("ResolvedBinding", $__m.ResolvedBinding);
      $__export("Dependency", $__m.Dependency);
      $__export("bind", $__m.bind);
    }, function($__m) {
      $__export("Key", $__m.Key);
      $__export("KeyRegistry", $__m.KeyRegistry);
      $__export("TypeLiteral", $__m.TypeLiteral);
    }, function($__m) {
      $__export("NoBindingError", $__m.NoBindingError);
      $__export("AbstractBindingError", $__m.AbstractBindingError);
      $__export("CyclicDependencyError", $__m.CyclicDependencyError);
      $__export("InstantiationError", $__m.InstantiationError);
      $__export("InvalidBindingError", $__m.InvalidBindingError);
      $__export("NoAnnotationError", $__m.NoAnnotationError);
      $__export("OutOfBoundsError", $__m.OutOfBoundsError);
    }, function($__m) {
      $__export("OpaqueToken", $__m.OpaqueToken);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/change_detection/jit_proto_change_detector", ["angular2/src/facade/collection", "angular2/src/change_detection/change_detection_jit_generator", "angular2/src/change_detection/coalesce", "angular2/src/change_detection/proto_change_detector"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/jit_proto_change_detector";
  var ListWrapper,
      ChangeDetectorJITGenerator,
      coalesce,
      ProtoRecordBuilder,
      JitProtoChangeDetector;
  return {
    setters: [function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      ChangeDetectorJITGenerator = $__m.ChangeDetectorJITGenerator;
    }, function($__m) {
      coalesce = $__m.coalesce;
    }, function($__m) {
      ProtoRecordBuilder = $__m.ProtoRecordBuilder;
    }],
    execute: function() {
      JitProtoChangeDetector = (function() {
        function JitProtoChangeDetector(definition) {
          this.definition = definition;
          this._factory = this._createFactory(definition);
        }
        return ($traceurRuntime.createClass)(JitProtoChangeDetector, {
          instantiate: function(dispatcher) {
            return this._factory(dispatcher);
          },
          _createFactory: function(definition) {
            var recordBuilder = new ProtoRecordBuilder();
            ListWrapper.forEach(definition.bindingRecords, (function(b) {
              recordBuilder.add(b, definition.variableNames);
            }));
            var records = coalesce(recordBuilder.records);
            return new ChangeDetectorJITGenerator(definition.id, definition.strategy, records, this.definition.directiveRecords, this.definition.generateCheckNoChanges).generate();
          }
        }, {isSupported: function() {
            return true;
          }});
      }());
      $__export("JitProtoChangeDetector", JitProtoChangeDetector);
    }
  };
});

System.register("angular2/src/render/render", ["angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/render/dom/compiler/compiler", "angular2/src/render/dom/dom_renderer", "angular2/src/render/dom/dom_tokens", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/render/render";
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  var $__exportNames = {};
  return {
    setters: [function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

System.register("angular2/src/change_detection/change_detection", ["angular2/src/change_detection/jit_proto_change_detector", "angular2/src/change_detection/pregen_proto_change_detector", "angular2/src/change_detection/proto_change_detector", "angular2/src/change_detection/pipes/pipes", "angular2/src/change_detection/pipes/iterable_changes", "angular2/src/change_detection/pipes/keyvalue_changes", "angular2/src/change_detection/pipes/observable_pipe", "angular2/src/change_detection/pipes/promise_pipe", "angular2/src/change_detection/pipes/uppercase_pipe", "angular2/src/change_detection/pipes/lowercase_pipe", "angular2/src/change_detection/pipes/json_pipe", "angular2/src/change_detection/pipes/limit_to_pipe", "angular2/src/change_detection/pipes/date_pipe", "angular2/src/change_detection/pipes/number_pipe", "angular2/src/change_detection/pipes/null_pipe", "angular2/src/change_detection/interfaces", "angular2/di", "angular2/src/facade/collection", "angular2/src/facade/lang", "angular2/src/change_detection/parser/ast", "angular2/src/change_detection/parser/lexer", "angular2/src/change_detection/parser/parser", "angular2/src/change_detection/parser/locals", "angular2/src/change_detection/exceptions", "angular2/src/change_detection/constants", "angular2/src/change_detection/binding_record", "angular2/src/change_detection/directive_record", "angular2/src/change_detection/dynamic_change_detector", "angular2/src/change_detection/change_detector_ref", "angular2/src/change_detection/pipes/pipe"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/change_detection/change_detection";
  var __decorate,
      __metadata,
      __param,
      JitProtoChangeDetector,
      PregenProtoChangeDetector,
      DynamicProtoChangeDetector,
      Pipes,
      IterableChangesFactory,
      KeyValueChangesFactory,
      ObservablePipeFactory,
      PromisePipeFactory,
      UpperCasePipe,
      LowerCasePipe,
      JsonPipe,
      LimitToPipeFactory,
      DatePipe,
      DecimalPipe,
      PercentPipe,
      CurrencyPipe,
      NullPipeFactory,
      ChangeDetection,
      Inject,
      Injectable,
      OpaqueToken,
      Optional,
      StringMapWrapper,
      CONST,
      CONST_EXPR,
      isPresent,
      keyValDiff,
      iterableDiff,
      async,
      uppercase,
      lowercase,
      json,
      limitTo,
      decimal,
      percent,
      currency,
      date,
      defaultPipes,
      preGeneratedProtoDetectors,
      PROTO_CHANGE_DETECTOR_KEY,
      PreGeneratedChangeDetection,
      DynamicChangeDetection,
      JitChangeDetection;
  return {
    setters: [function($__m) {
      JitProtoChangeDetector = $__m.JitProtoChangeDetector;
    }, function($__m) {
      PregenProtoChangeDetector = $__m.PregenProtoChangeDetector;
    }, function($__m) {
      DynamicProtoChangeDetector = $__m.DynamicProtoChangeDetector;
      $__export("DynamicProtoChangeDetector", $__m.DynamicProtoChangeDetector);
    }, function($__m) {
      Pipes = $__m.Pipes;
      $__export("Pipes", $__m.Pipes);
    }, function($__m) {
      IterableChangesFactory = $__m.IterableChangesFactory;
    }, function($__m) {
      KeyValueChangesFactory = $__m.KeyValueChangesFactory;
    }, function($__m) {
      ObservablePipeFactory = $__m.ObservablePipeFactory;
    }, function($__m) {
      PromisePipeFactory = $__m.PromisePipeFactory;
    }, function($__m) {
      UpperCasePipe = $__m.UpperCasePipe;
    }, function($__m) {
      LowerCasePipe = $__m.LowerCasePipe;
    }, function($__m) {
      JsonPipe = $__m.JsonPipe;
    }, function($__m) {
      LimitToPipeFactory = $__m.LimitToPipeFactory;
    }, function($__m) {
      DatePipe = $__m.DatePipe;
    }, function($__m) {
      DecimalPipe = $__m.DecimalPipe;
      PercentPipe = $__m.PercentPipe;
      CurrencyPipe = $__m.CurrencyPipe;
    }, function($__m) {
      NullPipeFactory = $__m.NullPipeFactory;
      $__export("NullPipe", $__m.NullPipe);
      $__export("NullPipeFactory", $__m.NullPipeFactory);
    }, function($__m) {
      ChangeDetection = $__m.ChangeDetection;
      $__export("ChangeDetection", $__m.ChangeDetection);
      $__export("ChangeDetectorDefinition", $__m.ChangeDetectorDefinition);
    }, function($__m) {
      Inject = $__m.Inject;
      Injectable = $__m.Injectable;
      OpaqueToken = $__m.OpaqueToken;
      Optional = $__m.Optional;
    }, function($__m) {
      StringMapWrapper = $__m.StringMapWrapper;
    }, function($__m) {
      CONST = $__m.CONST;
      CONST_EXPR = $__m.CONST_EXPR;
      isPresent = $__m.isPresent;
    }, function($__m) {
      $__export("ASTWithSource", $__m.ASTWithSource);
      $__export("AST", $__m.AST);
      $__export("AstTransformer", $__m.AstTransformer);
      $__export("AccessMember", $__m.AccessMember);
      $__export("LiteralArray", $__m.LiteralArray);
      $__export("ImplicitReceiver", $__m.ImplicitReceiver);
    }, function($__m) {
      $__export("Lexer", $__m.Lexer);
    }, function($__m) {
      $__export("Parser", $__m.Parser);
    }, function($__m) {
      $__export("Locals", $__m.Locals);
    }, function($__m) {
      $__export("DehydratedException", $__m.DehydratedException);
      $__export("ExpressionChangedAfterItHasBeenCheckedException", $__m.ExpressionChangedAfterItHasBeenCheckedException);
      $__export("ChangeDetectionError", $__m.ChangeDetectionError);
    }, function($__m) {
      $__export("CHECK_ONCE", $__m.CHECK_ONCE);
      $__export("CHECK_ALWAYS", $__m.CHECK_ALWAYS);
      $__export("DETACHED", $__m.DETACHED);
      $__export("CHECKED", $__m.CHECKED);
      $__export("ON_PUSH", $__m.ON_PUSH);
      $__export("DEFAULT", $__m.DEFAULT);
    }, function($__m) {
      $__export("BindingRecord", $__m.BindingRecord);
    }, function($__m) {
      $__export("DirectiveIndex", $__m.DirectiveIndex);
      $__export("DirectiveRecord", $__m.DirectiveRecord);
    }, function($__m) {
      $__export("DynamicChangeDetector", $__m.DynamicChangeDetector);
    }, function($__m) {
      $__export("ChangeDetectorRef", $__m.ChangeDetectorRef);
    }, function($__m) {
      $__export("WrappedValue", $__m.WrappedValue);
      $__export("BasePipe", $__m.BasePipe);
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      __param = (this && this.__param) || function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      keyValDiff = CONST_EXPR([CONST_EXPR(new KeyValueChangesFactory()), CONST_EXPR(new NullPipeFactory())]);
      $__export("keyValDiff", keyValDiff);
      iterableDiff = CONST_EXPR([CONST_EXPR(new IterableChangesFactory()), CONST_EXPR(new NullPipeFactory())]);
      $__export("iterableDiff", iterableDiff);
      async = CONST_EXPR([CONST_EXPR(new ObservablePipeFactory()), CONST_EXPR(new PromisePipeFactory()), CONST_EXPR(new NullPipeFactory())]);
      $__export("async", async);
      uppercase = CONST_EXPR([CONST_EXPR(new UpperCasePipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("uppercase", uppercase);
      lowercase = CONST_EXPR([CONST_EXPR(new LowerCasePipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("lowercase", lowercase);
      json = CONST_EXPR([CONST_EXPR(new JsonPipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("json", json);
      limitTo = CONST_EXPR([CONST_EXPR(new LimitToPipeFactory()), CONST_EXPR(new NullPipeFactory())]);
      $__export("limitTo", limitTo);
      decimal = CONST_EXPR([CONST_EXPR(new DecimalPipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("decimal", decimal);
      percent = CONST_EXPR([CONST_EXPR(new PercentPipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("percent", percent);
      currency = CONST_EXPR([CONST_EXPR(new CurrencyPipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("currency", currency);
      date = CONST_EXPR([CONST_EXPR(new DatePipe()), CONST_EXPR(new NullPipeFactory())]);
      $__export("date", date);
      defaultPipes = CONST_EXPR(new Pipes({
        "iterableDiff": iterableDiff,
        "keyValDiff": keyValDiff,
        "async": async,
        "uppercase": uppercase,
        "lowercase": lowercase,
        "json": json,
        "limitTo": limitTo,
        "number": decimal,
        "percent": percent,
        "currency": currency,
        "date": date
      }));
      $__export("defaultPipes", defaultPipes);
      preGeneratedProtoDetectors = {};
      $__export("preGeneratedProtoDetectors", preGeneratedProtoDetectors);
      PROTO_CHANGE_DETECTOR_KEY = CONST_EXPR(new OpaqueToken('ProtoChangeDetectors'));
      $__export("PROTO_CHANGE_DETECTOR_KEY", PROTO_CHANGE_DETECTOR_KEY);
      PreGeneratedChangeDetection = (function($__super) {
        function $__0(protoChangeDetectorsForTest) {
          $traceurRuntime.superConstructor($__0).call(this);
          this._dynamicChangeDetection = new DynamicChangeDetection();
          this._protoChangeDetectorFactories = isPresent(protoChangeDetectorsForTest) ? protoChangeDetectorsForTest : preGeneratedProtoDetectors;
        }
        return ($traceurRuntime.createClass)($__0, {createProtoChangeDetector: function(definition) {
            var id = definition.id;
            if (StringMapWrapper.contains(this._protoChangeDetectorFactories, id)) {
              return StringMapWrapper.get(this._protoChangeDetectorFactories, id)(definition);
            }
            return this._dynamicChangeDetection.createProtoChangeDetector(definition);
          }}, {isSupported: function() {
            return PregenProtoChangeDetector.isSupported();
          }}, $__super);
      }(ChangeDetection));
      $__export("PreGeneratedChangeDetection", PreGeneratedChangeDetection);
      $__export("PreGeneratedChangeDetection", PreGeneratedChangeDetection = __decorate([Injectable(), __param(0, Inject(PROTO_CHANGE_DETECTOR_KEY)), __param(0, Optional()), __metadata('design:paramtypes', [Object])], PreGeneratedChangeDetection));
      DynamicChangeDetection = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {createProtoChangeDetector: function(definition) {
            return new DynamicProtoChangeDetector(definition);
          }}, {}, $__super);
      }(ChangeDetection));
      $__export("DynamicChangeDetection", DynamicChangeDetection);
      $__export("DynamicChangeDetection", DynamicChangeDetection = __decorate([Injectable(), __metadata('design:paramtypes', [])], DynamicChangeDetection));
      JitChangeDetection = (function($__super) {
        function $__0() {
          $traceurRuntime.superConstructor($__0).apply(this, arguments);
        }
        return ($traceurRuntime.createClass)($__0, {createProtoChangeDetector: function(definition) {
            return new JitProtoChangeDetector(definition);
          }}, {isSupported: function() {
            return JitProtoChangeDetector.isSupported();
          }}, $__super);
      }(ChangeDetection));
      $__export("JitChangeDetection", JitChangeDetection);
      $__export("JitChangeDetection", JitChangeDetection = __decorate([Injectable(), CONST(), __metadata('design:paramtypes', [])], JitChangeDetection));
    }
  };
});

System.register("angular2/change_detection", ["angular2/src/change_detection/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/change_detection";
  return {
    setters: [function($__m) {
      $__export("CHECK_ONCE", $__m.CHECK_ONCE);
      $__export("CHECK_ALWAYS", $__m.CHECK_ALWAYS);
      $__export("DETACHED", $__m.DETACHED);
      $__export("CHECKED", $__m.CHECKED);
      $__export("ON_PUSH", $__m.ON_PUSH);
      $__export("DEFAULT", $__m.DEFAULT);
      $__export("ExpressionChangedAfterItHasBeenCheckedException", $__m.ExpressionChangedAfterItHasBeenCheckedException);
      $__export("ChangeDetectionError", $__m.ChangeDetectionError);
      $__export("ChangeDetectorRef", $__m.ChangeDetectorRef);
      $__export("WrappedValue", $__m.WrappedValue);
      $__export("Pipes", $__m.Pipes);
      $__export("BasePipe", $__m.BasePipe);
      $__export("NullPipe", $__m.NullPipe);
      $__export("NullPipeFactory", $__m.NullPipeFactory);
    }],
    execute: function() {}
  };
});

System.register("angular2/src/core/annotations_impl/annotations", ["angular2/src/facade/lang", "angular2/src/di/metadata", "angular2/change_detection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/annotations_impl/annotations";
  var __decorate,
      __metadata,
      CONST,
      InjectableMetadata,
      DEFAULT,
      Directive,
      Component,
      LifecycleEvent;
  return {
    setters: [function($__m) {
      CONST = $__m.CONST;
    }, function($__m) {
      InjectableMetadata = $__m.InjectableMetadata;
    }, function($__m) {
      DEFAULT = $__m.DEFAULT;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      Directive = (function($__super) {
        function $__0() {
          var $__3;
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__2.selector,
              properties = $__2.properties,
              events = $__2.events,
              host = $__2.host,
              lifecycle = $__2.lifecycle,
              hostInjector = $__2.hostInjector,
              exportAs = $__2.exportAs,
              compileChildren = ($__3 = $__2.compileChildren) === void 0 ? true : $__3;
          $traceurRuntime.superConstructor($__0).call(this);
          this.selector = selector;
          this.properties = properties;
          this.events = events;
          this.host = host;
          this.exportAs = exportAs;
          this.lifecycle = lifecycle;
          this.compileChildren = compileChildren;
          this.hostInjector = hostInjector;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(InjectableMetadata));
      $__export("Directive", Directive);
      $__export("Directive", Directive = __decorate([CONST(), __metadata('design:paramtypes', [Object])], Directive));
      Component = (function($__super) {
        function $__0() {
          var $__3,
              $__4;
          var $__2 = arguments[0] !== (void 0) ? arguments[0] : {},
              selector = $__2.selector,
              properties = $__2.properties,
              events = $__2.events,
              host = $__2.host,
              exportAs = $__2.exportAs,
              lifecycle = $__2.lifecycle,
              hostInjector = $__2.hostInjector,
              viewInjector = $__2.viewInjector,
              changeDetection = ($__3 = $__2.changeDetection) === void 0 ? DEFAULT : $__3,
              compileChildren = ($__4 = $__2.compileChildren) === void 0 ? true : $__4;
          $traceurRuntime.superConstructor($__0).call(this, {
            selector: selector,
            properties: properties,
            events: events,
            host: host,
            exportAs: exportAs,
            hostInjector: hostInjector,
            lifecycle: lifecycle,
            compileChildren: compileChildren
          });
          this.changeDetection = changeDetection;
          this.viewInjector = viewInjector;
        }
        return ($traceurRuntime.createClass)($__0, {}, {}, $__super);
      }(Directive));
      $__export("Component", Component);
      $__export("Component", Component = __decorate([CONST(), __metadata('design:paramtypes', [Object])], Component));
      $__export("LifecycleEvent", LifecycleEvent);
      (function(LifecycleEvent) {
        LifecycleEvent[LifecycleEvent["onDestroy"] = 0] = "onDestroy";
        LifecycleEvent[LifecycleEvent["onChange"] = 1] = "onChange";
        LifecycleEvent[LifecycleEvent["onCheck"] = 2] = "onCheck";
        LifecycleEvent[LifecycleEvent["onInit"] = 3] = "onInit";
        LifecycleEvent[LifecycleEvent["onAllChangesDone"] = 4] = "onAllChangesDone";
      })(LifecycleEvent || ($__export("LifecycleEvent", LifecycleEvent = {})));
    }
  };
});

System.register("angular2/src/core/compiler/directive_resolver", ["angular2/di", "angular2/src/facade/lang", "angular2/src/core/annotations_impl/annotations", "angular2/src/reflection/reflection"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/directive_resolver";
  var __decorate,
      __metadata,
      resolveForwardRef,
      Injectable,
      isPresent,
      BaseException,
      stringify,
      Directive,
      reflector,
      DirectiveResolver;
  return {
    setters: [function($__m) {
      resolveForwardRef = $__m.resolveForwardRef;
      Injectable = $__m.Injectable;
    }, function($__m) {
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      stringify = $__m.stringify;
    }, function($__m) {
      Directive = $__m.Directive;
    }, function($__m) {
      reflector = $__m.reflector;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      DirectiveResolver = (($traceurRuntime.createClass)(function() {}, {resolve: function(type) {
          var annotations = reflector.annotations(resolveForwardRef(type));
          if (isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
              var annotation = annotations[i];
              if (annotation instanceof Directive) {
                return annotation;
              }
            }
          }
          throw new BaseException(("No Directive annotation found on " + stringify(type)));
        }}, {}));
      $__export("DirectiveResolver", DirectiveResolver);
      $__export("DirectiveResolver", DirectiveResolver = __decorate([Injectable(), __metadata('design:paramtypes', [])], DirectiveResolver));
    }
  };
});

System.register("angular2/src/core/compiler/compiler", ["angular2/di", "angular2/src/facade/lang", "angular2/src/facade/async", "angular2/src/facade/collection", "angular2/src/core/compiler/directive_resolver", "angular2/src/core/compiler/view", "angular2/src/core/compiler/element_injector", "angular2/src/core/compiler/view_resolver", "angular2/src/core/compiler/component_url_mapper", "angular2/src/core/compiler/proto_view_factory", "angular2/src/services/url_resolver", "angular2/src/services/app_root_url", "angular2/src/render/api"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/compiler/compiler";
  var __decorate,
      __metadata,
      Binding,
      resolveForwardRef,
      Injectable,
      Type,
      isBlank,
      isType,
      isPresent,
      BaseException,
      normalizeBlank,
      stringify,
      isArray,
      isPromise,
      PromiseWrapper,
      ListWrapper,
      Map,
      MapWrapper,
      DirectiveResolver,
      AppProtoViewMergeMapping,
      DirectiveBinding,
      ViewResolver,
      ComponentUrlMapper,
      ProtoViewFactory,
      UrlResolver,
      AppRootUrl,
      renderApi,
      CompilerCache,
      Compiler;
  return {
    setters: [function($__m) {
      Binding = $__m.Binding;
      resolveForwardRef = $__m.resolveForwardRef;
      Injectable = $__m.Injectable;
    }, function($__m) {
      Type = $__m.Type;
      isBlank = $__m.isBlank;
      isType = $__m.isType;
      isPresent = $__m.isPresent;
      BaseException = $__m.BaseException;
      normalizeBlank = $__m.normalizeBlank;
      stringify = $__m.stringify;
      isArray = $__m.isArray;
      isPromise = $__m.isPromise;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
      Map = $__m.Map;
      MapWrapper = $__m.MapWrapper;
    }, function($__m) {
      DirectiveResolver = $__m.DirectiveResolver;
    }, function($__m) {
      AppProtoViewMergeMapping = $__m.AppProtoViewMergeMapping;
    }, function($__m) {
      DirectiveBinding = $__m.DirectiveBinding;
    }, function($__m) {
      ViewResolver = $__m.ViewResolver;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      renderApi = $__m;
    }],
    execute: function() {
      __decorate = (this && this.__decorate) || function(decorators, target, key, desc) {
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          return Reflect.decorate(decorators, target, key, desc);
        switch (arguments.length) {
          case 2:
            return decorators.reduceRight(function(o, d) {
              return (d && d(o)) || o;
            }, target);
          case 3:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key)), void 0;
            }, void 0);
          case 4:
            return decorators.reduceRight(function(o, d) {
              return (d && d(target, key, o)) || o;
            }, desc);
        }
      };
      __metadata = (this && this.__metadata) || function(k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(k, v);
      };
      CompilerCache = (($traceurRuntime.createClass)(function() {
        this._cache = new Map();
        this._hostCache = new Map();
      }, {
        set: function(component, protoView) {
          this._cache.set(component, protoView);
        },
        get: function(component) {
          var result = this._cache.get(component);
          return normalizeBlank(result);
        },
        setHost: function(component, protoView) {
          this._hostCache.set(component, protoView);
        },
        getHost: function(component) {
          var result = this._hostCache.get(component);
          return normalizeBlank(result);
        },
        clear: function() {
          this._cache.clear();
          this._hostCache.clear();
        }
      }, {}));
      $__export("CompilerCache", CompilerCache);
      $__export("CompilerCache", CompilerCache = __decorate([Injectable(), __metadata('design:paramtypes', [])], CompilerCache));
      Compiler = (($traceurRuntime.createClass)(function(reader, cache, viewResolver, componentUrlMapper, urlResolver, render, protoViewFactory, appUrl) {
        this._reader = reader;
        this._compilerCache = cache;
        this._compiling = new Map();
        this._viewResolver = viewResolver;
        this._componentUrlMapper = componentUrlMapper;
        this._urlResolver = urlResolver;
        this._appUrl = appUrl.value;
        this._render = render;
        this._protoViewFactory = protoViewFactory;
      }, {
        _bindDirective: function(directiveTypeOrBinding) {
          if (directiveTypeOrBinding instanceof DirectiveBinding) {
            return directiveTypeOrBinding;
          } else if (directiveTypeOrBinding instanceof Binding) {
            var annotation = this._reader.resolve(directiveTypeOrBinding.token);
            return DirectiveBinding.createFromBinding(directiveTypeOrBinding, annotation);
          } else {
            var annotation$__3 = this._reader.resolve(directiveTypeOrBinding);
            return DirectiveBinding.createFromType(directiveTypeOrBinding, annotation$__3);
          }
        },
        compileInHost: function(componentTypeOrBinding) {
          var $__0 = this;
          var componentType = isType(componentTypeOrBinding) ? componentTypeOrBinding : componentTypeOrBinding.token;
          var hostAppProtoView = this._compilerCache.getHost(componentType);
          var hostPvPromise;
          if (isPresent(hostAppProtoView)) {
            hostPvPromise = PromiseWrapper.resolve(hostAppProtoView);
          } else {
            var componentBinding = this._bindDirective(componentTypeOrBinding);
            Compiler._assertTypeIsComponent(componentBinding);
            var directiveMetadata = componentBinding.metadata;
            hostPvPromise = this._render.compileHost(directiveMetadata).then((function(hostRenderPv) {
              var protoViews = $__0._protoViewFactory.createAppProtoViews(componentBinding, hostRenderPv, [componentBinding]);
              return $__0._compileNestedProtoViews(protoViews, componentType, new Map());
            })).then((function(appProtoView) {
              $__0._compilerCache.setHost(componentType, appProtoView);
              return appProtoView;
            }));
          }
          return hostPvPromise.then((function(hostAppProtoView) {
            return hostAppProtoView.ref;
          }));
        },
        _compile: function(componentBinding, componentPath) {
          var $__0 = this;
          var component = componentBinding.key.token;
          var protoView = this._compilerCache.get(component);
          if (isPresent(protoView)) {
            return protoView;
          }
          var resultPromise = this._compiling.get(component);
          if (isPresent(resultPromise)) {
            return resultPromise;
          }
          var view = this._viewResolver.resolve(component);
          var directives = this._flattenDirectives(view);
          for (var i = 0; i < directives.length; i++) {
            if (!Compiler._isValidDirective(directives[i])) {
              throw new BaseException(("Unexpected directive value '" + stringify(directives[i]) + "' on the View of component '" + stringify(component) + "'"));
            }
          }
          var boundDirectives = this._removeDuplicatedDirectives(ListWrapper.map(directives, (function(directive) {
            return $__0._bindDirective(directive);
          })));
          var renderTemplate = this._buildRenderTemplate(component, view, boundDirectives);
          resultPromise = this._render.compile(renderTemplate).then((function(renderPv) {
            var protoViews = $__0._protoViewFactory.createAppProtoViews(componentBinding, renderPv, boundDirectives);
            return $__0._compileNestedProtoViews(protoViews, component, componentPath);
          })).then((function(appProtoView) {
            $__0._compilerCache.set(component, appProtoView);
            MapWrapper.delete($__0._compiling, component);
            return appProtoView;
          }));
          this._compiling.set(component, resultPromise);
          return resultPromise;
        },
        _removeDuplicatedDirectives: function(directives) {
          var directivesMap = new Map();
          directives.forEach((function(dirBinding) {
            directivesMap.set(dirBinding.key.id, dirBinding);
          }));
          return MapWrapper.values(directivesMap);
        },
        _compileNestedProtoViews: function(appProtoViews, componentType, componentPath) {
          var $__0 = this;
          var nestedPVPromises = [];
          componentPath = MapWrapper.clone(componentPath);
          if (appProtoViews[0].type === renderApi.ViewType.COMPONENT) {
            componentPath.set(componentType, appProtoViews[0]);
          }
          appProtoViews.forEach((function(appProtoView) {
            $__0._collectComponentElementBinders(appProtoView).forEach((function(elementBinder) {
              var nestedComponent = elementBinder.componentDirective;
              var nestedComponentType = nestedComponent.key.token;
              var elementBinderDone = (function(nestedPv) {
                elementBinder.nestedProtoView = nestedPv;
              });
              if (componentPath.has(nestedComponentType)) {
                if (appProtoView.isEmbeddedFragment) {
                  throw new BaseException(("<ng-content> is used within the recursive path of " + stringify(nestedComponentType)));
                } else if (appProtoView.type === renderApi.ViewType.COMPONENT) {
                  throw new BaseException(("Unconditional component cycle in " + stringify(nestedComponentType)));
                } else {
                  elementBinderDone(componentPath.get(nestedComponentType));
                }
              } else {
                var nestedCall = $__0._compile(nestedComponent, componentPath);
                if (isPromise(nestedCall)) {
                  nestedPVPromises.push(nestedCall.then(elementBinderDone));
                } else {
                  elementBinderDone(nestedCall);
                }
              }
            }));
          }));
          return PromiseWrapper.all(nestedPVPromises).then((function(_) {
            return PromiseWrapper.all(appProtoViews.map((function(appProtoView) {
              return $__0._mergeProtoView(appProtoView);
            })));
          })).then((function(_) {
            return appProtoViews[0];
          }));
        },
        _mergeProtoView: function(appProtoView) {
          if (appProtoView.type !== renderApi.ViewType.HOST && appProtoView.type !== renderApi.ViewType.EMBEDDED) {
            return null;
          }
          return this._render.mergeProtoViewsRecursively(this._collectMergeRenderProtoViews(appProtoView)).then((function(mergeResult) {
            appProtoView.mergeMapping = new AppProtoViewMergeMapping(mergeResult);
          }));
        },
        _collectMergeRenderProtoViews: function(appProtoView) {
          var result = [appProtoView.render];
          for (var i = 0; i < appProtoView.elementBinders.length; i++) {
            var binder = appProtoView.elementBinders[i];
            if (isPresent(binder.nestedProtoView)) {
              if (binder.hasStaticComponent() || (binder.hasEmbeddedProtoView() && binder.nestedProtoView.isEmbeddedFragment)) {
                result.push(this._collectMergeRenderProtoViews(binder.nestedProtoView));
              } else {
                result.push(null);
              }
            }
          }
          return result;
        },
        _collectComponentElementBinders: function(appProtoView) {
          var componentElementBinders = [];
          appProtoView.elementBinders.forEach((function(elementBinder) {
            if (isPresent(elementBinder.componentDirective)) {
              componentElementBinders.push(elementBinder);
            }
          }));
          return componentElementBinders;
        },
        _buildRenderTemplate: function(component, view, directives) {
          var $__0 = this;
          var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
          var templateAbsUrl = null;
          var styleAbsUrls = null;
          if (isPresent(view.templateUrl)) {
            templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
          } else if (isPresent(view.template)) {
            templateAbsUrl = componentUrl;
          }
          if (isPresent(view.styleUrls)) {
            styleAbsUrls = ListWrapper.map(view.styleUrls, (function(url) {
              return $__0._urlResolver.resolve(componentUrl, url);
            }));
          }
          return new renderApi.ViewDefinition({
            componentId: stringify(component),
            templateAbsUrl: templateAbsUrl,
            template: view.template,
            styleAbsUrls: styleAbsUrls,
            styles: view.styles,
            directives: ListWrapper.map(directives, (function(directiveBinding) {
              return directiveBinding.metadata;
            })),
            encapsulation: view.encapsulation
          });
        },
        _flattenDirectives: function(template) {
          if (isBlank(template.directives))
            return [];
          var directives = [];
          this._flattenList(template.directives, directives);
          return directives;
        },
        _flattenList: function(tree, out) {
          for (var i = 0; i < tree.length; i++) {
            var item = resolveForwardRef(tree[i]);
            if (isArray(item)) {
              this._flattenList(item, out);
            } else {
              out.push(item);
            }
          }
        }
      }, {
        _isValidDirective: function(value) {
          return isPresent(value) && (value instanceof Type || value instanceof Binding);
        },
        _assertTypeIsComponent: function(directiveBinding) {
          if (directiveBinding.metadata.type !== renderApi.DirectiveMetadata.COMPONENT_TYPE) {
            throw new BaseException(("Could not load '" + stringify(directiveBinding.key.token) + "' because it is not a component."));
          }
        }
      }));
      $__export("Compiler", Compiler);
      $__export("Compiler", Compiler = __decorate([Injectable(), __metadata('design:paramtypes', [DirectiveResolver, CompilerCache, ViewResolver, ComponentUrlMapper, UrlResolver, renderApi.RenderCompiler, ProtoViewFactory, AppRootUrl])], Compiler));
    }
  };
});

System.register("angular2/src/core/application_common", ["angular2/di", "angular2/src/facade/lang", "angular2/src/dom/browser_adapter", "angular2/src/dom/dom_adapter", "angular2/src/core/compiler/compiler", "angular2/src/reflection/reflection", "angular2/src/change_detection/change_detection", "angular2/src/core/exception_handler", "angular2/src/render/dom/compiler/view_loader", "angular2/src/render/dom/compiler/style_url_resolver", "angular2/src/render/dom/compiler/style_inliner", "angular2/src/core/compiler/view_resolver", "angular2/src/core/compiler/directive_resolver", "angular2/src/facade/collection", "angular2/src/facade/async", "angular2/src/core/zone/ng_zone", "angular2/src/core/life_cycle/life_cycle", "angular2/src/render/xhr", "angular2/src/render/xhr_impl", "angular2/src/render/dom/events/event_manager", "angular2/src/render/dom/events/key_events", "angular2/src/render/dom/events/hammer_gestures", "angular2/src/core/compiler/component_url_mapper", "angular2/src/services/url_resolver", "angular2/src/services/app_root_url", "angular2/src/services/anchor_based_app_root_url", "angular2/src/core/compiler/dynamic_component_loader", "angular2/src/core/testability/testability", "angular2/src/core/compiler/view_pool", "angular2/src/core/compiler/view_manager", "angular2/src/core/compiler/view_manager_utils", "angular2/src/core/compiler/view_listener", "angular2/src/core/compiler/proto_view_factory", "angular2/src/render/api", "angular2/src/render/render", "angular2/src/render/dom/view/shared_styles_host", "angular2/src/core/compiler/view_ref", "angular2/src/core/application_tokens"], function($__export) {
  "use strict";
  var __moduleName = "angular2/src/core/application_common";
  var Injector,
      bind,
      isBlank,
      isPresent,
      assertionsEnabled,
      isDart,
      BrowserDomAdapter,
      DOM,
      Compiler,
      CompilerCache,
      Reflector,
      reflector,
      Parser,
      Lexer,
      ChangeDetection,
      DynamicChangeDetection,
      JitChangeDetection,
      PreGeneratedChangeDetection,
      Pipes,
      defaultPipes,
      ExceptionHandler,
      ViewLoader,
      StyleUrlResolver,
      StyleInliner,
      ViewResolver,
      DirectiveResolver,
      ListWrapper,
      PromiseWrapper,
      NgZone,
      LifeCycle,
      XHR,
      XHRImpl,
      EventManager,
      DomEventsPlugin,
      KeyEventsPlugin,
      HammerGesturesPlugin,
      ComponentUrlMapper,
      UrlResolver,
      AppRootUrl,
      AnchorBasedAppRootUrl,
      DynamicComponentLoader,
      TestabilityRegistry,
      Testability,
      AppViewPool,
      APP_VIEW_POOL_CAPACITY,
      AppViewManager,
      AppViewManagerUtils,
      AppViewListener,
      ProtoViewFactory,
      Renderer,
      RenderCompiler,
      DomRenderer,
      DOCUMENT_TOKEN,
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES,
      DefaultDomCompiler,
      APP_ID_RANDOM_BINDING,
      SharedStylesHost,
      DomSharedStylesHost,
      internalView,
      appComponentRefPromiseToken,
      appComponentTypeToken,
      _rootInjector,
      _rootBindings,
      ApplicationRef;
  function _injectorBindings(appComponentType) {
    var bestChangeDetection = DynamicChangeDetection;
    if (PreGeneratedChangeDetection.isSupported()) {
      bestChangeDetection = PreGeneratedChangeDetection;
    } else if (JitChangeDetection.isSupported()) {
      bestChangeDetection = JitChangeDetection;
    }
    return [bind(DOCUMENT_TOKEN).toValue(DOM.defaultDoc()), bind(DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES).toValue(false), bind(appComponentTypeToken).toValue(appComponentType), bind(appComponentRefPromiseToken).toFactory((function(dynamicComponentLoader, injector, testability, registry) {
      return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector).then((function(componentRef) {
        registry.registerApplication(componentRef.location.nativeElement, testability);
        return componentRef;
      }));
    }), [DynamicComponentLoader, Injector, Testability, TestabilityRegistry]), bind(appComponentType).toFactory((function(p) {
      return p.then((function(ref) {
        return ref.instance;
      }));
    }), [appComponentRefPromiseToken]), bind(LifeCycle).toFactory((function(exceptionHandler) {
      return new LifeCycle(null, assertionsEnabled());
    }), [ExceptionHandler]), bind(EventManager).toFactory((function(ngZone) {
      var plugins = [new HammerGesturesPlugin(), new KeyEventsPlugin(), new DomEventsPlugin()];
      return new EventManager(plugins, ngZone);
    }), [NgZone]), DomRenderer, bind(Renderer).toAlias(DomRenderer), APP_ID_RANDOM_BINDING, DefaultDomCompiler, bind(RenderCompiler).toAlias(DefaultDomCompiler), DomSharedStylesHost, bind(SharedStylesHost).toAlias(DomSharedStylesHost), ProtoViewFactory, AppViewPool, bind(APP_VIEW_POOL_CAPACITY).toValue(10000), AppViewManager, AppViewManagerUtils, AppViewListener, Compiler, CompilerCache, ViewResolver, bind(Pipes).toValue(defaultPipes), bind(ChangeDetection).toClass(bestChangeDetection), ViewLoader, DirectiveResolver, Parser, Lexer, bind(ExceptionHandler).toFactory((function() {
      return new ExceptionHandler(DOM, isDart ? false : true);
    }), []), bind(XHR).toValue(new XHRImpl()), ComponentUrlMapper, UrlResolver, StyleUrlResolver, StyleInliner, DynamicComponentLoader, Testability, AnchorBasedAppRootUrl, bind(AppRootUrl).toAlias(AnchorBasedAppRootUrl)];
  }
  function createNgZone(handler) {
    var bootstrapErrorReporter = (function(exception, stackTrace) {
      return handler.call(exception, stackTrace);
    });
    var zone = new NgZone({enableLongStackTrace: assertionsEnabled()});
    zone.overrideOnErrorHandler(bootstrapErrorReporter);
    return zone;
  }
  function commonBootstrap(appComponentType) {
    var componentInjectableBindings = arguments[1] !== (void 0) ? arguments[1] : null;
    BrowserDomAdapter.makeCurrent();
    var bootstrapProcess = PromiseWrapper.completer();
    var zone = createNgZone(new ExceptionHandler(DOM, isDart ? false : true));
    zone.run((function() {
      var appInjector = _createAppInjector(appComponentType, componentInjectableBindings, zone);
      var exceptionHandler = appInjector.get(ExceptionHandler);
      zone.overrideOnErrorHandler((function(e, s) {
        return exceptionHandler.call(e, s);
      }));
      try {
        var compRefToken = appInjector.get(appComponentRefPromiseToken);
        var tick = (function(componentRef) {
          var appChangeDetector = internalView(componentRef.hostView).changeDetector;
          var lc = appInjector.get(LifeCycle);
          lc.registerWith(zone, appChangeDetector);
          lc.tick();
          bootstrapProcess.resolve(new ApplicationRef(componentRef, appComponentType, appInjector));
        });
        var tickResult = PromiseWrapper.then(compRefToken, tick);
        PromiseWrapper.then(tickResult, (function(_) {}));
        PromiseWrapper.then(tickResult, null, (function(err, stackTrace) {
          bootstrapProcess.reject(err, stackTrace);
        }));
      } catch (e) {
        bootstrapProcess.reject(e, e.stack);
      }
    }));
    return bootstrapProcess.promise;
  }
  function _createAppInjector(appComponentType, bindings, zone) {
    if (isBlank(_rootInjector))
      _rootInjector = Injector.resolveAndCreate(_rootBindings);
    var mergedBindings = isPresent(bindings) ? ListWrapper.concat(_injectorBindings(appComponentType), bindings) : _injectorBindings(appComponentType);
    mergedBindings.push(bind(NgZone).toValue(zone));
    return _rootInjector.resolveAndCreateChild(mergedBindings);
  }
  $__export("createNgZone", createNgZone);
  $__export("commonBootstrap", commonBootstrap);
  return {
    setters: [function($__m) {
      Injector = $__m.Injector;
      bind = $__m.bind;
    }, function($__m) {
      isBlank = $__m.isBlank;
      isPresent = $__m.isPresent;
      assertionsEnabled = $__m.assertionsEnabled;
      isDart = $__m.isDart;
    }, function($__m) {
      BrowserDomAdapter = $__m.BrowserDomAdapter;
    }, function($__m) {
      DOM = $__m.DOM;
    }, function($__m) {
      Compiler = $__m.Compiler;
      CompilerCache = $__m.CompilerCache;
    }, function($__m) {
      Reflector = $__m.Reflector;
      reflector = $__m.reflector;
    }, function($__m) {
      Parser = $__m.Parser;
      Lexer = $__m.Lexer;
      ChangeDetection = $__m.ChangeDetection;
      DynamicChangeDetection = $__m.DynamicChangeDetection;
      JitChangeDetection = $__m.JitChangeDetection;
      PreGeneratedChangeDetection = $__m.PreGeneratedChangeDetection;
      Pipes = $__m.Pipes;
      defaultPipes = $__m.defaultPipes;
    }, function($__m) {
      ExceptionHandler = $__m.ExceptionHandler;
    }, function($__m) {
      ViewLoader = $__m.ViewLoader;
    }, function($__m) {
      StyleUrlResolver = $__m.StyleUrlResolver;
    }, function($__m) {
      StyleInliner = $__m.StyleInliner;
    }, function($__m) {
      ViewResolver = $__m.ViewResolver;
    }, function($__m) {
      DirectiveResolver = $__m.DirectiveResolver;
    }, function($__m) {
      ListWrapper = $__m.ListWrapper;
    }, function($__m) {
      PromiseWrapper = $__m.PromiseWrapper;
    }, function($__m) {
      NgZone = $__m.NgZone;
    }, function($__m) {
      LifeCycle = $__m.LifeCycle;
    }, function($__m) {
      XHR = $__m.XHR;
    }, function($__m) {
      XHRImpl = $__m.XHRImpl;
    }, function($__m) {
      EventManager = $__m.EventManager;
      DomEventsPlugin = $__m.DomEventsPlugin;
    }, function($__m) {
      KeyEventsPlugin = $__m.KeyEventsPlugin;
    }, function($__m) {
      HammerGesturesPlugin = $__m.HammerGesturesPlugin;
    }, function($__m) {
      ComponentUrlMapper = $__m.ComponentUrlMapper;
    }, function($__m) {
      UrlResolver = $__m.UrlResolver;
    }, function($__m) {
      AppRootUrl = $__m.AppRootUrl;
    }, function($__m) {
      AnchorBasedAppRootUrl = $__m.AnchorBasedAppRootUrl;
    }, function($__m) {
      DynamicComponentLoader = $__m.DynamicComponentLoader;
    }, function($__m) {
      TestabilityRegistry = $__m.TestabilityRegistry;
      Testability = $__m.Testability;
    }, function($__m) {
      AppViewPool = $__m.AppViewPool;
      APP_VIEW_POOL_CAPACITY = $__m.APP_VIEW_POOL_CAPACITY;
    }, function($__m) {
      AppViewManager = $__m.AppViewManager;
    }, function($__m) {
      AppViewManagerUtils = $__m.AppViewManagerUtils;
    }, function($__m) {
      AppViewListener = $__m.AppViewListener;
    }, function($__m) {
      ProtoViewFactory = $__m.ProtoViewFactory;
    }, function($__m) {
      Renderer = $__m.Renderer;
      RenderCompiler = $__m.RenderCompiler;
    }, function($__m) {
      DomRenderer = $__m.DomRenderer;
      DOCUMENT_TOKEN = $__m.DOCUMENT_TOKEN;
      DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES = $__m.DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES;
      DefaultDomCompiler = $__m.DefaultDomCompiler;
      APP_ID_RANDOM_BINDING = $__m.APP_ID_RANDOM_BINDING;
    }, function($__m) {
      SharedStylesHost = $__m.SharedStylesHost;
      DomSharedStylesHost = $__m.DomSharedStylesHost;
    }, function($__m) {
      internalView = $__m.internalView;
    }, function($__m) {
      appComponentRefPromiseToken = $__m.appComponentRefPromiseToken;
      appComponentTypeToken = $__m.appComponentTypeToken;
    }],
    execute: function() {
      _rootBindings = [bind(Reflector).toValue(reflector), TestabilityRegistry];
      ApplicationRef = (function() {
        function ApplicationRef(hostComponent, hostComponentType, injector) {
          this._hostComponent = hostComponent;
          this._injector = injector;
          this._hostComponentType = hostComponentType;
        }
        return ($traceurRuntime.createClass)(ApplicationRef, {
          get hostComponentType() {
            return this._hostComponentType;
          },
          get hostComponent() {
            return this._hostComponent.instance;
          },
          dispose: function() {
            this._hostComponent.dispose();
          },
          get injector() {
            return this._injector;
          }
        }, {});
      }());
      $__export("ApplicationRef", ApplicationRef);
    }
  };
});

System.register("angular2/angular2", ["angular2/src/core/application_common", "angular2/annotations", "angular2/change_detection", "angular2/core", "angular2/di", "angular2/directives", "angular2/http", "angular2/forms", "angular2/render"], function($__export) {
  "use strict";
  var __moduleName = "angular2/angular2";
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  var $__exportNames = {undefined: true};
  return {
    setters: [function($__m) {
      $__export("bootstrap", $__m.commonBootstrap);
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }, function($__m) {
      Object.keys($__m).forEach(function(p) {
        if (!$__exportNames[p])
          $__export(p, $__m[p]);
      });
    }],
    execute: function() {}
  };
});

//# sourceMappingURLDisabled=angular2.dev.js.map
System.config({"paths":{"*":"*.js","angular2/*":"angular2/*"}});

System.register('ionic/components', ['ionic/components/app/app', 'ionic/components/action-menu/action-menu', 'ionic/components/aside/aside', 'ionic/components/button/button', 'ionic/components/card/card', 'ionic/components/checkbox/checkbox', 'ionic/components/content/content', 'ionic/components/icon/icon', 'ionic/components/item/item', 'ionic/components/item/item-group', 'ionic/components/form/input', 'ionic/components/form/text-input', 'ionic/components/form/tap-input', 'ionic/components/form/label', 'ionic/components/list/list', 'ionic/components/show-hide-when/show-hide-when', 'ionic/components/material/button', 'ionic/components/material/ripple', 'ionic/components/modal/modal', 'ionic/components/nav/nav', 'ionic/components/nav/nav-controller', 'ionic/components/nav/nav-push', 'ionic/components/nav-bar/nav-bar', 'ionic/components/popup/popup', 'ionic/components/slides/slides', 'ionic/components/radio/radio', 'ionic/components/scroll/scroll', 'ionic/components/scroll/pull-to-refresh', 'ionic/components/search-bar/search-bar', 'ionic/components/segment/segment', 'ionic/components/switch/switch', 'ionic/components/tabs/tabs', 'ionic/components/tabs/tab', 'ionic/components/toolbar/toolbar'], function (_export) {
  'use strict';

  // Material components/effects
  return {
    setters: [function (_ionicComponentsAppApp) {
      for (var _key in _ionicComponentsAppApp) {
        _export(_key, _ionicComponentsAppApp[_key]);
      }
    }, function (_ionicComponentsActionMenuActionMenu) {
      for (var _key2 in _ionicComponentsActionMenuActionMenu) {
        _export(_key2, _ionicComponentsActionMenuActionMenu[_key2]);
      }
    }, function (_ionicComponentsAsideAside) {
      for (var _key3 in _ionicComponentsAsideAside) {
        _export(_key3, _ionicComponentsAsideAside[_key3]);
      }
    }, function (_ionicComponentsButtonButton) {
      for (var _key4 in _ionicComponentsButtonButton) {
        _export(_key4, _ionicComponentsButtonButton[_key4]);
      }
    }, function (_ionicComponentsCardCard) {
      for (var _key5 in _ionicComponentsCardCard) {
        _export(_key5, _ionicComponentsCardCard[_key5]);
      }
    }, function (_ionicComponentsCheckboxCheckbox) {
      for (var _key6 in _ionicComponentsCheckboxCheckbox) {
        _export(_key6, _ionicComponentsCheckboxCheckbox[_key6]);
      }
    }, function (_ionicComponentsContentContent) {
      for (var _key7 in _ionicComponentsContentContent) {
        _export(_key7, _ionicComponentsContentContent[_key7]);
      }
    }, function (_ionicComponentsIconIcon) {
      for (var _key8 in _ionicComponentsIconIcon) {
        _export(_key8, _ionicComponentsIconIcon[_key8]);
      }
    }, function (_ionicComponentsItemItem) {
      for (var _key9 in _ionicComponentsItemItem) {
        _export(_key9, _ionicComponentsItemItem[_key9]);
      }
    }, function (_ionicComponentsItemItemGroup) {
      for (var _key10 in _ionicComponentsItemItemGroup) {
        _export(_key10, _ionicComponentsItemItemGroup[_key10]);
      }
    }, function (_ionicComponentsFormInput) {
      for (var _key11 in _ionicComponentsFormInput) {
        _export(_key11, _ionicComponentsFormInput[_key11]);
      }
    }, function (_ionicComponentsFormTextInput) {
      for (var _key12 in _ionicComponentsFormTextInput) {
        _export(_key12, _ionicComponentsFormTextInput[_key12]);
      }
    }, function (_ionicComponentsFormTapInput) {
      for (var _key13 in _ionicComponentsFormTapInput) {
        _export(_key13, _ionicComponentsFormTapInput[_key13]);
      }
    }, function (_ionicComponentsFormLabel) {
      for (var _key14 in _ionicComponentsFormLabel) {
        _export(_key14, _ionicComponentsFormLabel[_key14]);
      }
    }, function (_ionicComponentsListList) {
      for (var _key15 in _ionicComponentsListList) {
        _export(_key15, _ionicComponentsListList[_key15]);
      }
    }, function (_ionicComponentsShowHideWhenShowHideWhen) {
      for (var _key16 in _ionicComponentsShowHideWhenShowHideWhen) {
        _export(_key16, _ionicComponentsShowHideWhenShowHideWhen[_key16]);
      }
    }, function (_ionicComponentsMaterialButton) {
      for (var _key17 in _ionicComponentsMaterialButton) {
        _export(_key17, _ionicComponentsMaterialButton[_key17]);
      }
    }, function (_ionicComponentsMaterialRipple) {
      for (var _key18 in _ionicComponentsMaterialRipple) {
        _export(_key18, _ionicComponentsMaterialRipple[_key18]);
      }
    }, function (_ionicComponentsModalModal) {
      for (var _key19 in _ionicComponentsModalModal) {
        _export(_key19, _ionicComponentsModalModal[_key19]);
      }
    }, function (_ionicComponentsNavNav) {
      for (var _key20 in _ionicComponentsNavNav) {
        _export(_key20, _ionicComponentsNavNav[_key20]);
      }
    }, function (_ionicComponentsNavNavController) {
      for (var _key21 in _ionicComponentsNavNavController) {
        _export(_key21, _ionicComponentsNavNavController[_key21]);
      }
    }, function (_ionicComponentsNavNavPush) {
      for (var _key22 in _ionicComponentsNavNavPush) {
        _export(_key22, _ionicComponentsNavNavPush[_key22]);
      }
    }, function (_ionicComponentsNavBarNavBar) {
      for (var _key23 in _ionicComponentsNavBarNavBar) {
        _export(_key23, _ionicComponentsNavBarNavBar[_key23]);
      }
    }, function (_ionicComponentsPopupPopup) {
      for (var _key24 in _ionicComponentsPopupPopup) {
        _export(_key24, _ionicComponentsPopupPopup[_key24]);
      }
    }, function (_ionicComponentsSlidesSlides) {
      for (var _key25 in _ionicComponentsSlidesSlides) {
        _export(_key25, _ionicComponentsSlidesSlides[_key25]);
      }
    }, function (_ionicComponentsRadioRadio) {
      for (var _key26 in _ionicComponentsRadioRadio) {
        _export(_key26, _ionicComponentsRadioRadio[_key26]);
      }
    }, function (_ionicComponentsScrollScroll) {
      for (var _key27 in _ionicComponentsScrollScroll) {
        _export(_key27, _ionicComponentsScrollScroll[_key27]);
      }
    }, function (_ionicComponentsScrollPullToRefresh) {
      for (var _key28 in _ionicComponentsScrollPullToRefresh) {
        _export(_key28, _ionicComponentsScrollPullToRefresh[_key28]);
      }
    }, function (_ionicComponentsSearchBarSearchBar) {
      for (var _key29 in _ionicComponentsSearchBarSearchBar) {
        _export(_key29, _ionicComponentsSearchBarSearchBar[_key29]);
      }
    }, function (_ionicComponentsSegmentSegment) {
      for (var _key30 in _ionicComponentsSegmentSegment) {
        _export(_key30, _ionicComponentsSegmentSegment[_key30]);
      }
    }, function (_ionicComponentsSwitchSwitch) {
      for (var _key31 in _ionicComponentsSwitchSwitch) {
        _export(_key31, _ionicComponentsSwitchSwitch[_key31]);
      }
    }, function (_ionicComponentsTabsTabs) {
      for (var _key32 in _ionicComponentsTabsTabs) {
        _export(_key32, _ionicComponentsTabsTabs[_key32]);
      }
    }, function (_ionicComponentsTabsTab) {
      for (var _key33 in _ionicComponentsTabsTab) {
        _export(_key33, _ionicComponentsTabsTab[_key33]);
      }
    }, function (_ionicComponentsToolbarToolbar) {
      for (var _key34 in _ionicComponentsToolbarToolbar) {
        _export(_key34, _ionicComponentsToolbarToolbar[_key34]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/index", [], function (_export) {
  "use strict";

  return {
    setters: [],
    execute: function () {}
  };
});
/*
 * export everything here
 */
System.register('ionic/ionic', ['ionic/config/config', 'ionic/config/annotations', 'ionic/net/http', 'ionic/registry', 'ionic/components', 'ionic/platform/platform', 'ionic/platform/registry', 'ionic/routing/router', 'ionic/routing/url-state', 'ionic/util/click-block', 'ionic/util/focus', 'ionic/animations/animation', 'ionic/animations/builtins', 'ionic/transitions/transition', 'ionic/transitions/ios-transition', 'ionic/transitions/md-transition'], function (_export) {
  'use strict';

  return {
    setters: [function (_ionicConfigConfig) {
      for (var _key in _ionicConfigConfig) {
        _export(_key, _ionicConfigConfig[_key]);
      }
    }, function (_ionicConfigAnnotations) {
      for (var _key2 in _ionicConfigAnnotations) {
        _export(_key2, _ionicConfigAnnotations[_key2]);
      }
    }, function (_ionicNetHttp) {
      for (var _key3 in _ionicNetHttp) {
        _export(_key3, _ionicNetHttp[_key3]);
      }
    }, function (_ionicRegistry) {
      for (var _key4 in _ionicRegistry) {
        _export(_key4, _ionicRegistry[_key4]);
      }
    }, function (_ionicComponents) {
      for (var _key5 in _ionicComponents) {
        _export(_key5, _ionicComponents[_key5]);
      }
    }, function (_ionicPlatformPlatform) {
      for (var _key6 in _ionicPlatformPlatform) {
        _export(_key6, _ionicPlatformPlatform[_key6]);
      }
    }, function (_ionicPlatformRegistry) {
      for (var _key7 in _ionicPlatformRegistry) {
        _export(_key7, _ionicPlatformRegistry[_key7]);
      }
    }, function (_ionicRoutingRouter) {
      for (var _key8 in _ionicRoutingRouter) {
        _export(_key8, _ionicRoutingRouter[_key8]);
      }
    }, function (_ionicRoutingUrlState) {
      for (var _key9 in _ionicRoutingUrlState) {
        _export(_key9, _ionicRoutingUrlState[_key9]);
      }
    }, function (_ionicUtilClickBlock) {
      for (var _key10 in _ionicUtilClickBlock) {
        _export(_key10, _ionicUtilClickBlock[_key10]);
      }
    }, function (_ionicUtilFocus) {
      for (var _key11 in _ionicUtilFocus) {
        _export(_key11, _ionicUtilFocus[_key11]);
      }
    }, function (_ionicAnimationsAnimation) {
      for (var _key12 in _ionicAnimationsAnimation) {
        _export(_key12, _ionicAnimationsAnimation[_key12]);
      }
    }, function (_ionicAnimationsBuiltins) {
      for (var _key13 in _ionicAnimationsBuiltins) {
        _export(_key13, _ionicAnimationsBuiltins[_key13]);
      }
    }, function (_ionicTransitionsTransition) {
      for (var _key14 in _ionicTransitionsTransition) {
        _export(_key14, _ionicTransitionsTransition[_key14]);
      }
    }, function (_ionicTransitionsIosTransition) {
      for (var _key15 in _ionicTransitionsIosTransition) {
        _export(_key15, _ionicTransitionsIosTransition[_key15]);
      }
    }, function (_ionicTransitionsMdTransition) {
      for (var _key16 in _ionicTransitionsMdTransition) {
        _export(_key16, _ionicTransitionsMdTransition[_key16]);
      }
    }],
    execute: function () {}
  };
});
System.register("ionic/registry", ["angular2/angular2", "ionic/ionic"], function (_export) {
    "use strict";

    var Directive, IonicApp, __decorate, __metadata, Register;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_ionicIonic) {
            IonicApp = _ionicIonic.IonicApp;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Register = (function () {
                var _class = function Register(app) {
                    _classCallCheck(this, _class);

                    this.app = app;
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.register && this.registerId) {
                            this.app.register(this.registerId, this.register);
                        }
                    }
                }]);

                return _class;
            })();

            _export("Register", Register);

            _export("Register", Register = __decorate([Directive({
                selector: "[register]",
                properties: ["register", "registerId: register-id"],
                host: {
                    "this.register-id": "registerId"
                }
            }), __metadata("design:paramtypes", [typeof IonicApp !== "undefined" && IonicApp || Object])], Register));
        }
    };
});
System.register('ionic/util', ['ionic/util/dom', 'ionic/util/util'], function (_export) {
  'use strict';

  var domUtil, dom;
  return {
    setters: [function (_ionicUtilDom) {
      domUtil = _ionicUtilDom;
    }, function (_ionicUtilUtil) {
      for (var _key in _ionicUtilUtil) {
        _export(_key, _ionicUtilUtil[_key]);
      }
    }],
    execute: function () {
      dom = domUtil;

      _export('dom', dom);
    }
  };
});
System.register('ionic/components/ion', ['ionic/util'], function (_export) {
    'use strict';

    var util, Ion;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            /**
             * Base class for all Ionic components. Exposes some common functionality
             * that all Ionic components need, such as accessing underlying native elements and
             * sending/receiving app-level events.
             */

            Ion = (function () {
                function Ion(elementRef, config) {
                    _classCallCheck(this, Ion);

                    this.elementRef = elementRef;
                    this.config = config;
                    this.clsMode = config.setting('mode');
                }

                _createClass(Ion, [{
                    key: 'onInit',
                    value: function onInit() {
                        var cls = this.constructor;
                        if (cls.defaultProperties && this.config) {
                            for (var prop in cls.defaultProperties) {
                                // Priority:
                                // ---------
                                // 1) Value set from within constructor
                                // 2) Value set from the host element's attribute
                                // 3) Value set by the users global config
                                // 4) Value set by the default mode/platform config
                                // 5) Value set from the component's default
                                if (this[prop]) {
                                    // this property has already been set on the instance
                                    // could be from the user setting the element's attribute
                                    // or from the user setting it within the constructor
                                    continue;
                                }
                                // get the property values from a global user/platform config
                                var configVal = this.config.setting(prop);
                                if (configVal) {
                                    this[prop] = configVal;
                                    continue;
                                }
                                // wasn't set yet, so go with property's default value
                                this[prop] = cls.defaultProperties[prop];
                            }
                        }
                        this.onIonInit && this.onIonInit();
                    }
                }, {
                    key: 'getDelegate',
                    value: function getDelegate(delegateName) {
                        var cls = this.constructor;
                        if (cls.delegates) {
                            var cases = cls.delegates[delegateName] || [];
                            for (var i = 0; i < cases.length; i++) {
                                var delegateCase = cases[i];
                                if (util.isArray(delegateCase)) {
                                    var _delegateCase = _slicedToArray(delegateCase, 2);

                                    var check = _delegateCase[0];
                                    var DelegateConstructor = _delegateCase[1];

                                    if (check(this)) {
                                        return new DelegateConstructor(this);
                                    }
                                } else {
                                    return new delegateCase(this);
                                }
                            }
                        }
                    }
                }, {
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this.elementRef;
                    }
                }, {
                    key: 'getNativeElement',
                    value: function getNativeElement() {
                        return this.elementRef.nativeElement;
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        return this.getNativeElement().offsetWidth;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        return this.getNativeElement().offsetHeight;
                    }
                }]);

                return Ion;
            })();

            _export('Ion', Ion);
        }
    };
});
System.register('ionic/animations/animation', ['../util/dom'], function (_export) {
    'use strict';

    var CSS, RENDER_DELAY, AnimationRegistry, Animation, Animate, TRANSFORMS, ANIMATE_PROPERTIES, CUBIC_BEZIERS, EASING_FN;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertEffects(effects, fromEffect, toEffect, easingConfig) {
        easingConfig.opts = easingConfig.opts || {};
        var increment = easingConfig.opts.increment || 0.04;
        var easingFn = EASING_FN[easingConfig.name];
        var pos = undefined,
            tweenEffect = undefined,
            addEffect = undefined,
            property = undefined,
            toProperty = undefined,
            fromValue = undefined,
            diffValue = undefined;
        for (pos = increment; pos <= 1 - increment; pos += increment) {
            tweenEffect = {};
            addEffect = false;
            for (property in toEffect) {
                toProperty = toEffect[property];
                if (toProperty.tween) {
                    fromValue = fromEffect[property].num;
                    diffValue = toProperty.num - fromValue;
                    tweenEffect[property] = {
                        value: roundValue(easingFn(pos, easingConfig.opts) * diffValue + fromValue) + toProperty.unit
                    };
                    addEffect = true;
                }
            }
            if (addEffect) {
                effects.push(convertProperties(tweenEffect));
            }
        }
    }
    function parseEffect(inputEffect) {
        var val = undefined,
            r = undefined,
            num = undefined,
            property = undefined;
        var outputEffect = {};
        for (property in inputEffect) {
            val = inputEffect[property];
            r = val.toString().match(/(\d*\.?\d*)(.*)/);
            num = parseFloat(r[1]);
            outputEffect[property] = {
                value: val,
                num: num,
                unit: r[0] != r[2] ? r[2] : '',
                tween: !isNaN(num) && ANIMATE_PROPERTIES.indexOf(property) > -1
            };
        }
        return outputEffect;
    }
    function convertProperties(inputEffect) {
        var outputEffect = {};
        var transforms = [];
        var value = undefined,
            property = undefined;
        for (property in inputEffect) {
            value = inputEffect[property].value;
            if (TRANSFORMS.indexOf(property) > -1) {
                transforms.push(property + '(' + value + ')');
            } else {
                outputEffect[property] = value;
            }
        }
        if (transforms.length) {
            transforms.push('translateZ(0px)');
            outputEffect.transform = transforms.join(' ');
        }
        return outputEffect;
    }
    function inlineStyle(ele, effect) {
        if (ele && effect) {
            var transforms = [];
            var value = undefined,
                property = undefined;
            for (property in effect) {
                value = effect[property].value;
                if (TRANSFORMS.indexOf(property) > -1) {
                    transforms.push(property + '(' + value + ')');
                } else {
                    ele.style[property] = value;
                }
            }
            if (transforms.length) {
                transforms.push('translateZ(0px)');
                ele.style[CSS.transform] = transforms.join(' ');
            }
        }
    }
    function roundValue(val) {
        return Math.round(val * 10000) / 10000;
    }
    return {
        setters: [function (_utilDom) {
            CSS = _utilDom.CSS;
        }],
        execute: function () {
            RENDER_DELAY = 36;
            AnimationRegistry = {};

            /**
              Animation Steps/Process
              -----------------------
              1) Construct animation (doesn't start)
              2) Client play()'s animation, returns promise
              3) Add before classes to elements
              4) Remove before classes from elements
              5) Elements staged in "from" effect w/ inline styles
              6) Call onReady()
              7) Wait for RENDER_DELAY milliseconds (give browser time to render)
              8) Call onPlay()
              8) Run from/to animation on elements
              9) Animations finish async
             10) Set inline styles w/ the "to" effects on elements
             11) Add after classes to elements
             12) Remove after classes from elements
             13) Call onFinish()
             14) Resolve play()'s promise
            **/

            Animation = (function () {
                function Animation(ele) {
                    _classCallCheck(this, Animation);

                    this._el = [];
                    this._chld = [];
                    this._ani = [];
                    this._bfAdd = [];
                    this._bfSty = {};
                    this._bfRmv = [];
                    this._afAdd = [];
                    this._afRmv = [];
                    this._readys = [];
                    this._plays = [];
                    this._finishes = [];
                    this.elements(ele);
                }

                _createClass(Animation, [{
                    key: 'elements',
                    value: function elements(ele) {
                        if (ele) {
                            if (typeof ele === 'string') {
                                // string query selector
                                ele = document.querySelectorAll(ele);
                            }
                            if (ele.length) {
                                // array of elements
                                for (var i = 0; i < ele.length; i++) {
                                    this.addElement(ele[i]);
                                }
                            } else {
                                // single element
                                this.addElement(ele);
                            }
                        }
                        return this;
                    }
                }, {
                    key: 'addElement',
                    value: function addElement(ele) {
                        // ensure only HTML Element nodes
                        if (ele) {
                            if (ele.nativeElement) {
                                // angular ElementRef
                                ele = ele.nativeElement;
                            }
                            if (ele.nodeType === 1) {
                                this._el.push(ele);
                            }
                        }
                    }
                }, {
                    key: 'parent',
                    value: function parent(parentAnimation) {
                        this._parent = parentAnimation;
                        return this;
                    }
                }, {
                    key: 'add',
                    value: function add(childAnimations) {
                        childAnimations = Array.isArray(childAnimations) ? childAnimations : arguments;
                        for (var i = 0; i < childAnimations.length; i++) {
                            childAnimations[i].parent(this);
                            this._chld.push(childAnimations[i]);
                        }
                        return this;
                    }
                }, {
                    key: 'duration',
                    value: function duration(value) {
                        if (arguments.length) {
                            this._duration = value;
                            return this;
                        }
                        return this._duration || this._parent && this._parent.duration();
                    }
                }, {
                    key: 'easing',
                    value: function easing(name, opts) {
                        if (arguments.length) {
                            this._easing = {
                                name: name,
                                opts: opts
                            };
                            return this;
                        }
                        return this._easing || this._parent && this._parent.easing();
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        if (arguments.length) {
                            this._rate = value;
                            var i = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i].playbackRate(value);
                            }
                            for (i = 0; i < this._ani.length; i++) {
                                this._ani[i].playbackRate(value);
                            }
                            return this;
                        }
                        return this._rate || this._parent && this._parent.playbackRate();
                    }
                }, {
                    key: 'from',
                    value: function from(property, value) {
                        if (!this._from) {
                            this._from = {};
                        }
                        this._from[property] = value;
                        return this;
                    }
                }, {
                    key: 'to',
                    value: function to(property, value) {
                        if (!this._to) {
                            this._to = {};
                        }
                        this._to[property] = value;
                        return this;
                    }
                }, {
                    key: 'fromTo',
                    value: function fromTo(property, from, to) {
                        return this.from(property, from).to(property, to);
                    }
                }, {
                    key: 'fadeIn',
                    value: function fadeIn() {
                        return this.fromTo('opacity', 0, 1);
                    }
                }, {
                    key: 'fadeOut',
                    value: function fadeOut() {
                        return this.fromTo('opacity', 1, 0);
                    }
                }, {
                    key: 'play',
                    value: function play() {
                        var _this = this;

                        var self = this;
                        var animations = self._ani;
                        var children = self._chld;
                        var promises = [];
                        var i = undefined,
                            l = undefined;
                        // the actual play() method which may or may not start async
                        function beginPlay() {
                            var i = undefined,
                                l = undefined;
                            var promises = [];
                            for (i = 0, l = children.length; i < l; i++) {
                                promises.push(children[i].play());
                            }
                            for (i = 0, l = animations.length; i < l; i++) {
                                promises.push(animations[i].play());
                            }
                            return Promise.all(promises);
                        }
                        if (!self._parent) {
                            var _ret = (function () {
                                var kickoff = function kickoff() {
                                    // synchronously call all onPlay()'s before play()
                                    self._onPlay();
                                    beginPlay().then(function () {
                                        self._onFinish();
                                        resolve();
                                    });
                                };

                                // this is the top level animation and is in full control
                                // of when the async play() should actually kick off
                                // stage all animations and child animations at their starting point
                                self.stage();
                                var resolve = undefined;
                                var promise = new Promise(function (res) {
                                    resolve = res;
                                });

                                if (_this._duration > RENDER_DELAY) {
                                    // begin each animation when everything is rendered in their starting point
                                    // give the browser some time to render everything in place before starting
                                    setTimeout(kickoff, RENDER_DELAY);
                                } else {
                                    // no need to render everything in there place before animating in
                                    // just kick it off immediately to render them in their "to" locations
                                    kickoff();
                                }
                                return {
                                    v: promise
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        }
                        // this is a child animation, it is told exactly when to
                        // start by the top level animation
                        return beginPlay();
                    }
                }, {
                    key: 'stage',
                    value: function stage() {
                        // before the RENDER_DELAY
                        // before the animations have started
                        if (!this._isStaged) {
                            this._isStaged = true;
                            var i = undefined,
                                p = undefined,
                                l = undefined,
                                j = undefined,
                                ele = undefined,
                                animation = undefined;
                            for (i = 0, l = this._chld.length; i < l; i++) {
                                this._chld[i].stage();
                            }
                            for (i = 0; i < this._el.length; i++) {
                                ele = this._el[i];
                                for (j = 0; j < this._bfAdd.length; j++) {
                                    ele.classList.add(this._bfAdd[j]);
                                }
                                for (p in this._bfSty) {
                                    ele.style[p] = this._bfSty[p];
                                }
                                for (j = 0; j < this._bfRmv.length; j++) {
                                    ele.classList.remove(this._bfRmv[j]);
                                }
                            }
                            if (this._to) {
                                // only animate the elements if there are defined "to" effects
                                for (i = 0; i < this._el.length; i++) {
                                    animation = new Animate(this._el[i], this._from, this._to, this.duration(), this.easing(), this.playbackRate());
                                    if (animation.shouldAnimate) {
                                        this._ani.push(animation);
                                    }
                                }
                            }
                            for (i = 0; i < this._readys.length; i++) {
                                this._readys[i](this);
                            }
                        }
                    }
                }, {
                    key: '_onPlay',
                    value: function _onPlay() {
                        // after the RENDER_DELAY
                        // before the animations have started
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i]._onPlay();
                        }
                        for (i = 0; i < this._plays.length; i++) {
                            this._plays[i](this);
                        }
                    }
                }, {
                    key: '_onFinish',
                    value: function _onFinish() {
                        // after the animations have finished
                        if (!this._isFinished) {
                            this._isFinished = true;
                            var i = undefined,
                                j = undefined,
                                ele = undefined;
                            for (i = 0; i < this._chld.length; i++) {
                                this._chld[i]._onFinish();
                            }
                            if (this.playbackRate() < 0) {
                                // reverse direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._bfAdd.length; j++) {
                                        ele.classList.remove(this._bfAdd[j]);
                                    }
                                    for (j = 0; j < this._bfRmv.length; j++) {
                                        ele.classList.add(this._bfRmv[j]);
                                    }
                                }
                            } else {
                                // normal direction
                                for (i = 0; i < this._el.length; i++) {
                                    ele = this._el[i];
                                    for (j = 0; j < this._afAdd.length; j++) {
                                        ele.classList.add(this._afAdd[j]);
                                    }
                                    for (j = 0; j < this._afRmv.length; j++) {
                                        ele.classList.remove(this._afRmv[j]);
                                    }
                                }
                            }
                            for (i = 0; i < this._finishes.length; i++) {
                                this._finishes[i](this);
                            }
                        }
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this._hasFinished = false;
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].pause();
                        }
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].progress(value);
                        }
                        if (!this._initProgress) {
                            this._initProgress = true;
                            this.play();
                            this.pause();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].progress(value);
                        }
                    }
                }, {
                    key: 'onReady',
                    value: function onReady(fn) {
                        this._readys.push(fn);
                    }
                }, {
                    key: 'onPlay',
                    value: function onPlay(fn) {
                        this._plays.push(fn);
                    }
                }, {
                    key: 'onFinish',
                    value: function onFinish(fn) {
                        this._finishes.push(fn);
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        var i = undefined;
                        for (i = 0; i < this._chld.length; i++) {
                            this._chld[i].dispose();
                        }
                        for (i = 0; i < this._ani.length; i++) {
                            this._ani[i].dispose();
                        }
                        this._el = this._parent = this._chld = this._ani = this._readys = this._plays = this._finishes = null;
                    }
                }, {
                    key: 'before',
                    get: function get() {
                        var _this2 = this;

                        return {
                            addClass: function addClass(className) {
                                _this2._bfAdd.push(className);
                                return _this2;
                            },
                            removeClass: function removeClass(className) {
                                _this2._bfRmv.push(className);
                                return _this2;
                            },
                            setStyles: function setStyles(styles) {
                                _this2._bfSty = styles;
                            }
                        };
                    }
                }, {
                    key: 'after',
                    get: function get() {
                        var _this3 = this;

                        return {
                            addClass: function addClass(className) {
                                _this3._afAdd.push(className);
                                return _this3;
                            },
                            removeClass: function removeClass(className) {
                                _this3._afRmv.push(className);
                                return _this3;
                            }
                        };
                    }
                }], [{
                    key: 'create',

                    /*
                     STATIC CLASSES
                     */
                    value: function create(element, name) {
                        var AnimationClass = AnimationRegistry[name];
                        if (!AnimationClass) {
                            // couldn't find an animation by the given name
                            // fallback to just the base Animation class
                            AnimationClass = Animation;
                        }
                        return new AnimationClass(element);
                    }
                }, {
                    key: 'register',
                    value: function register(name, AnimationClass) {
                        AnimationRegistry[name] = AnimationClass;
                    }
                }]);

                return Animation;
            })();

            _export('Animation', Animation);

            Animate = (function () {
                function Animate(ele, fromEffect, toEffect, duration, easingConfig, playbackRate) {
                    var _this4 = this;

                    _classCallCheck(this, Animate);

                    // https://w3c.github.io/web-animations/
                    // not using the direct API methods because they're still in flux
                    // however, element.animate() seems locked in and uses the latest
                    // and correct API methods under the hood, so really doesn't matter
                    this.toEffect = parseEffect(toEffect);
                    this.shouldAnimate = duration > RENDER_DELAY;
                    if (!this.shouldAnimate) {
                        return inlineStyle(ele, this.toEffect);
                    }
                    this.ele = ele;
                    this.promise = new Promise(function (res) {
                        _this4.resolve = res;
                    });
                    // stage where the element will start from
                    fromEffect = parseEffect(fromEffect);
                    inlineStyle(ele, fromEffect);
                    this.duration = duration;
                    this.rate = playbackRate;
                    this.easing = easingConfig && easingConfig.name || 'linear';
                    this.effects = [convertProperties(fromEffect)];
                    if (this.easing in EASING_FN) {
                        insertEffects(this.effects, fromEffect, this.toEffect, easingConfig);
                    } else if (this.easing in CUBIC_BEZIERS) {
                        this.easing = 'cubic-bezier(' + CUBIC_BEZIERS[this.easing] + ')';
                    }
                    this.effects.push(convertProperties(this.toEffect));
                }

                _createClass(Animate, [{
                    key: 'play',
                    value: function play() {
                        var self = this;
                        if (self.player) {
                            self.player.play();
                        } else {
                            self.player = self.ele.animate(self.effects, {
                                duration: self.duration || 0,
                                easing: self.easing,
                                playbackRate: self.rate || 1
                            });
                            self.player.onfinish = function () {
                                // lock in where the element will stop at
                                // if the playbackRate is negative then it needs to return
                                // to its "from" effects
                                inlineStyle(self.ele, self.rate < 0 ? self.fromEffect : self.toEffect);
                                self.resolve();
                            };
                        }
                        return self.promise;
                    }
                }, {
                    key: 'pause',
                    value: function pause() {
                        this.player && this.player.pause();
                    }
                }, {
                    key: 'progress',
                    value: function progress(value) {
                        var player = this.player;
                        if (player) {
                            // passed a number between 0 and 1
                            value = Math.max(0, Math.min(1, value));
                            if (value >= 1) {
                                player.currentTime = this.duration * 0.999;
                                return player.play();
                            }
                            if (player.playState !== 'paused') {
                                player.pause();
                            }
                            player.currentTime = this.duration * value;
                        }
                    }
                }, {
                    key: 'playbackRate',
                    value: function playbackRate(value) {
                        this.rate = value;
                        if (this.player) {
                            this.player.playbackRate = value;
                        }
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.ele = this.player = this.effects = this.toEffect = null;
                    }
                }]);

                return Animate;
            })();

            TRANSFORMS = ['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'perspective'];
            ANIMATE_PROPERTIES = TRANSFORMS.concat('opacity');

            // Robert Penner's Easing Functions
            // http://robertpenner.com/easing/
            CUBIC_BEZIERS = {
                // default browser suppored easing
                // ease
                // ease-in
                // ease-out
                // ease-in-out
                // Cubic
                'ease-in-cubic': '0.55,0.055,0.675,0.19',
                'ease-out-cubic': '0.215,0.61,0.355,1',
                'ease-in-Out-cubic': '0.645,0.045,0.355,1',
                // Circ
                'ease-in-circ': '0.6,0.04,0.98,0.335',
                'ease-out-circ': '0.075,0.82,0.165,1',
                'ease-in-out-circ': '0.785,0.135,0.15,0.86',
                // Expo
                'ease-in-expo': '0.95,0.05,0.795,0.035',
                'ease-out-expo': '0.19,1,0.22,1',
                'ease-in-out-expo': '1,0,0,1',
                // Quad
                'ease-in-quad': '0.55,0.085,0.68,0.53',
                'ease-out-quad': '0.25,0.46,0.45,0.94',
                'ease-in-out-quad': '0.455,0.03,0.515,0.955',
                // Quart
                'ease-in-quart': '0.895,0.03,0.685,0.22',
                'ease-out-quart': '0.165,0.84,0.44,1',
                'ease-in-out-quart': '0.77,0,0.175,1',
                // Quint
                'ease-in-quint': '0.755,0.05,0.855,0.06',
                'ease-out-quint': '0.23,1,0.32,1',
                'ease-in-out-quint': '0.86,0,0.07,1',
                // Sine
                'ease-in-sine': '0.47,0,0.745,0.715',
                'ease-out-sine': '0.39,0.575,0.565,1',
                'ease-in-out-sine': '0.445,0.05,0.55,0.95',
                // Back
                'ease-in-back': '0.6,-0.28,0.735,0.045',
                'ease-out-back': '0.175,0.885,0.32,1.275',
                'ease-in-out-back': '0.68,-0.55,0.265,1.55'
            };
            EASING_FN = {
                'elastic': function elastic(pos) {
                    return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
                },
                'swing-from-to': function swingFromTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
                },
                'swing-from': function swingFrom(pos, opts) {
                    var s = opts.s || 1.70158;
                    return pos * pos * ((s + 1) * pos - s);
                },
                'swing-to': function swingTo(pos, opts) {
                    var s = opts.s || 1.70158;
                    return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
                },
                'bounce': function bounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'bounce-past': function bouncePast(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
                    } else if (pos < 2.5 / 2.75) {
                        return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
                    }
                    return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
                },
                'ease-out-bounce': function easeOutBounce(pos) {
                    if (pos < 1 / 2.75) {
                        return 7.5625 * pos * pos;
                    } else if (pos < 2 / 2.75) {
                        return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
                    } else if (pos < 2.5 / 2.75) {
                        return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
                    }
                    return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
                },
                'ease-from-to': function easeFromTo(pos) {
                    if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 4);
                    return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
                },
                'ease-from': function easeFrom(pos, opts) {
                    return Math.pow(pos, opts.s || 4);
                },
                'ease-to': function easeTo(pos, opts) {
                    return Math.pow(pos, opts.s || 0.25);
                },
                /*
                 * scripty2, Thomas Fuchs (MIT Licence)
                 * https://raw.github.com/madrobby/scripty2/master/src/effects/transitions/transitions.js
                 */
                'spring': function spring(pos, opts) {
                    var damping = opts.damping || 4.5;
                    var elasticity = opts.elasticity || 6;
                    return 1 - Math.cos(pos * damping * Math.PI) * Math.exp(-pos * elasticity);
                },
                'sinusoidal': function sinusoidal(pos) {
                    return -Math.cos(pos * Math.PI) / 2 + 0.5;
                }
            };
        }
    };
});
System.register('ionic/animations/builtins', ['./animation'], function (_export) {
    'use strict';

    var Animation, SlideIn, SlideOut, FadeIn, FadeOut;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_animation) {
            Animation = _animation.Animation;
        }],
        execute: function () {
            SlideIn = (function (_Animation) {
                function SlideIn(element) {
                    _classCallCheck(this, SlideIn);

                    _get(Object.getPrototypeOf(SlideIn.prototype), 'constructor', this).call(this, element);
                    this.easing('cubic-bezier(0.1,0.7,0.1,1)').duration(400).fromTo('translateY', '100%', '0%');
                }

                _inherits(SlideIn, _Animation);

                return SlideIn;
            })(Animation);

            Animation.register('slide-in', SlideIn);

            SlideOut = (function (_Animation2) {
                function SlideOut(element) {
                    _classCallCheck(this, SlideOut);

                    _get(Object.getPrototypeOf(SlideOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fromTo('translateY', '0%', '100%');
                }

                _inherits(SlideOut, _Animation2);

                return SlideOut;
            })(Animation);

            Animation.register('slide-out', SlideOut);

            FadeIn = (function (_Animation3) {
                function FadeIn(element) {
                    _classCallCheck(this, FadeIn);

                    _get(Object.getPrototypeOf(FadeIn.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-in').duration(400).fadeIn();
                }

                _inherits(FadeIn, _Animation3);

                return FadeIn;
            })(Animation);

            Animation.register('fade-in', FadeIn);

            FadeOut = (function (_Animation4) {
                function FadeOut(element) {
                    _classCallCheck(this, FadeOut);

                    _get(Object.getPrototypeOf(FadeOut.prototype), 'constructor', this).call(this, element);
                    this.easing('ease-out').duration(250).fadeOut();
                }

                _inherits(FadeOut, _Animation4);

                return FadeOut;
            })(Animation);

            Animation.register('fade-out', FadeOut);
        }
    };
});
System.register('ionic/animations/scroll-to', ['../util/dom'], function (_export) {
    'use strict';

    var raf, ScrollTo;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilDom) {
            raf = _utilDom.raf;
        }],
        execute: function () {
            ScrollTo = (function () {
                function ScrollTo(ele, x, y, duration) {
                    _classCallCheck(this, ScrollTo);

                    if (typeof ele === 'string') {
                        // string query selector
                        ele = document.querySelector(ele);
                    }
                    if (ele) {
                        if (ele.nativeElement) {
                            // angular ElementRef
                            ele = ele.nativeElement;
                        }
                        if (ele.nodeType === 1) {
                            this._el = ele;
                        }
                    }
                }

                _createClass(ScrollTo, [{
                    key: 'start',
                    value: function start(x, y, duration, tolerance) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var self = this;
                        if (!self._el) {
                            // invalid element
                            return Promise.resolve();
                        }
                        x = x || 0;
                        y = y || 0;
                        tolerance = tolerance || 0;
                        var ele = self._el;
                        var fromY = ele.scrollTop;
                        var fromX = ele.scrollLeft;
                        var xDistance = Math.abs(x - fromX);
                        var yDistance = Math.abs(y - fromY);
                        if (yDistance <= tolerance && xDistance <= tolerance) {
                            // prevent scrolling if already close to there
                            this._el = ele = null;
                            return Promise.resolve();
                        }
                        return new Promise(function (resolve, reject) {
                            var start = Date.now();
                            // start scroll loop
                            self.isPlaying = true;
                            raf(step);
                            // decelerating to zero velocity
                            function easeOutCubic(t) {
                                return --t * t * t + 1;
                            }
                            // scroll loop
                            function step() {
                                var time = Math.min(1, (Date.now() - start) / duration);
                                // where .5 would be 50% of time on a linear scale easedT gives a
                                // fraction based on the easing method
                                var easedT = easeOutCubic(time);
                                if (fromY != y) {
                                    ele.scrollTop = parseInt(easedT * (y - fromY) + fromY, 10);
                                }
                                if (fromX != x) {
                                    ele.scrollLeft = parseInt(easedT * (x - fromX) + fromX, 10);
                                }
                                if (time < 1 && self.isPlaying) {
                                    raf(step);
                                } else if (!self.isPlaying) {
                                    // stopped
                                    this._el = ele = null;
                                    reject();
                                } else {
                                    // done
                                    this._el = ele = null;
                                    resolve();
                                }
                            }
                        });
                    }
                }, {
                    key: 'stop',
                    value: function stop() {
                        this.isPlaying = false;
                    }
                }, {
                    key: 'dispose',
                    value: function dispose() {
                        this.stop();
                        this._el = null;
                    }
                }]);

                return ScrollTo;
            })();

            _export('ScrollTo', ScrollTo);
        }
    };
});
System.register('ionic/config/annotations', ['angular2/angular2', 'ionic/util', '../components/app/app', '../ionic'], function (_export) {
    'use strict';

    var coreDirectives, formDirectives, Component, Directive, View, forwardRef, util, ionicBootstrap, Aside, Button, Content, Scroll, Refresher, Slides, Slide, SlidePager, Tabs, Tab, Card, List, Item, ItemGroup, ItemGroupTitle, Toolbar, Icon, IconDirective, Checkbox, TapInput, Switch, Input, TextInput, Label, Segment, SegmentButton, SegmentControlValueAccessor, RadioGroup, RadioButton, Nav, NavbarTemplate, Navbar, NavPush, NavPop, TapClick, TapDisabled, Register, ShowWhen, HideWhen, MaterialButton, IonicDirectives, IonicViewImpl;

    var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    _export('IonicView', IonicView);

    _export('IonicDirective', IonicDirective);

    _export('IonicComponent', IonicComponent);

    _export('App', App);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function IonicView(args) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new IonicViewImpl(args));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicDirective(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Directive(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function IonicComponent(config) {
        return function (cls) {
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            annotations.push(new Component(appendConfig(cls, config)));
            Reflect.defineMetadata('annotations', annotations, cls);
            return cls;
        };
    }

    function appendConfig(cls, config) {
        config.host = config.host || {};
        cls.defaultProperties = config.defaultProperties || {};
        config.properties = config.properties || [];
        for (var prop in cls.defaultProperties) {
            // add the property to the component "properties"
            config.properties.push(prop);
            // set the component "hostProperties", so the instance's
            // property value will be used to set the element's attribute
            config.host['[attr.' + util.pascalCaseToDashCase(prop) + ']'] = prop;
        }
        cls.delegates = config.delegates;
        var componentId = config.classId || config.selector && config.selector.replace('ion-', '');
        config.host['class'] = ((config.host['class'] || '') + ' ' + componentId).trim();
        // the mode will get figured out when the component is constructed
        config.host['[attr.mode]'] = 'clsMode';
        return config;
    }

    function App() {
        var args = arguments[0] === undefined ? {} : arguments[0];

        return function (cls) {
            // get current annotations
            var annotations = Reflect.getMetadata('annotations', cls) || [];
            // create @Component
            args.selector = args.selector || 'ion-app';
            annotations.push(new Component(args));
            // create @View
            // if no template was provided, default so it has a root ion-nav
            if (!args.templateUrl && !args.template) {
                args.template = '<ion-nav></ion-nav>';
            }
            annotations.push(new IonicViewImpl(args));
            // redefine with added annotations
            Reflect.defineMetadata('annotations', annotations, cls);
            ionicBootstrap(cls, args.config, args.routes);
            return cls;
        };
    }

    return {
        setters: [function (_angular2Angular2) {
            coreDirectives = _angular2Angular2.coreDirectives;
            formDirectives = _angular2Angular2.formDirectives;
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_componentsAppApp) {
            ionicBootstrap = _componentsAppApp.ionicBootstrap;
        }, function (_ionic) {
            Aside = _ionic.Aside;
            Button = _ionic.Button;
            Content = _ionic.Content;
            Scroll = _ionic.Scroll;
            Refresher = _ionic.Refresher;
            Slides = _ionic.Slides;
            Slide = _ionic.Slide;
            SlidePager = _ionic.SlidePager;
            Tabs = _ionic.Tabs;
            Tab = _ionic.Tab;
            Card = _ionic.Card;
            List = _ionic.List;
            Item = _ionic.Item;
            ItemGroup = _ionic.ItemGroup;
            ItemGroupTitle = _ionic.ItemGroupTitle;
            Toolbar = _ionic.Toolbar;
            Icon = _ionic.Icon;
            IconDirective = _ionic.IconDirective;
            Checkbox = _ionic.Checkbox;
            TapInput = _ionic.TapInput;
            Switch = _ionic.Switch;
            Input = _ionic.Input;
            TextInput = _ionic.TextInput;
            Label = _ionic.Label;
            Segment = _ionic.Segment;
            SegmentButton = _ionic.SegmentButton;
            SegmentControlValueAccessor = _ionic.SegmentControlValueAccessor;
            RadioGroup = _ionic.RadioGroup;
            RadioButton = _ionic.RadioButton;
            Nav = _ionic.Nav;
            NavbarTemplate = _ionic.NavbarTemplate;
            Navbar = _ionic.Navbar;
            NavPush = _ionic.NavPush;
            NavPop = _ionic.NavPop;
            TapClick = _ionic.TapClick;
            TapDisabled = _ionic.TapDisabled;
            Register = _ionic.Register;
            ShowWhen = _ionic.ShowWhen;
            HideWhen = _ionic.HideWhen;
            MaterialButton = _ionic.MaterialButton;
        }],
        execute: function () {
            // TODO: Why is forwardRef() required when they're already imported above????
            IonicDirectives = [
            // Angular
            coreDirectives, formDirectives,
            // Content
            forwardRef(function () {
                return Aside;
            }), forwardRef(function () {
                return Button;
            }), forwardRef(function () {
                return Content;
            }), forwardRef(function () {
                return Scroll;
            }), forwardRef(function () {
                return Refresher;
            }),
            // Lists
            forwardRef(function () {
                return Card;
            }), forwardRef(function () {
                return List;
            }), forwardRef(function () {
                return Item;
            }), forwardRef(function () {
                return ItemGroup;
            }), forwardRef(function () {
                return ItemGroupTitle;
            }),
            // Slides
            forwardRef(function () {
                return Slides;
            }), forwardRef(function () {
                return Slide;
            }), forwardRef(function () {
                return SlidePager;
            }),
            // Tabs
            forwardRef(function () {
                return Tabs;
            }), forwardRef(function () {
                return Tab;
            }), forwardRef(function () {
                return Toolbar;
            }),
            // Media
            forwardRef(function () {
                return Icon;
            }), forwardRef(function () {
                return IconDirective;
            }),
            // Form
            forwardRef(function () {
                return Segment;
            }), forwardRef(function () {
                return SegmentButton;
            }), forwardRef(function () {
                return SegmentControlValueAccessor;
            }), forwardRef(function () {
                return Checkbox;
            }), forwardRef(function () {
                return RadioGroup;
            }), forwardRef(function () {
                return RadioButton;
            }), forwardRef(function () {
                return Switch;
            }),
            //SearchBar,
            // Input
            forwardRef(function () {
                return Input;
            }), forwardRef(function () {
                return TextInput;
            }), forwardRef(function () {
                return TapInput;
            }), forwardRef(function () {
                return Label;
            }),
            // Nav
            forwardRef(function () {
                return Nav;
            }), forwardRef(function () {
                return NavbarTemplate;
            }), forwardRef(function () {
                return Navbar;
            }), forwardRef(function () {
                return NavPush;
            }), forwardRef(function () {
                return NavPop;
            }), forwardRef(function () {
                return Register;
            }), forwardRef(function () {
                return ShowWhen;
            }), forwardRef(function () {
                return HideWhen;
            }),
            // Gestures
            forwardRef(function () {
                return TapClick;
            }), forwardRef(function () {
                return TapDisabled;
            }),
            // Material
            forwardRef(function () {
                return MaterialButton;
            })];

            _export('IonicDirectives', IonicDirectives);

            IonicViewImpl = (function (_View) {
                function IonicViewImpl() {
                    var args = arguments[0] === undefined ? {} : arguments[0];

                    _classCallCheck(this, IonicViewImpl);

                    args.directives = (args.directives || []).concat(IonicDirectives);
                    _get(Object.getPrototypeOf(IonicViewImpl.prototype), 'constructor', this).call(this, args);
                }

                _inherits(IonicViewImpl, _View);

                return IonicViewImpl;
            })(View);
        }
    };
});
System.register('ionic/config/config', ['../util/util'], function (_export) {
    'use strict';

    var isObject, isDefined, isFunction, extend, IonicConfig, globalConfig;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            isObject = _utilUtil.isObject;
            isDefined = _utilUtil.isDefined;
            isFunction = _utilUtil.isFunction;
            extend = _utilUtil.extend;
        }],
        execute: function () {
            /**
            * This is the Ionic Config
            * @usage this is what you do to use it
            */

            IonicConfig = (function () {
                function IonicConfig(settings) {
                    _classCallCheck(this, IonicConfig);

                    // defaults
                    this._settings = {};
                    // override defaults w/ user config
                    if (settings) {
                        extend(this._settings, settings);
                    }
                }

                _createClass(IonicConfig, [{
                    key: 'setting',

                    /**
                    * @description The settings description
                    */
                    value: function setting() {
                        var args = arguments;
                        var arg0 = args[0];
                        var arg1 = args[1];
                        var settings = this._settings;
                        switch (args.length) {
                            case 0:
                                // setting() = get settings object
                                return settings;
                            case 1:
                                // setting({...}) = set settings object
                                // setting('key') = get value
                                if (isObject(arg0)) {
                                    // setting({...}) = set settings object
                                    // arg0 = setting object
                                    this._settings = arg0;
                                    return this;
                                }
                                // time for the big show, get the value
                                // setting('key') = get value
                                // arg0 = key
                                if (!isDefined(settings[arg0])) {
                                    // if the value was already set this will all be skipped
                                    // if there was no user config then it'll check each of
                                    // the user config's platforms, which already contains
                                    // settings from default platform configs
                                    settings[arg0] = null;
                                    // check the platform settings object for this value
                                    // loop though each of the active platforms
                                    var activePlatformKeys = this._platforms;
                                    var platformSettings = settings.platforms;
                                    var platformObj = null;
                                    if (platformSettings) {
                                        var platformValue = undefined;
                                        for (var i = 0; i < activePlatformKeys.length; i++) {
                                            platformObj = platformSettings[activePlatformKeys[i]];
                                            if (platformObj && isDefined(platformObj[arg0])) {
                                                platformValue = platformObj[arg0];
                                            }
                                        }
                                        if (isDefined(platformValue)) {
                                            settings[arg0] = platformValue;
                                        }
                                    }
                                }
                                // return key's value
                                // either it came directly from the user config
                                // or it was from the users platform configs
                                // or it was from the default platform configs
                                // in that order
                                if (isFunction(settings[arg0])) {
                                    settings[arg0] = settings[arg0]();
                                }
                                return settings[arg0];
                            case 2:
                                // setting('ios', {...}) = set platform config object
                                // setting('key', 'value') = set key/value pair
                                if (isObject(arg1)) {
                                    // setting('ios', {...}) = set platform config object
                                    // arg0 = platform
                                    // arg1 = platform config object
                                    settings.platforms = settings.platforms || {};
                                    settings.platforms[arg0] = arg1;
                                } else {
                                    // setting('key', 'value') = set key/value pair
                                    // arg0 = key
                                    // arg1 = value
                                    settings[arg0] = arg1;
                                }
                                return this;
                            case 3:
                                // setting('ios', 'key', 'value') = set key/value pair for platform
                                // arg0 = platform
                                // arg1 = key
                                // arg2 = value
                                settings.platforms = settings.platforms || {};
                                settings.platforms[arg0] = settings.platforms[arg0] || {};
                                settings.platforms[arg0][arg1] = args[2];
                                return this;
                        }
                    }
                }, {
                    key: 'setPlatform',

                    /**
                     * The setPlatform description
                     */
                    value: function setPlatform(platform) {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        this._platforms = platform.platforms();
                        // copy default platform settings into the user config platform settings
                        // user config platform settings should override default platform settings
                        this._settings.platforms = extend(platform.settings(), this._settings.platforms || {});
                    }
                }], [{
                    key: 'global',
                    set: function set(config) {
                        globalConfig = config;
                    },
                    get: function get() {
                        return globalConfig;
                    }
                }]);

                return IonicConfig;
            })();

            _export('IonicConfig', IonicConfig);

            globalConfig = null;
        }
    };
});
System.register('ionic/gestures/drag-gesture', ['ionic/gestures/gesture', 'ionic/util'], function (_export) {
    'use strict';

    var Gesture, util, DragGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            //import Hammer from 'hammer';
            /*
             * BUG(ajoslin): HammerJS 2.x does not have an alternative to HammerJS 1.x's
             * dragLockToAxis, so a vertical and horizontal gesture can happen at the same time.
             */

            DragGesture = (function (_Gesture) {
                function DragGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, DragGesture);

                    util.defaults(opts, {});
                    _get(Object.getPrototypeOf(DragGesture.prototype), 'constructor', this).call(this, element, opts);
                }

                _inherits(DragGesture, _Gesture);

                _createClass(DragGesture, [{
                    key: 'listen',
                    value: function listen() {
                        var _this = this;

                        _get(Object.getPrototypeOf(DragGesture.prototype), 'listen', this).call(this);
                        this.on('panstart', function (ev) {
                            if (_this.onDragStart(ev) !== false) {
                                _this.dragging = true;
                            }
                            // ev.stopPropagation();
                        });
                        this.on('panmove', function (ev) {
                            if (!_this.dragging) return;
                            if (_this.onDrag(ev) === false) {
                                _this.dragging = false;
                            }
                            // ev.stopPropagation()
                        });
                        this.on('panend', function (ev) {
                            if (!_this.dragging) return;
                            _this.onDragEnd(ev);
                            _this.dragging = false;
                            // ev.stopPropagation()
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag() {}
                }, {
                    key: 'onDragStart',
                    value: function onDragStart() {}
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd() {}
                }]);

                return DragGesture;
            })(Gesture);

            _export('DragGesture', DragGesture);
        }
    };
});
System.register('ionic/gestures/gesture', ['ionic/util', 'ionic/gestures/hammer'], function (_export) {
    'use strict';

    var util, Hammer, Gesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicGesturesHammer) {
            Hammer = _ionicGesturesHammer.Hammer;
        }],
        execute: function () {
            Gesture = (function () {
                function Gesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, Gesture);

                    util.defaults(opts, {
                        domEvents: true
                    });
                    this.element = element;
                    // Map 'x' or 'y' string to hammerjs opts
                    this.direction = opts.direction || 'x';
                    opts.direction = this.direction === 'x' ? Hammer.DIRECTION_HORIZONTAL : Hammer.DIRECTION_VERTICAL;
                    this._options = opts;
                    this._callbacks = {};
                }

                _createClass(Gesture, [{
                    key: 'options',
                    value: function options() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        util.extend(this._options, opts);
                    }
                }, {
                    key: 'on',
                    value: function on(type, cb) {
                        this.hammertime.on(type, util.noop);
                        (this._callbacks[type] || (this._callbacks[type] = [])).push(cb);
                        this.element.addEventListener(type, cb);
                    }
                }, {
                    key: 'listen',
                    value: function listen() {
                        this.hammertime = Hammer(this.element, this._options);
                    }
                }, {
                    key: 'unlisten',
                    value: function unlisten() {
                        this.hammertime.destroy();
                        this.hammertime = null;
                        for (var type in this._callbacks) {
                            for (var i = 0; i < this._callbacks[type].length; i++) {
                                this.element.removeEventListener(type, this._callbacks[type][i]);
                            }
                        }
                        this._callbacks = {};
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unlisten();
                    }
                }]);

                return Gesture;
            })();

            _export('Gesture', Gesture);
        }
    };
});
System.register('ionic/gestures/hammer', [], function (_export) {
    /*! Hammer.JS - v2.0.4 - 2014-09-28
     * http://hammerjs.github.io/
     *
     * Copyright (c) 2014 Jorik Tangelder;
     * Licensed under the MIT license */
    //(function(window, document, exportName, undefined) {
    //'use strict';
    'use strict';

    var VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_NONE, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, MOUSE_INPUT_MAP, MOUSE_ELEMENT_EVENTS, MOUSE_WINDOW_EVENTS, POINTER_INPUT_MAP, IE10_POINTER_TYPE_ENUM, POINTER_ELEMENT_EVENTS, POINTER_WINDOW_EVENTS, SINGLE_TOUCH_INPUT_MAP, SINGLE_TOUCH_TARGET_EVENTS, SINGLE_TOUCH_WINDOW_EVENTS, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_ENDED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, STOP, FORCED_STOP;

    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }
    /**
     * if the argument is an array, we want to execute the fn on each entry
     * if it aint an array we don't want to do a thing.
     * this is used by all the methods that accept a single and array argument.
     * @param {*|Array} arg
     * @param {String} fn
     * @param {Object} [context]
     * @returns {Boolean}
     */
    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }
    /**
     * walk objects and arrays
     * @param {Object} obj
     * @param {Function} iterator
     * @param {Object} context
     */
    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }
    /**
     * extend object.
     * means that properties in dest will be overwritten by the ones in src.
     * @param {Object} dest
     * @param {Object} src
     * @param {Boolean} [merge]
     * @returns {Object} dest
     */
    function extend(dest, src, merge) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }
    /**
     * merge the values from src in the dest.
     * means that properties that exist in dest will not be overwritten by src
     * @param {Object} dest
     * @param {Object} src
     * @returns {Object} dest
     */
    function merge(dest, src) {
        return extend(dest, src, true);
    }
    /**
     * simple class inheritance
     * @param {Function} child
     * @param {Function} base
     * @param {Object} [properties]
     */
    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }
    /**
     * simple function bind
     * @param {Function} fn
     * @param {Object} context
     * @returns {Function}
     */
    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }
    /**
     * let a boolean value also be a function that must return a boolean
     * this first item in args will be used as the context
     * @param {Boolean|Function} val
     * @param {Array} [args]
     * @returns {Boolean}
     */
    function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
        }
        return val;
    }
    /**
     * use the val2 when val1 is undefined
     * @param {*} val1
     * @param {*} val2
     * @returns {*}
     */
    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }
    /**
     * addEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function addEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
        });
    }
    /**
     * removeEventListener with multiple events at once
     * @param {EventTarget} target
     * @param {String} types
     * @param {Function} handler
     */
    function removeEventListeners(target, types, handler) {
        each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
        });
    }
    /**
     * find if a node is in the given parent
     * @method hasParent
     * @param {HTMLElement} node
     * @param {HTMLElement} parent
     * @return {Boolean} found
     */
    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    /**
     * small indexOf wrapper
     * @param {String} str
     * @param {String} find
     * @returns {Boolean} found
     */
    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }
    /**
     * split string on whitespace
     * @param {String} str
     * @returns {Array} words
     */
    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }
    /**
     * find if a array contains the object using indexOf or a simple polyFill
     * @param {Array} src
     * @param {String} find
     * @param {String} [findByKey]
     * @return {Boolean|Number} false when not found, or the index
     */
    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }
    /**
     * convert array-like objects to real arrays
     * @param {Object} obj
     * @returns {Array}
     */
    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }
    /**
     * unique array with objects based on a key (like 'id') or just by the array's value
     * @param {Array} src [{id:1},{id:2},{id:1}]
     * @param {String} [key]
     * @param {Boolean} [sort=False]
     * @returns {Array} [{id:1},{id:2}]
     */
    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key];
                });
            }
        }
        return results;
    }
    /**
     * get the prefixed property
     * @param {Object} obj
     * @param {String} property
     * @returns {String|Undefined} prefixed
     */
    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    function uniqueId() {
        return _uniqueId++;
    }
    /**
     * get the window object of an element
     * @param {HTMLElement} element
     * @returns {DocumentView|Window}
     */
    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        return doc.defaultView || doc.parentWindow;
    }

    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input(manager, callback) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
                self.handler(ev);
            }
        };
        this.init();
    }

    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
            Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
        } else {
            Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
    }
    /**
     * handle input events
     * @param {Manager} manager
     * @param {String} eventType
     * @param {Object} input
     */
    function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
            manager.session = {};
        }
        // source event is the normalized value of the domEvents
        // like 'touchstart, mouseup, pointerdown'
        input.eventType = eventType;
        // compute scale, rotation etc
        computeInputData(manager, input);
        // emit secret event
        manager.emit('hammer.input', input);
        manager.recognize(input);
        manager.session.prevInput = input;
    }
    /**
     * extend the data with some usable properties like scale, rotate, velocity etc
     * @param {Object} manager
     * @param {Object} input
     */
    function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
        }
        // to compute scale and rotation we need to store the multiple touches
        if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        computeIntervalInputData(session, input);
        // find the correct target
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }
    function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
    }
    /**
     * velocity is calculated every x ms
     * @param {Object} session
     * @param {Object} input
     */
    function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input,
            deltaTime = input.timeStamp - last.timeStamp,
            velocity,
            velocityX,
            velocityY,
            direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = last.deltaX - input.deltaX;
            var deltaY = last.deltaY - input.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
        } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
    }
    /**
     * create a simple clone from the input used for storage of firstInput and firstMultiple
     * @param {Object} input
     * @returns {Object} clonedInputData
     */
    function simpleCloneInputData(input) {
        // make a simple copy of the pointers because we will get a reference if we don't
        // we only need clientXY for the calculations
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
            pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            };
            i++;
        }
        return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
        };
    }
    /**
     * get the center of all the pointers
     * @param {Array} pointers
     * @return {Object} center contains `x` and `y` properties
     */
    function getCenter(pointers) {
        var pointersLength = pointers.length;
        // no need to loop when only one touch
        if (pointersLength === 1) {
            return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
        }
        var x = 0,
            y = 0,
            i = 0;
        while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
        }
        return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
        };
    }
    /**
     * calculate the velocity between two points. unit is in px per ms.
     * @param {Number} deltaTime
     * @param {Number} x
     * @param {Number} y
     * @return {Object} velocity `x` and `y`
     */
    function getVelocity(deltaTime, x, y) {
        return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
        };
    }
    /**
     * get the direction between two points
     * @param {Number} x
     * @param {Number} y
     * @return {Number} direction
     */
    function getDirection(x, y) {
        if (x === y) {
            return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
            return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
    }
    /**
     * calculate the absolute distance between two points
     * @param {Object} p1 {x, y}
     * @param {Object} p2 {x, y}
     * @param {Array} [props] containing x and y keys
     * @return {Number} distance
     */
    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }
    /**
     * calculate the angle between two coordinates
     * @param {Object} p1
     * @param {Object} p2
     * @param {Array} [props] containing x and y keys
     * @return {Number} angle
     */
    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    /**
     * calculate the rotation degrees between two pointersets
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} rotation
     */
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    /**
     * calculate the scale factor between two pointersets
     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
     * @param {Array} start array of pointers
     * @param {Array} end array of pointers
     * @return {Number} scale
     */
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply(this, arguments);
    }

    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
    }

    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
        }
        return [all, changed];
    }

    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
    }

    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        // when there is only one touch, the process can be simplified
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(ev.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        // get target touches from touches
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        // collect touches
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        // filter changed touches to only contain touches that exist in the collected target ids
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            // cleanup removed touches
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }
    /**
     * Combined touch and mouse input
     *
     * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
     * This because touch devices also emit mouse events while doing a touch.
     *
     * @constructor
     * @extends Input
     */
    function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
    }

    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
    }

    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions(actions) {
        // none
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        // pan-x and pan-y can be combined
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        // pan-x OR pan-y
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        // manipulation
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }

    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer(options) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge(options || {}, this.defaults);
        // default is enable true
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }

    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_ENDED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }
    /**
     * direction cons to string
     * @param {Const} direction
     * @returns {String}
     */
    function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
            return 'down';
        } else if (direction == DIRECTION_UP) {
            return 'up';
        } else if (direction == DIRECTION_LEFT) {
            return 'left';
        } else if (direction == DIRECTION_RIGHT) {
            return 'right';
        }
        return '';
    }
    /**
     * get a recognizer by name if it is bound to a manager
     * @param {Recognizer|String} otherRecognizer
     * @param {Recognizer} recognizer
     * @returns {Recognizer}
     */
    function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
            return manager.get(otherRecognizer);
        }
        return otherRecognizer;
    }
    /**
     * This recognizer is just used as a base for the simple attribute recognizers.
     * @constructor
     * @extends Recognizer
     */
    function AttrRecognizer() {
        Recognizer.apply(this, arguments);
    }

    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
    }

    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
    }

    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
    }

    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply(this, arguments);
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }

    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager(element, options);
    }

    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager(element, options) {
        options = options || {};
        this.options = merge(options, Hammer.defaults);
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
        }, this);
    }

    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps(manager, add) {
        var element = manager.element;
        each(manager.options.cssProps, function (value, name) {
            element.style[prefixed(element.style, name)] = add ? value : '';
        });
    }
    /**
     * trigger dom event
     * @param {String} event
     * @param {Object} data
     */
    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
    }
    return {
        setters: [],
        execute: function () {
            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');
            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            /**
             * get a unique id
             * @returns {number} uniqueId
             */
            _uniqueId = 1;
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            INPUT_TYPE_TOUCH = 'touch';
            INPUT_TYPE_PEN = 'pen';
            INPUT_TYPE_MOUSE = 'mouse';
            INPUT_TYPE_KINECT = 'kinect';
            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;
            INPUT_MOVE = 2;
            INPUT_END = 4;
            INPUT_CANCEL = 8;
            DIRECTION_NONE = 1;
            DIRECTION_LEFT = 2;
            DIRECTION_RIGHT = 4;
            DIRECTION_UP = 8;
            DIRECTION_DOWN = 16;
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];
            Input.prototype = {
                /**
                 * should handle the inputEvent data and trigger the callback
                 * @virtual
                 */
                handler: function handler() {},
                /**
                 * bind the events
                 */
                init: function init() {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
                 * unbind the events
                 */
                destroy: function destroy() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            MOUSE_ELEMENT_EVENTS = 'mousedown';
            MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
            inherit(MouseInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    // on start we want to have the left mouse button down
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    // mouse must be down, and mouse events are allowed (see the TouchMouse input)
                    if (!this.pressed || !this.allow) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [ev],
                        changedPointers: [ev],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };

            // in IE10 the pointer types is defined as an enum
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
            };
            POINTER_ELEMENT_EVENTS = 'pointerdown';
            POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

            // IE10 has prefixed support, and case-sensitive
            if (window.MSPointerEvent) {
                POINTER_ELEMENT_EVENTS = 'MSPointerDown';
                POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
            }inherit(PointerEventInput, Input, {
                /**
                 * handle mouse events
                 * @param {Object} ev
                 */
                handler: function PEhandler(ev) {
                    var store = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    // get index of the event in the store
                    var storeIndex = inArray(store, ev.pointerId, 'pointerId');
                    // start and mouse must be down
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store.push(ev);
                            storeIndex = store.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (storeIndex < 0) {
                        return;
                    }
                    // update the event in the store
                    store[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store,
                        changedPointers: [ev],
                        pointerType: pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        // remove from the store
                        store.splice(storeIndex, 1);
                    }
                }
            });
            SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
            SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(SingleTouchInput, Input, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    // should we handle the touch events?
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    // when done, reset the started state
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
            inherit(TouchInput, Input, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });inherit(TouchMouseInput, Input, {
                /**
                 * handle mouse and touch events
                 * @param {Hammer} manager
                 * @param {String} inputEvent
                 * @param {Object} inputData
                 */
                handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    // when we're in a touch event, so  block all upcoming mouse events
                    // most mobile browser also emit mouseevents, right after touchstart
                    if (isTouch) {
                        this.mouse.allow = false;
                    } else if (isMouse && !this.mouse.allow) {
                        return;
                    }
                    // reset the allowMouse when we're done
                    if (inputEvent & (INPUT_END | INPUT_CANCEL)) {
                        this.mouse.allow = true;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
                 * remove the event listeners
                 */
                destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            // magical touchAction value
            TOUCH_ACTION_COMPUTE = 'compute';
            TOUCH_ACTION_AUTO = 'auto';
            TOUCH_ACTION_MANIPULATION = 'manipulation';
            // not implemented
            TOUCH_ACTION_NONE = 'none';
            TOUCH_ACTION_PAN_X = 'pan-x';
            TOUCH_ACTION_PAN_Y = 'pan-y';
            TouchAction.prototype = {
                /**
                 * set the touchAction value on the element or enable the polyfill
                 * @param {String} value
                 */
                set: function set(value) {
                    // find out the touch-action by the event handlers
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
                 * just re-set the touchAction value
                 */
                update: function update() {
                    this.set(this.manager.options.touchAction);
                },
                /**
                 * compute the value for the touchAction property based on the recognizer's settings
                 * @returns {String} value
                 */
                compute: function compute() {
                    var actions = [];
                    each(this.manager.recognizers, function (recognizer) {
                        if (boolOrFn(recognizer.options.enable, [recognizer])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(' '));
                },
                /**
                 * this method is called on each input cycle and provides the preventing of the browser behavior
                 * @param {Object} input
                 */
                preventDefaults: function preventDefaults(input) {
                    // not needed with native support for the touchAction property
                    if (NATIVE_TOUCH_ACTION) {
                        return;
                    }
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE);
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
                 * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
                 * @param {Object} srcEvent
                 */
                preventSrc: function preventSrc(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            }; /**
                * Recognizer flow explained; *
                * All recognizers have the initial state of POSSIBLE when a input session starts.
                * The definition of a input session is from the first input until the last input, with all it's movement in it. *
                * Example session for mouse-input: mousedown -> mousemove -> mouseup
                *
                * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
                * which determines with state it should be.
                *
                * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
                * POSSIBLE to give it another change on the next cycle.
                *
                *               Possible
                *                  |
                *            +-----+---------------+
                *            |                     |
                *      +-----+-----+               |
                *      |           |               |
                *   Failed      Cancelled          |
                *                          +-------+------+
                *                          |              |
                *                      Recognized       Began
                *                                         |
                *                                      Changed
                *                                         |
                *                                  Ended/Recognized
                */
            STATE_POSSIBLE = 1;
            STATE_BEGAN = 2;
            STATE_CHANGED = 4;
            STATE_ENDED = 8;
            STATE_RECOGNIZED = STATE_ENDED;
            STATE_CANCELLED = 16;
            STATE_FAILED = 32;
            Recognizer.prototype = {
                /**
                 * @virtual
                 * @type {Object}
                 */
                defaults: {},
                /**
                 * set options
                 * @param {Object} options
                 * @return {Recognizer}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
                 * recognize simultaneous with an other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                recognizeWith: function recognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
                 * drop the simultaneous link. it doesnt remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
                 * recognizer can only run when an other is failing
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                requireFailure: function requireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
                 * drop the requireFailure link. it does not remove the link on the other recognizer.
                 * @param {Recognizer} otherRecognizer
                 * @returns {Recognizer} this
                 */
                dropRequireFailure: function dropRequireFailure(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
                 * has require failures boolean
                 * @returns {boolean}
                 */
                hasRequireFailures: function hasRequireFailures() {
                    return this.requireFail.length > 0;
                },
                /**
                 * if the recognizer can recognize simultaneous with an other recognizer
                 * @param {Recognizer} otherRecognizer
                 * @returns {Boolean}
                 */
                canRecognizeWith: function canRecognizeWith(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
                 * You should use `tryEmit` instead of `emit` directly to check
                 * that all the needed recognizers has failed before emitting.
                 * @param {Object} input
                 */
                emit: function emit(input) {
                    var self = this;
                    var state = this.state;
                    function emit(withState) {
                        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);
                    }
                    // 'panstart' and 'panmove'
                    if (state < STATE_ENDED) {
                        emit(true);
                    }
                    emit(); // simple 'eventName' events
                    // panend and pancancel
                    if (state >= STATE_ENDED) {
                        emit(true);
                    }
                },
                /**
                 * Check that all the require failure recognizers has failed,
                 * if true, it emits a gesture event,
                 * otherwise, setup the state to FAILED.
                 * @param {Object} input
                 */
                tryEmit: function tryEmit(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    // it's failing anyway
                    this.state = STATE_FAILED;
                },
                /**
                 * can we emit?
                 * @returns {boolean}
                 */
                canEmit: function canEmit() {
                    var i = 0;
                    while (i < this.requireFail.length) {
                        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                },
                /**
                 * update the recognizer
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var inputDataClone = extend({}, inputData);
                    // is is enabled and allow recognizing?
                    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
                 * return the state of the recognizer
                 * the actual recognizing happens in this method
                 * @virtual
                 * @param {Object} inputData
                 * @returns {Const} STATE
                 */
                process: function process(inputData) {},
                /**
                 * return the preferred touch-action
                 * @virtual
                 * @returns {Array}
                 */
                getTouchAction: function getTouchAction() {},
                /**
                 * called when the gesture isn't allowed to recognize
                 * like when another is being recognized or it is disabled
                 * @virtual
                 */
                reset: function reset() {}
            };inherit(AttrRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof AttrRecognizer
                 */
                defaults: {
                    /**
                     * @type {Number}
                     * @default 1
                     */
                    pointers: 1
                },
                /**
                 * Used to check if it the recognizer receives valid input, like input.distance > 10.
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {Boolean} recognized
                 */
                attrTest: function attrTest(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
                 * Process the input and return the state for the recognizer
                 * @memberof AttrRecognizer
                 * @param {Object} input
                 * @returns {*} State
                 */
                process: function process(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });inherit(PanRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PanRecognizer
                 */
                defaults: {
                    event: 'pan',
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function getTouchAction() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function directionTest(input) {
                    var options = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    // lock to axis?
                    if (!(direction & options.direction)) {
                        if (options.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options.threshold && direction & options.direction;
                },
                attrTest: function attrTest(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function emit(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this._super.emit.call(this, input);
                }
            });inherit(PinchRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'pinch',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function emit(input) {
                    this._super.emit.call(this, input);
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? 'in' : 'out';
                        this.manager.emit(this.options.event + inOut, input);
                    }
                }
            });inherit(PressRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PressRecognizer
                 */
                defaults: {
                    event: 'press',
                    pointers: 1,
                    time: 500,
                    threshold: 5 // a minimal movement is ok, but keep it low
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_AUTO];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTime = input.deltaTime > options.time;
                    this._input = input;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + 'up', input);
                    } else {
                        this._input.timeStamp = now();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });inherit(RotateRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof RotateRecognizer
                 */
                defaults: {
                    event: 'rotate',
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_NONE];
                },
                attrTest: function attrTest(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });inherit(SwipeRecognizer, AttrRecognizer, {
                /**
                 * @namespace
                 * @memberof SwipeRecognizer
                 */
                defaults: {
                    event: 'swipe',
                    threshold: 10,
                    velocity: 0.65,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function getTouchAction() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function attrTest(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.velocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.velocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.velocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function emit(input) {
                    var direction = directionStr(input.direction);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });inherit(TapRecognizer, Recognizer, {
                /**
                 * @namespace
                 * @memberof PinchRecognizer
                 */
                defaults: {
                    event: 'tap',
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10 // a multi-tap can be a bit off the initial position
                },
                getTouchAction: function getTouchAction() {
                    return [TOUCH_ACTION_MANIPULATION];
                },
                process: function process(input) {
                    var options = this.options;
                    var validPointers = input.pointers.length === options.pointers;
                    var validMovement = input.distance < options.threshold;
                    var validTouchTime = input.deltaTime < options.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        // if tap count matches we have recognized it,
                        // else it has began recognizing...
                        var tapCount = this.count % options.taps;
                        if (tapCount === 0) {
                            // no failing requirements, immediately trigger the tap event
                            // or wait as long as the multitap interval to trigger
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function failTimeout() {
                    this._timer = setTimeoutContext(function () {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function reset() {
                    clearTimeout(this._timer);
                },
                emit: function emit() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            }); /**
                 * @const {string}
                 */
            Hammer.VERSION = '2.0.4';
            /**
             * default settings
             * @namespace
             */
            Hammer.defaults = {
                /**
                 * set if DOM events are being triggered.
                 * But this is slower and unused by simple implementations, so disabled by default.
                 * @type {Boolean}
                 * @default false
                 */
                domEvents: false,
                /**
                 * The value for the touchAction property/fallback.
                 * When set to `compute` it will magically set the correct value based on the added recognizers.
                 * @type {String}
                 * @default compute
                 */
                touchAction: TOUCH_ACTION_COMPUTE,
                /**
                 * @type {Boolean}
                 * @default true
                 */
                enable: true,
                /**
                 * EXPERIMENTAL FEATURE -- can be removed/changed
                 * Change the parent input target element.
                 * If Null, then it is being set the to main element.
                 * @type {Null|EventTarget}
                 * @default null
                 */
                inputTarget: null,
                /**
                 * force an input class
                 * @type {Null|Function}
                 * @default null
                 */
                inputClass: null,
                /**
                 * Default recognizer setup when calling `Hammer()`
                 * When creating a new Manager these will be skipped.
                 * @type {Array}
                 */
                preset: [
                // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [RotateRecognizer, { enable: false }], [PinchRecognizer, { enable: false }, ['rotate']], [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }], [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']], [TapRecognizer], [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']], [PressRecognizer]],
                /**
                 * Some CSS properties can be used to improve the working of Hammer.
                 * Add them to this method and they will be set when creating a new Manager.
                 * @namespace
                 */
                cssProps: {
                    /**
                     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userSelect: 'none',
                    /**
                     * Disable the Windows Phone grippers when pressing an element.
                     * @type {String}
                     * @default 'none'
                     */
                    touchSelect: 'none',
                    /**
                     * Disables the default callout shown when you touch and hold a touch target.
                     * On iOS, when you touch and hold a touch target such as a link, Safari displays
                     * a callout containing information about the link. This property allows you to disable that callout.
                     * @type {String}
                     * @default 'none'
                     */
                    touchCallout: 'none',
                    /**
                     * Specifies whether zooming is enabled. Used by IE10>
                     * @type {String}
                     * @default 'none'
                     */
                    contentZooming: 'none',
                    /**
                     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
                     * @type {String}
                     * @default 'none'
                     */
                    userDrag: 'none',
                    /**
                     * Overrides the highlight color shown when the user taps a link or a JavaScript
                     * clickable element in iOS. This property obeys the alpha value, if specified.
                     * @type {String}
                     * @default 'rgba(0,0,0,0)'
                     */
                    tapHighlightColor: 'rgba(0,0,0,0)'
                }
            };
            STOP = 1;
            FORCED_STOP = 2;
            Manager.prototype = {
                /**
                 * set options
                 * @param {Object} options
                 * @returns {Manager}
                 */
                set: function set(options) {
                    extend(this.options, options);
                    // Options that need a little more setup
                    if (options.touchAction) {
                        this.touchAction.update();
                    }
                    if (options.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = options.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
                 * stop recognizing for this session.
                 * This session will be discarded, when a new [input]start event is fired.
                 * When forced, the recognizer cycle is stopped immediately.
                 * @param {Boolean} [force]
                 */
                stop: function stop(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
                 * run the recognizers!
                 * called by the inputHandler function on every movement of the pointers (touches)
                 * it walks through all the recognizers and tries to detect the gesture that is being made
                 * @param {Object} inputData
                 */
                recognize: function recognize(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var curRecognizer = session.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i = 0;
                    while (i < recognizers.length) {
                        recognizer = recognizers[i];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i++;
                    }
                },
                /**
                 * get a recognizer by its event name.
                 * @param {Recognizer|String} recognizer
                 * @returns {Recognizer|Null}
                 */
                get: function get(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for (var i = 0; i < recognizers.length; i++) {
                        if (recognizers[i].options.event == recognizer) {
                            return recognizers[i];
                        }
                    }
                    return null;
                },
                /**
                 * add a recognizer to the manager
                 * existing recognizers with the same event name will be removed
                 * @param {Recognizer} recognizer
                 * @returns {Recognizer|Manager}
                 */
                add: function add(recognizer) {
                    if (invokeArrayArg(recognizer, 'add', this)) {
                        return this;
                    }
                    // remove existing
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
                 * remove a recognizer by name or instance
                 * @param {Recognizer|String} recognizer
                 * @returns {Manager}
                 */
                remove: function remove(recognizer) {
                    if (invokeArrayArg(recognizer, 'remove', this)) {
                        return this;
                    }
                    var recognizers = this.recognizers;
                    recognizer = this.get(recognizer);
                    recognizers.splice(inArray(recognizers, recognizer), 1);
                    this.touchAction.update();
                    return this;
                },
                /**
                 * bind event
                 * @param {String} events
                 * @param {Function} handler
                 * @returns {EventEmitter} this
                 */
                on: function on(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        handlers[event] = handlers[event] || [];
                        handlers[event].push(handler);
                    });
                    return this;
                },
                /**
                 * unbind event, leave emit blank to remove all handlers
                 * @param {String} events
                 * @param {Function} [handler]
                 * @returns {EventEmitter} this
                 */
                off: function off(events, handler) {
                    var handlers = this.handlers;
                    each(splitStr(events), function (event) {
                        if (!handler) {
                            delete handlers[event];
                        } else {
                            handlers[event].splice(inArray(handlers[event], handler), 1);
                        }
                    });
                    return this;
                },
                /**
                 * emit event to the listeners
                 * @param {String} event
                 * @param {Object} data
                 */
                emit: function emit(event, data) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) {
                        triggerDomEvent(event, data);
                    }
                    // no handlers, so skip it all
                    var handlers = this.handlers[event] && this.handlers[event].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event;
                    data.preventDefault = function () {
                        data.srcEvent.preventDefault();
                    };
                    var i = 0;
                    while (i < handlers.length) {
                        handlers[i](data);
                        i++;
                    }
                },
                /**
                 * destroy the manager and unbinds all events
                 * it doesn't unbind dom events, that is the user own responsibility
                 */
                destroy: function destroy() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };extend(Hammer, {
                INPUT_START: INPUT_START,
                INPUT_MOVE: INPUT_MOVE,
                INPUT_END: INPUT_END,
                INPUT_CANCEL: INPUT_CANCEL,
                STATE_POSSIBLE: STATE_POSSIBLE,
                STATE_BEGAN: STATE_BEGAN,
                STATE_CHANGED: STATE_CHANGED,
                STATE_ENDED: STATE_ENDED,
                STATE_RECOGNIZED: STATE_RECOGNIZED,
                STATE_CANCELLED: STATE_CANCELLED,
                STATE_FAILED: STATE_FAILED,
                DIRECTION_NONE: DIRECTION_NONE,
                DIRECTION_LEFT: DIRECTION_LEFT,
                DIRECTION_RIGHT: DIRECTION_RIGHT,
                DIRECTION_UP: DIRECTION_UP,
                DIRECTION_DOWN: DIRECTION_DOWN,
                DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL: DIRECTION_VERTICAL,
                DIRECTION_ALL: DIRECTION_ALL,
                Manager: Manager,
                Input: Input,
                TouchAction: TouchAction,
                TouchInput: TouchInput,
                MouseInput: MouseInput,
                PointerEventInput: PointerEventInput,
                TouchMouseInput: TouchMouseInput,
                SingleTouchInput: SingleTouchInput,
                Recognizer: Recognizer,
                AttrRecognizer: AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each: each,
                merge: merge,
                extend: extend,
                inherit: inherit,
                bindFn: bindFn,
                prefixed: prefixed
            });
            /*
            if (typeof define == TYPE_FUNCTION && define.amd) {
                define(function() {
                    return Hammer;
                });
            } else if (typeof module != 'undefined' && module.exports) {
                module.exports = Hammer;
            } else {
                window[exportName] = Hammer;
            }
            */

            _export('Hammer', Hammer);

            //})(window, document, 'Hammer');
        }
    };
});
System.register('ionic/gestures/slide-edge-gesture', ['ionic/gestures/slide-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var SlideGesture, util, SlideEdgeGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideEdgeGesture = (function (_SlideGesture) {
                function SlideEdgeGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideEdgeGesture);

                    util.defaults(opts, {
                        edge: 'left',
                        threshold: 50
                    });
                    _get(Object.getPrototypeOf(SlideEdgeGesture.prototype), 'constructor', this).call(this, element, opts);
                    // Can check corners through use of eg 'left top'
                    this.edges = opts.edge.split(' ');
                    this.threshold = opts.threshold;
                }

                _inherits(SlideEdgeGesture, _SlideGesture);

                _createClass(SlideEdgeGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        var _this = this;

                        this._containerRect = this.getContainerDimensions();
                        return this.edges.every(function (edge) {
                            return _this._checkEdge(edge, ev.gesture.center);
                        });
                    }
                }, {
                    key: 'getContainerDimensions',
                    value: function getContainerDimensions() {
                        return {
                            left: 0,
                            top: 0,
                            width: window.innerWidth,
                            height: window.innerHeight
                        };
                    }
                }, {
                    key: '_checkEdge',
                    value: function _checkEdge(edge, pos) {
                        switch (edge) {
                            case 'left':
                                return pos.x <= this._containerRect.left + this.threshold;
                            case 'right':
                                return pos.x >= this._containerRect.width - this.threshold;
                            case 'top':
                                return pos.y <= this._containerRect.top + this.threshold;
                            case 'bottom':
                                return pos.y >= this._containerRect.height - this.threshold;
                        }
                    }
                }]);

                return SlideEdgeGesture;
            })(SlideGesture);

            _export('SlideEdgeGesture', SlideEdgeGesture);
        }
    };
});
System.register('ionic/gestures/slide-gesture', ['ionic/gestures/drag-gesture', 'ionic/util'], function (_export) {
    'use strict';

    var DragGesture, util, SlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            SlideGesture = (function (_DragGesture) {
                function SlideGesture(element) {
                    var opts = arguments[1] === undefined ? {} : arguments[1];

                    _classCallCheck(this, SlideGesture);

                    _get(Object.getPrototypeOf(SlideGesture.prototype), 'constructor', this).call(this, element, opts);
                    this.element = element;
                }

                _inherits(SlideGesture, _DragGesture);

                _createClass(SlideGesture, [{
                    key: 'getSlideBoundaries',

                    /*
                     * Get the min and max for the slide. pageX/pageY.
                     * Only called on dragstart.
                     */
                    value: function getSlideBoundaries(slide, ev) {
                        return {
                            min: 0,
                            max: this.element.offsetWidth
                        };
                    }
                }, {
                    key: 'getElementStartPos',

                    /*
                     * Get the element's pos when the drag starts.
                     * For example, an open side menu starts at 100% and a closed
                     * sidemenu starts at 0%.
                     */
                    value: function getElementStartPos(slide, ev) {
                        return 0;
                    }
                }, {
                    key: 'canStart',
                    value: function canStart() {
                        return true;
                    }
                }, {
                    key: 'onDragStart',
                    value: function onDragStart(ev) {
                        var _this = this;

                        if (!this.canStart(ev)) return false;
                        this.slide = {};
                        var promise = this.onSlideBeforeStart(this.slide, ev) || Promise.resolve();
                        promise.then(function () {
                            var _getSlideBoundaries = _this.getSlideBoundaries(_this.slide, ev);

                            var min = _getSlideBoundaries.min;
                            var max = _getSlideBoundaries.max;

                            _this.slide.min = min;
                            _this.slide.max = max;
                            _this.slide.elementStartPos = _this.getElementStartPos(_this.slide, ev);
                            _this.slide.pointerStartPos = ev.gesture.center[_this.direction];
                            _this.slide.started = true;
                            _this.onSlideStart(_this.slide, ev);
                        })['catch'](function () {
                            _this.slide = null;
                        });
                    }
                }, {
                    key: 'onDrag',
                    value: function onDrag(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.slide.pos = ev.gesture.center[this.direction];
                        this.slide.distance = util.clamp(this.slide.min, this.slide.pos - this.slide.pointerStartPos + this.slide.elementStartPos, this.slide.max);
                        this.slide.delta = this.slide.pos - this.slide.pointerStartPos;
                        this.onSlide(this.slide, ev);
                    }
                }, {
                    key: 'onDragEnd',
                    value: function onDragEnd(ev) {
                        if (!this.slide || !this.slide.started) return;
                        this.onSlideEnd(this.slide, ev);
                        this.slide = null;
                    }
                }, {
                    key: 'onSlideBeforeStart',
                    value: function onSlideBeforeStart() {}
                }, {
                    key: 'onSlideStart',
                    value: function onSlideStart() {}
                }, {
                    key: 'onSlide',
                    value: function onSlide() {}
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd() {}
                }]);

                return SlideGesture;
            })(DragGesture);

            _export('SlideGesture', SlideGesture);
        }
    };
});
System.register('ionic/platform/platform', ['../util/util', '../util/dom'], function (_export) {
    'use strict';

    var util, dom, PlatformCtrl, PlatformNode, Platform;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function insertSuperset(platformNode) {
        var supersetPlaformName = platformNode.superset();
        if (supersetPlaformName) {
            // add a platform in between two exist platforms
            // so we can build the correct hierarchy of active platforms
            var supersetPlatform = new PlatformNode(supersetPlaformName);
            supersetPlatform.parent(platformNode.parent());
            supersetPlatform.child(platformNode);
            if (supersetPlatform.parent()) {
                supersetPlatform.parent().child(supersetPlatform);
            }
            platformNode.parent(supersetPlatform);
        }
    }
    return {
        setters: [function (_utilUtil) {
            util = _utilUtil;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            PlatformCtrl = (function () {
                function PlatformCtrl() {
                    var _this = this;

                    _classCallCheck(this, PlatformCtrl);

                    this._settings = {};
                    this._platforms = [];
                    this._versions = {};
                    this._registry = {};
                    this._default = null;
                    this._onResizes = [];
                    this._readyPromise = new Promise(function (res) {
                        _this._readyResolve = res;
                    });
                }

                _createClass(PlatformCtrl, [{
                    key: 'is',

                    // Methods
                    // **********************************************
                    value: function is(platformName) {
                        return this._platforms.indexOf(platformName) > -1;
                    }
                }, {
                    key: 'platforms',
                    value: function platforms() {
                        // get the array of active platforms, which also knows the hierarchy,
                        // with the last one the most important
                        return this._platforms;
                    }
                }, {
                    key: 'versions',
                    value: function versions(platformName) {
                        if (arguments.length) {
                            // get a specific platform's version
                            return this._versions[platformName];
                        }
                        // get all the platforms that have a valid parsed version
                        return this._versions;
                    }
                }, {
                    key: 'ready',
                    value: function ready() {
                        return this._readyPromise;
                    }
                }, {
                    key: 'prepareReady',
                    value: function prepareReady(config) {
                        var self = this;
                        function resolve() {
                            self._readyResolve(config);
                        }
                        if (this._engineReady) {
                            // the engine provide a ready promise, use this instead
                            this._engineReady(resolve);
                        } else {
                            // there is no custom ready method from the engine
                            // use the default dom ready
                            dom.ready(resolve);
                        }
                    }
                }, {
                    key: 'domReady',
                    value: function domReady() {
                        // convenience method so its easy to access on Platform
                        return dom.ready.apply(this, arguments);
                    }
                }, {
                    key: 'windowLoad',
                    value: function windowLoad() {
                        // convenience method so its easy to access on Platform
                        return dom.windowLoad.apply(this, arguments);
                    }
                }, {
                    key: 'on',

                    // Methods meant to be overridden by the engine
                    // **********************************************
                    // Provided NOOP methods so they do not error when
                    // called by engines (the browser) doesn't provide them
                    value: function on() {}
                }, {
                    key: 'onHardwareBackButton',
                    value: function onHardwareBackButton() {}
                }, {
                    key: 'registerBackButtonAction',
                    value: function registerBackButtonAction() {}
                }, {
                    key: 'exitApp',
                    value: function exitApp() {}
                }, {
                    key: 'fullScreen',
                    value: function fullScreen() {}
                }, {
                    key: 'showStatusBar',
                    value: function showStatusBar() {}
                }, {
                    key: 'url',

                    // Getter/Setter Methods
                    // **********************************************
                    value: function url(val) {
                        if (arguments.length) {
                            this._url = val;
                            this._qs = util.getQuerystring(val);
                        }
                        return this._url;
                    }
                }, {
                    key: 'query',
                    value: function query(key) {
                        return (this._qs || {})[key];
                    }
                }, {
                    key: 'userAgent',
                    value: function userAgent(val) {
                        if (arguments.length) {
                            this._ua = val;
                        }
                        return this._ua;
                    }
                }, {
                    key: 'navigatorPlatform',
                    value: function navigatorPlatform(val) {
                        if (arguments.length) {
                            this._bPlt = val;
                        }
                        return this._bPlt || '';
                    }
                }, {
                    key: 'width',
                    value: function width() {
                        if (!this._w) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._w;
                    }
                }, {
                    key: 'height',
                    value: function height() {
                        if (!this._h) {
                            this._w = window.innerWidth;
                            this._h = window.innerHeight;
                        }
                        return this._h;
                    }
                }, {
                    key: 'isPortrait',
                    value: function isPortrait() {
                        return this.width() < this.height();
                    }
                }, {
                    key: 'isLandscape',
                    value: function isLandscape() {
                        return !this.isPortrait();
                    }
                }, {
                    key: 'winResize',
                    value: function winResize() {
                        Platform._w = Platform._h = 0;
                        clearTimeout(Platform._resizeTimer);
                        Platform._resizeTimer = setTimeout(function () {
                            for (var i = 0; i < Platform._onResizes.length; i++) {
                                try {
                                    Platform._onResizes[i]();
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        }, 500);
                    }
                }, {
                    key: 'onResize',
                    value: function onResize(cb) {
                        // TODO: Make more good
                        this._onResizes.push(cb);
                    }
                }, {
                    key: 'register',

                    // Registry
                    // **********************************************
                    value: function register(platformConfig) {
                        this._registry[platformConfig.name] = platformConfig;
                    }
                }, {
                    key: 'registry',
                    value: function registry() {
                        return this._registry;
                    }
                }, {
                    key: 'setDefault',
                    value: function setDefault(platformName) {
                        this._default = platformName;
                    }
                }, {
                    key: 'testQuery',
                    value: function testQuery(queryValue) {
                        var val = this.query('ionicplatform');
                        if (val) {
                            var valueSplit = val.toLowerCase().split(';');
                            for (var i = 0; i < valueSplit.length; i++) {
                                if (valueSplit[i] == queryValue) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'testUserAgent',
                    value: function testUserAgent(userAgentExpression) {
                        var rx = new RegExp(userAgentExpression, 'i');
                        return rx.test(this._ua);
                    }
                }, {
                    key: 'matchUserAgentVersion',
                    value: function matchUserAgentVersion(userAgentExpression) {
                        var val = this._ua.match(userAgentExpression);
                        if (val) {
                            return {
                                major: val[1],
                                minor: val[2]
                            };
                        }
                    }
                }, {
                    key: 'isPlatform',
                    value: function isPlatform(queryValue, userAgentExpression) {
                        if (!userAgentExpression) {
                            userAgentExpression = queryValue;
                        }
                        return this.testQuery(queryValue) || this.testUserAgent(userAgentExpression);
                    }
                }, {
                    key: 'load',
                    value: function load(config) {
                        var rootPlatformNode = null;
                        var engineNode = null;
                        var self = this;
                        this.platformOverride = config.setting('platform');
                        // figure out the most specific platform and active engine
                        var tmpPlatform = null;
                        for (var platformName in this._registry) {
                            tmpPlatform = this.matchPlatform(platformName);
                            if (tmpPlatform) {
                                // we found a platform match!
                                // check if its more specific than the one we already have
                                if (tmpPlatform.isEngine) {
                                    // because it matched then this should be the active engine
                                    // you cannot have more than one active engine
                                    engineNode = tmpPlatform;
                                } else if (!rootPlatformNode || tmpPlatform.depth > rootPlatformNode.depth) {
                                    // only find the root node for platforms that are not engines
                                    // set this node as the root since we either don't already
                                    // have one, or this one is more specific that the current one
                                    rootPlatformNode = tmpPlatform;
                                }
                            }
                        }
                        if (!rootPlatformNode) {
                            rootPlatformNode = new PlatformNode(this._default);
                        }
                        // build a Platform instance filled with the
                        // hierarchy of active platforms and settings
                        if (rootPlatformNode) {
                            // check if we found an engine node (cordova/node-webkit/etc)
                            if (engineNode) {
                                // add the engine to the first in the platform hierarchy
                                // the original rootPlatformNode now becomes a child
                                // of the engineNode, which is not the new root
                                engineNode.child(rootPlatformNode);
                                rootPlatformNode.parent(engineNode);
                                rootPlatformNode = engineNode;
                                // add any events which the engine would provide
                                // for example, Cordova provides its own ready event
                                var engineMethods = engineNode.methods();
                                engineMethods._engineReady = engineMethods.ready;
                                delete engineMethods.ready;
                                util.extend(this, engineMethods);
                            }
                            var platformNode = rootPlatformNode;
                            while (platformNode) {
                                insertSuperset(platformNode);
                                platformNode = platformNode.child();
                            }
                            // make sure the root noot is actually the root
                            // incase a node was inserted before the root
                            platformNode = rootPlatformNode.parent();
                            while (platformNode) {
                                rootPlatformNode = platformNode;
                                platformNode = platformNode.parent();
                            }
                            platformNode = rootPlatformNode;
                            while (platformNode) {
                                // set the array of active platforms with
                                // the last one in the array the most important
                                this._platforms.push(platformNode.name());
                                // copy default platform settings into this platform settings obj
                                this._settings[platformNode.name()] = util.extend({}, platformNode.settings());
                                // get the platforms version if a version parser was provided
                                this._versions[platformNode.name()] = platformNode.version(this);
                                // go to the next platform child
                                platformNode = platformNode.child();
                            }
                        }
                    }
                }, {
                    key: 'matchPlatform',
                    value: function matchPlatform(platformName) {
                        // build a PlatformNode and assign config data to it
                        // use it's getRoot method to build up its hierarchy
                        // depending on which platforms match
                        var platformNode = new PlatformNode(platformName);
                        var rootNode = platformNode.getRoot(this, 0);
                        if (rootNode) {
                            rootNode.depth = 0;
                            var childPlatform = rootNode.child();
                            while (childPlatform) {
                                rootNode.depth++;
                                childPlatform = childPlatform.child();
                            }
                        }
                        return rootNode;
                    }
                }, {
                    key: 'settings',
                    value: function settings(val) {
                        if (arguments.length) {
                            this._settings = val;
                        }
                        return this._settings;
                    }
                }, {
                    key: 'get',
                    value: function get(platformName) {
                        return this._registry[platformName] || {};
                    }
                }]);

                return PlatformCtrl;
            })();

            _export('PlatformCtrl', PlatformCtrl);

            PlatformNode = (function () {
                function PlatformNode(platformName) {
                    _classCallCheck(this, PlatformNode);

                    this.c = Platform.get(platformName);
                    this.isEngine = this.c.isEngine;
                }

                _createClass(PlatformNode, [{
                    key: 'name',
                    value: function name() {
                        return this.c.name;
                    }
                }, {
                    key: 'settings',
                    value: function settings() {
                        return this.c.settings || {};
                    }
                }, {
                    key: 'superset',
                    value: function superset() {
                        return this.c.superset;
                    }
                }, {
                    key: 'methods',
                    value: function methods() {
                        return this.c.methods || {};
                    }
                }, {
                    key: 'parent',
                    value: function parent(val) {
                        if (arguments.length) {
                            this._parent = val;
                        }
                        return this._parent;
                    }
                }, {
                    key: 'child',
                    value: function child(val) {
                        if (arguments.length) {
                            this._child = val;
                        }
                        return this._child;
                    }
                }, {
                    key: 'isMatch',
                    value: function isMatch(p) {
                        if (typeof this.c.isMatched !== 'boolean') {
                            if (p.platformOverride && !this.isEngine) {
                                this.c.isMatched = p.platformOverride === this.c.name;
                            } else if (!this.c.isMatch) {
                                this.c.isMatched = false;
                            } else {
                                this.c.isMatched = this.c.isMatch(p);
                            }
                        }
                        return this.c.isMatched;
                    }
                }, {
                    key: 'version',
                    value: function version(p) {
                        if (this.c.versionParser) {
                            var v = this.c.versionParser(p);
                            if (v) {
                                var str = v.major + '.' + v.minor;
                                return {
                                    str: str,
                                    num: parseFloat(str),
                                    major: parseInt(v.major, 10),
                                    minor: parseInt(v.minor, 10)
                                };
                            }
                        }
                    }
                }, {
                    key: 'getRoot',
                    value: function getRoot(p) {
                        if (this.isMatch(p)) {
                            var parents = this.getSubsetParents(this.name());
                            if (!parents.length) {
                                return this;
                            }
                            var platform = null;
                            var rootPlatform = null;
                            for (var i = 0; i < parents.length; i++) {
                                platform = new PlatformNode(parents[i]);
                                platform.child(this);
                                rootPlatform = platform.getRoot(p);
                                if (rootPlatform) {
                                    this.parent(platform);
                                    return rootPlatform;
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getSubsetParents',
                    value: function getSubsetParents(subsetPlatformName) {
                        var registry = Platform.registry();
                        var parentPlatformNames = [];
                        var platform = null;
                        for (var platformName in registry) {
                            platform = registry[platformName];
                            if (platform.subsets && platform.subsets.indexOf(subsetPlatformName) > -1) {
                                parentPlatformNames.push(platformName);
                            }
                        }
                        return parentPlatformNames;
                    }
                }]);

                return PlatformNode;
            })();

            Platform = new PlatformCtrl();

            _export('Platform', Platform);
        }
    };
});
System.register('ionic/platform/registry', ['./platform'], function (_export) {
    'use strict';

    var Platform;
    return {
        setters: [function (_platform) {
            Platform = _platform.Platform;
        }],
        execute: function () {
            Platform.register({
                name: 'core',
                settings: {
                    backButtonText: 'Back',
                    backButtonIcon: 'ion-ios-arrow-back',
                    forwardIcon: 'ion-ios-arrow-forward',
                    mode: 'ios',
                    iconMode: 'ios',
                    navTitleAlign: 'center',
                    viewTransition: 'ios'
                }
            });
            Platform.setDefault('core');
            Platform.register({
                name: 'mobile'
            });
            Platform.register({
                name: 'phablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    // http://www.mydevice.io/devices/
                    return smallest > 390 && smallest < 520 && (largest > 620 && largest < 800);
                }
            });
            Platform.register({
                name: 'tablet',
                isMatch: function isMatch(p) {
                    var smallest = Math.min(p.width(), p.height());
                    var largest = Math.max(p.width(), p.height());
                    // http://www.mydevice.io/devices/
                    return smallest > 460 && smallest < 820 && (largest > 780 && largest < 1400);
                }
            });
            Platform.register({
                name: 'android',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    backButtonText: '',
                    backButtonIcon: 'ion-android-arrow-back',
                    forwardIcon: '',
                    mode: 'md',
                    iconMode: 'md',
                    type: 'overlay',
                    keyboardScrollAssist: true,
                    mdRipple: true,
                    tabBarPlacement: 'top',
                    navTitleAlign: 'left',
                    viewTransition: 'md'
                },
                isMatch: function isMatch(p) {
                    // "silk" is kindle fire
                    return p.isPlatform('android', 'android| silk');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Android (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'ios',
                superset: 'mobile',
                subsets: ['ipad', 'iphone'],
                settings: {
                    backButtonText: 'Back',
                    backButtonIcon: 'ion-ios-arrow-back',
                    forwardIcon: 'ion-ios-arrow-forward',
                    mode: 'ios',
                    iconMode: 'ios',
                    tapPolyfill: function tapPolyfill() {
                        // this ensures it's actually a physical iOS device
                        // and not just an a spoofed user-agent string
                        return /iphone|ipad|ipod/i.test(Platform.navigatorPlatform());
                    },
                    keyboardScrollAssist: true,
                    viewTransition: 'ios',
                    navTitleAlign: 'center',
                    mdRipple: false
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('ios', 'iphone|ipad|ipod');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/OS (\d+)_(\d+)?/);
                }
            });
            Platform.register({
                name: 'ipad',
                superset: 'tablet',
                isMatch: function isMatch(p) {
                    return p.isPlatform('ipad');
                }
            });
            Platform.register({
                name: 'iphone',
                subsets: ['phablet'],
                isMatch: function isMatch(p) {
                    return p.isPlatform('iphone');
                }
            });
            Platform.register({
                name: 'windowsphone',
                superset: 'mobile',
                subsets: ['phablet', 'tablet'],
                settings: {
                    mode: 'wp',
                    iconMode: 'md',
                    viewTransition: 'md'
                },
                isMatch: function isMatch(p) {
                    return p.isPlatform('windowsphone', 'windows phone');
                },
                versionParser: function versionParser(p) {
                    return p.matchUserAgentVersion(/Windows Phone (\d+).(\d+)?/);
                }
            });
            Platform.register({
                name: 'cordova',
                isEngine: true,
                methods: {
                    ready: function ready(resolve) {
                        Platform.windowLoad(function () {
                            document.addEventListener('deviceready', resolve);
                        });
                    }
                },
                isMatch: function isMatch(p) {
                    return !!(window.cordova || window.PhoneGap || window.phonegap);
                }
            });
        }
    };
});
System.register('ionic/net/http', ['ionic/util'], function (_export) {
    'use strict';

    var util, Http;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            //TODO(mlynch): surely, there must be another way, sir?
            window._jsonpcallbacks = {
                counter: 0
            };
            /**
             * The Http class makes it easy to send GET/POST/PUT/DELETE/PATCH requests
             * and send/receive JSON (or anything else) through a simple API.
             *
             * Http uses the `fetch()` API underneath, or a polyfill if it's not natively supported.
             */

            Http = (function () {
                function Http() {
                    _classCallCheck(this, Http);
                }

                _createClass(Http, null, [{
                    key: 'fetch',

                    /**
                     * The raw fetch() operation.
                     *
                     * Generally, you want to use one of get()/post()/put()/delete() but
                     * this is useful if you want to do something crazy.
                     *
                     * @param url the URL to pass to fetch
                     * @param options the options to configure the fetch
                     * @return es6 promise from the fetch.
                     */
                    value: function fetch(url, options) {
                        return window.fetch(url, options).then(function (response) {
                            // status "0" to handle local files fetching (e.g. Cordova/Phonegap etc.)
                            if (response.status === 200 || response.status === 0) {
                                // We have a good response, let's check the response headers and return
                                // deserialized JSON or return the text from the response.
                                if (response.headers.get('Content-Type') === 'application/json') {
                                    return response.json();
                                }
                                return response.text();
                            } else {
                                return Promise.reject(response, new Error(response.statusText));
                            }
                        })['catch'](function (err) {
                            return Promise.reject(err);
                        });
                    }
                }, {
                    key: 'jsonp',
                    value: function jsonp(url, callbackId, options) {
                        return new Promise(function (resolve, reject) {
                            var script = document.createElement('script');
                            script.src = url;
                            script.async = true;
                            script.type = 'text/javascript';
                            var callback = function callback(event) {
                                script.removeEventListener('load', callback);
                                script.removeEventListener('error', callback);
                                document.body.removeChild(script);
                                var text = undefined,
                                    status = undefined;
                                if (event) {
                                    if (event.type === 'load' && !window._jsonpcallbacks[callbackId].called) {
                                        event = { type: 'error' };
                                    }
                                    text = event.type;
                                    status = event.type === 'error' ? 404 : 200;
                                    resolve(window._jsonpcallbacks[callbackId].data, status, text);
                                } else {
                                    reject();
                                }
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                            };
                            script.addEventListener('load', callback);
                            script.addEventListener('error', callback);
                            document.body.appendChild(script);
                            return callback;
                        });
                    }
                }, {
                    key: '_method',
                    value: function _method(method, url, data, options, sendsJson) {
                        options = util.defaults(options, {
                            method: method,
                            headers: {
                                'Accept': 'application/json,text/plain,*/*'
                            }
                        });
                        if (options.body) {
                            options.body = typeof data === 'string' ? data : JSON.stringify(data);
                        }
                        if (sendsJson) {
                            options.headers['Content-Type'] = 'application/json';
                        }
                        if (options.method == 'jsonp') {
                            var callbackId;

                            var _ret = (function () {
                                // Adopted from Angular 1
                                var callbacks = window._jsonpcallbacks;
                                callbackId = '_' + (callbacks.counter++).toString(36);

                                callbacks[callbackId] = function (data) {
                                    callbacks[callbackId].data = data;
                                    callbacks[callbackId].called = true;
                                };
                                /*
                                var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                                    callbackId, function(status, text) {
                                  completeRequest(callback, status, callbacks[callbackId].data, "", text);
                                  callbacks[callbackId] = noop;
                                });
                                */
                                url = url.replace('JSON_CALLBACK', '_jsonpcallbacks.' + callbackId);
                                return {
                                    v: Http.jsonp(url, callbackId, options)
                                };
                            })();

                            if (typeof _ret === 'object') return _ret.v;
                        } else {
                            return Http.fetch(url, options);
                        }
                    }
                }, {
                    key: 'get',

                    /**
                     * Send a GET request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function get(url) {
                        var options = arguments[1] === undefined ? {} : arguments[1];

                        return Http._method('get', url, {}, options);
                    }
                }, {
                    key: 'post',

                    /**
                     * Send a POST request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to POST to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function post(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('post', url, data, options, true);
                    }
                }, {
                    key: 'put',

                    /**
                     * Send a PUT request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PUT to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function put(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('put', url, data, options, true);
                    }
                }, {
                    key: 'delete',

                    /**
                     * Send a DELETE request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to DELETE to
                     * @param data the JSON data to send
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function _delete(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('delete', url, data, options, true);
                    }
                }, {
                    key: 'patch',

                    /**
                     * Send a PATH request to the given URL.
                     *
                     * By default, options sends the `Accept` header as `application/json,text/plain,* / *`,
                     * and the `Content-Type` header as `application/json`
                     *
                     * @param url the URL to PATH to
                     * @param options the options to configure the post with.
                     * @return promise
                     */
                    value: function patch(url) {
                        var data = arguments[1] === undefined ? {} : arguments[1];
                        var options = arguments[2] === undefined ? {} : arguments[2];

                        return Http._method('patch', url, data, options, true);
                    }
                }]);

                return Http;
            })();

            _export('Http', Http);
        }
    };
});
System.register('ionic/routing/path-recognizer', ['angular2/src/facade/lang', 'angular2/src/facade/collection'], function (_export) {
    'use strict';

    var RegExpWrapper, StringWrapper, isPresent, BaseException, normalizeBlank, StringMapWrapper, ListWrapper, ContinuationSegment, StaticSegment, DynamicSegment, StarSegment, paramMatcher, wildcardMatcher, PathRecognizer, specialCharacters, escapeRe;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function parsePathString(route) {
        // normalize route as not starting with a "/". Recognition will
        // also normalize.
        if (StringWrapper.startsWith(route, '/')) {
            route = StringWrapper.substring(route, 1);
        }
        var segments = splitBySlash(route);
        var results = [];
        var specificity = 0;
        // The "specificity" of a path is used to determine which route is used when multiple routes match
        // a URL.
        // Static segments (like "/foo") are the most specific, followed by dynamic segments (like
        // "/:id"). Star segments
        // add no specificity. Segments at the start of the path are more specific than proceeding ones.
        // The code below uses place values to combine the different types of segments into a single
        // integer that we can
        // sort later. Each static segment is worth hundreds of points of specificity (10000, 9900, ...,
        // 200), and each
        // dynamic segment is worth single points of specificity (100, 99, ... 2).
        if (segments.length > 98) {
            throw new BaseException('\'' + route + '\' has more than the maximum supported number of segments.');
        }
        var limit = segments.length - 1;
        for (var i = 0; i <= limit; i++) {
            var segment = segments[i],
                match;
            if (isPresent(match = RegExpWrapper.firstMatch(paramMatcher, segment))) {
                results.push(new DynamicSegment(match[1]));
                specificity += 100 - i;
            } else if (isPresent(match = RegExpWrapper.firstMatch(wildcardMatcher, segment))) {
                results.push(new StarSegment(match[1]));
            } else if (segment == '...') {
                if (i < limit) {
                    // TODO (matsko): setup a proper error here `
                    throw new BaseException('Unexpected "..." before the end of the path for "' + route + '".');
                }
                results.push(new ContinuationSegment());
            } else if (segment.length > 0) {
                results.push(new StaticSegment(segment));
                specificity += 100 * (100 - i);
            }
        }
        return { segments: results, specificity: specificity };
    }
    function splitBySlash(url) {
        return url.split('/');
    }

    function escapeRegex(string) {
        return StringWrapper.replaceAllMapped(string, escapeRe, function (match) {
            return '\\' + match;
        });
    }
    return {
        setters: [function (_angular2SrcFacadeLang) {
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
            StringWrapper = _angular2SrcFacadeLang.StringWrapper;
            isPresent = _angular2SrcFacadeLang.isPresent;
            BaseException = _angular2SrcFacadeLang.BaseException;
            normalizeBlank = _angular2SrcFacadeLang.normalizeBlank;
        }, function (_angular2SrcFacadeCollection) {
            StringMapWrapper = _angular2SrcFacadeCollection.StringMapWrapper;
            ListWrapper = _angular2SrcFacadeCollection.ListWrapper;
        }],
        execute: function () {
            ContinuationSegment = (function () {
                function ContinuationSegment() {
                    _classCallCheck(this, ContinuationSegment);
                }

                _createClass(ContinuationSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        return '';
                    }
                }]);

                return ContinuationSegment;
            })();

            StaticSegment = (function () {
                function StaticSegment(string) {
                    _classCallCheck(this, StaticSegment);

                    this.name = '';
                    this.regex = escapeRegex(string);
                }

                _createClass(StaticSegment, [{
                    key: 'generate',
                    value: function generate() {
                        return this.regex;
                    }
                }]);

                return StaticSegment;
            })();

            DynamicSegment = (function () {
                function DynamicSegment(name) {
                    _classCallCheck(this, DynamicSegment);

                    this.regex = '([^/]+)';
                }

                _createClass(DynamicSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        if (!StringMapWrapper.contains(params, this.name)) {
                            throw new BaseException('Route generator for \'' + this.name + '\' was not included in parameters passed.');
                        }
                        return normalizeBlank(StringMapWrapper.get(params, this.name));
                    }
                }]);

                return DynamicSegment;
            })();

            StarSegment = (function () {
                function StarSegment(name) {
                    _classCallCheck(this, StarSegment);

                    this.regex = '(.+)';
                }

                _createClass(StarSegment, [{
                    key: 'generate',
                    value: function generate(params) {
                        return normalizeBlank(StringMapWrapper.get(params, this.name));
                    }
                }]);

                return StarSegment;
            })();

            paramMatcher = RegExpWrapper.create('^:([^/]+)$');
            wildcardMatcher = RegExpWrapper.create('^\\*([^/]+)$');
            // represents something like '/foo/:bar'

            PathRecognizer = (function () {
                function PathRecognizer(path) {
                    var _this = this;

                    _classCallCheck(this, PathRecognizer);

                    this.segments = [];
                    var parsed = parsePathString(path);
                    var specificity = parsed['specificity'];
                    var segments = parsed['segments'];
                    var regexString = '^';
                    ListWrapper.forEach(segments, function (segment) {
                        if (segment instanceof ContinuationSegment) {
                            _this.terminal = false;
                        } else {
                            regexString += '/' + segment.regex;
                        }
                    });
                    if (this.terminal) {
                        regexString += '$';
                    }
                    this.regex = RegExpWrapper.create(regexString);
                    this.segments = segments;
                    this.specificity = specificity;
                }

                _createClass(PathRecognizer, [{
                    key: 'parseParams',
                    value: function parseParams(url) {
                        var params = StringMapWrapper.create();
                        var urlPart = url;
                        for (var i = 0; i < this.segments.length; i++) {
                            var segment = this.segments[i];
                            if (segment instanceof ContinuationSegment) {
                                continue;
                            }
                            var match = RegExpWrapper.firstMatch(RegExpWrapper.create('/' + segment.regex), urlPart);
                            urlPart = StringWrapper.substring(urlPart, match[0].length);
                            if (segment.name.length > 0) {
                                StringMapWrapper.set(params, segment.name, match[1]);
                            }
                        }
                        return params;
                    }
                }, {
                    key: 'generate',
                    value: function generate(params) {
                        return ListWrapper.join(ListWrapper.map(this.segments, function (segment) {
                            return '/' + segment.generate(params);
                        }), '');
                    }
                }]);

                return PathRecognizer;
            })();

            _export('PathRecognizer', PathRecognizer);

            specialCharacters = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
            escapeRe = RegExpWrapper.create('(\\' + specialCharacters.join('|\\') + ')', 'g');
        }
    };
});
System.register('ionic/routing/router', ['angular2/src/facade/lang', '../util/util', './path-recognizer'], function (_export) {
    'use strict';

    var RegExpWrapper, util, PathRecognizer, IonicRouter, stateManagerClasses, stateManagers, Route;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2SrcFacadeLang) {
            RegExpWrapper = _angular2SrcFacadeLang.RegExpWrapper;
        }, function (_utilUtil) {
            util = _utilUtil;
        }, function (_pathRecognizer) {
            PathRecognizer = _pathRecognizer.PathRecognizer;
        }],
        execute: function () {
            IonicRouter = (function () {
                function IonicRouter(config) {
                    _classCallCheck(this, IonicRouter);

                    this._routes = [];
                    this._viewCtrls = [];
                    this.config(config);
                }

                _createClass(IonicRouter, [{
                    key: 'app',
                    value: function app(_app) {
                        this.app = _app;
                    }
                }, {
                    key: 'config',
                    value: function config(_config) {
                        if (_config) {
                            for (var i = 0; i < _config.length; i++) {
                                this.addRoute(_config[i]);
                            }
                        }
                    }
                }, {
                    key: 'addRoute',
                    value: function addRoute(routeConfig) {
                        if (routeConfig && routeConfig.path && routeConfig.component) {
                            var route = new Route(routeConfig);
                            if (routeConfig.root) {
                                this.otherwise(route);
                            }
                            this._routes.push(route);
                        }
                    }
                }, {
                    key: 'stateChange',
                    value: function stateChange(type, activeView) {
                        // this fires when the app's state has changed. `stateChange` will
                        // tell each of the state managers that the state has changed, and
                        // each state manager will decide what to do with this info
                        // (the url state manager updates the url bar if a route was setup)
                        if (activeView && activeView.component) {
                            var componentRoute = activeView.component.route;
                            if (componentRoute) {
                                var path = componentRoute.generate(activeView.params);
                                if (path) {
                                    for (var _name in stateManagers) {
                                        stateManagers[_name].stateChange(path, type, activeView);
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: 'stateClear',
                    value: function stateClear() {
                        for (var _name2 in stateManagers) {
                            stateManagers[_name2].stateClear();
                        }
                    }
                }, {
                    key: 'matchPaths',
                    value: function matchPaths(paths) {
                        // load each of paths to a component
                        var components = [];
                        var route = undefined;
                        if (paths) {
                            for (var i = 0; i < paths.length; i++) {
                                route = this.matchPath(paths[i]);
                                if (route && route.component) {
                                    components.push(route.component);
                                }
                            }
                        }
                        return components;
                    }
                }, {
                    key: 'matchPath',
                    value: function matchPath(path) {
                        // takes a string path and loops through each of the setup
                        // routes to see if the path matches any of the routes
                        // the matched path with the highest specifity wins
                        var matchedRoute = null;
                        var route = null;
                        var routeMatch = null;
                        for (var i = 0; i < this._routes.length; i++) {
                            route = this._routes[i];
                            routeMatch = route.match(path);
                            if (routeMatch && (!matchedRoute || route.specificity > matchedRoute.specificity)) {
                                matchedRoute = route;
                            }
                        }
                        return matchedRoute;
                    }
                }, {
                    key: 'load',
                    value: function load(window, ionicApp, ionicConfig) {
                        var _this = this;

                        // load is called when the app has finished loading each state
                        // manager gets a chance to say what path the app should be at
                        var viewCtrl = this.viewController();
                        if (!viewCtrl || !this._routes.length) {
                            return Promise.resolve();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // get the initial load paths from the state manager with the highest priorty
                        this.getManagerPaths(window, ionicApp, ionicConfig).then(function (paths) {
                            // load all of the paths the highest priority state manager has given
                            var components = _this.matchPaths(paths);
                            if (!components.length && _this.otherwise()) {
                                // the state manager did not find and loaded components
                                // use the "otherwise" path
                                components = [_this.otherwise().component];
                            }
                            _this.app.zoneRun(function () {
                                viewCtrl.setItems(components).then(resolve);
                            });
                        });
                        return promise;
                    }
                }, {
                    key: 'getManagerPaths',
                    value: function getManagerPaths(window, ionicApp, ionicConfig) {
                        // loop through all of the state managers and load their paths
                        // the state manager with valid paths and highest priority wins
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // load each of the state managers
                        var stateManagerPromises = [];
                        for (var _name3 in stateManagerClasses) {
                            stateManagers[_name3] = new stateManagerClasses[_name3](window, this, ionicApp, ionicConfig);
                            stateManagerPromises.push(stateManagers[_name3].load());
                        }
                        // when all the state manager loads have resolved then see which one wins
                        Promise.all(stateManagerPromises).then(function (stateManagerLoadResults) {
                            // now that all the state managers are loaded
                            // get the highest priority state manager's paths
                            var stateLoadResult = null;
                            var paths = null;
                            var highestPriority = -1;
                            for (var i = 0; i < stateManagerLoadResults.length; i++) {
                                stateLoadResult = stateManagerLoadResults[i];
                                if (stateLoadResult && stateLoadResult.paths.length && stateLoadResult.priority > highestPriority) {
                                    paths = stateLoadResult.paths;
                                    highestPriority = stateLoadResult.priority;
                                }
                            }
                            resolve(paths);
                        });
                        return promise;
                    }
                }, {
                    key: 'push',
                    value: function push(path) {
                        var _this2 = this;

                        var viewCtrl = this.viewController();
                        if (viewCtrl) {
                            (function () {
                                var matchedRoute = _this2.matchPath(path);
                                if (matchedRoute && matchedRoute.component) {
                                    _this2.app.zoneRun(function () {
                                        viewCtrl.push(matchedRoute.component, matchedRoute.params, {});
                                    });
                                }
                            })();
                        }
                    }
                }, {
                    key: 'pop',
                    value: function pop() {
                        var viewCtrl = this.viewController();
                        if (viewCtrl) {
                            this.app.zoneRun(function () {
                                viewCtrl.pop();
                            });
                        }
                    }
                }, {
                    key: 'otherwise',
                    value: function otherwise(val) {
                        if (arguments.length) {
                            this._otherwise = val;
                        }
                        return this._otherwise;
                    }
                }, {
                    key: 'addViewController',
                    value: function addViewController(viewCtrl) {
                        this._viewCtrls.push(viewCtrl);
                    }
                }, {
                    key: 'viewController',
                    value: function viewController() {
                        if (this._viewCtrls.length) {
                            return this._viewCtrls[this._viewCtrls.length - 1];
                        }
                    }
                }], [{
                    key: 'registerStateManager',
                    value: function registerStateManager(name, StateManagerClass) {
                        stateManagerClasses[name] = StateManagerClass;
                    }
                }, {
                    key: 'deregisterStateManager',
                    value: function deregisterStateManager(name) {
                        delete stateManagerClasses[name];
                        delete stateManagers[name];
                    }
                }]);

                return IonicRouter;
            })();

            _export('IonicRouter', IonicRouter);

            stateManagerClasses = {};
            stateManagers = {};

            Route = (function () {
                function Route(routeConfig) {
                    _classCallCheck(this, Route);

                    util.extend(this, routeConfig);
                    this.recognizer = new PathRecognizer(this.path);
                    this.specificity = this.recognizer.specificity;
                    this.component.route = this;
                }

                _createClass(Route, [{
                    key: 'match',
                    value: function match(path) {
                        return RegExpWrapper.firstMatch(this.recognizer.regex, path);
                    }
                }, {
                    key: 'generate',
                    value: function generate(params) {
                        return this.recognizer.generate(params);
                    }
                }]);

                return Route;
            })();
        }
    };
});
System.register('ionic/routing/url-state', ['./router'], function (_export) {
    'use strict';

    var IonicRouter, UrlStateManager, PATH_STORE_KEY, MAX_PATH_STORE;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_router) {
            IonicRouter = _router.IonicRouter;
        }],
        execute: function () {
            UrlStateManager = (function () {
                function UrlStateManager(window, router) {
                    var _this = this;

                    _classCallCheck(this, UrlStateManager);

                    this.location = window.location;
                    this.history = window.history;
                    this.ls = window.localStorage;
                    this.router = router;
                    // overkill for location change listeners, but ensures we
                    // know when the location has changed. Only 1 of the listeners
                    // will actually do the work, the other will be skipped.
                    window.addEventListener('popstate', function () {
                        _this.onLocationChange();
                    });
                    window.addEventListener('hashchange', function () {
                        _this.onLocationChange();
                    });
                }

                _createClass(UrlStateManager, [{
                    key: 'load',
                    value: function load() {
                        var paths = [this.getCurrentPath()];
                        var savedPaths = this.paths();
                        if (savedPaths[savedPaths.length - 1] == paths[0]) {
                            // the last path in the saved paths is the same as the
                            // current path, so use the saved paths to rebuild the history
                            paths = savedPaths;
                        } else {
                            // the current path is not the same as the last path in the
                            // saved history, so the saved history is no good, erase it
                            this.paths([]);
                        }
                        return Promise.resolve({
                            paths: paths,
                            priority: 0
                        });
                    }
                }, {
                    key: 'stateChange',
                    value: function stateChange(path, type, activeView) {
                        var savedPaths = this.paths();
                        // check if the given path is different than the current location
                        var isDifferentPath = this.getCurrentPath() !== path;
                        if (type == 'pop') {
                            // if the popstate came from the browser's back button (and not Ionic)
                            // then we shouldn't force another browser history.back()
                            // only do a history.back() if the URL hasn't been updated yet
                            if (isDifferentPath) {
                                this.history.back();
                            }
                            if (savedPaths.length && savedPaths[savedPaths.length - 1] != path) {
                                // only if the last item in the saved paths
                                // equals this path then it can be removed
                                savedPaths.pop();
                            }
                        } else {
                            if (this._hasInit) {
                                if (isDifferentPath) {
                                    // push the new state to the history stack since the path
                                    // isn't already in the location hash
                                    this.history.pushState(path, '', '#' + path);
                                }
                            } else {
                                // replace the very first load with the correct entering state info
                                this.history.replaceState(path, '', '#' + path);
                                this._hasInit = true;
                            }
                            if (savedPaths[savedPaths.length - 1] != path) {
                                // only if the last item in the saved paths does
                                // not equal this path then it can be added
                                savedPaths.push(path);
                                // don't allow the history to grow too large
                                if (savedPaths.length > MAX_PATH_STORE) {
                                    savedPaths = savedPaths.slice(savedPaths.length - MAX_PATH_STORE);
                                }
                            }
                        }
                        // save the new path data
                        this.paths(savedPaths);
                        // ensure this resets
                        this._currentPath = null;
                    }
                }, {
                    key: 'stateClear',
                    value: function stateClear() {
                        this.paths([]);
                    }
                }, {
                    key: 'onLocationChange',
                    value: function onLocationChange() {
                        var currentPath = this.getCurrentPath();
                        if (currentPath == this._currentPath) {
                            // absolutely no change since last onLocationChange
                            return;
                        }
                        // keep in-memory the current path to quickly tell if things have changed
                        this._currentPath = currentPath;
                        // load up the saved paths
                        var savedPaths = this.paths();
                        if (currentPath === savedPaths[savedPaths.length - 1]) {
                            // do nothing if the last saved path is
                            // the same as the current path
                            return;
                        }
                        if (currentPath === savedPaths[savedPaths.length - 2]) {
                            // the user is moving back
                            this.router.pop();
                        } else {
                            // the user is moving forward
                            this.router.push(currentPath);
                        }
                    }
                }, {
                    key: 'paths',
                    value: function paths(val) {
                        if (arguments.length) {
                            // set in-memory data
                            this._paths = val;
                            // set localStorage data
                            try {
                                this.ls.setItem(PATH_STORE_KEY, JSON.stringify(val));
                            } catch (e) {}
                        } else {
                            if (!this._paths) {
                                // we don't already have data in-memory
                                // see if we have data in localStorage
                                try {
                                    var strData = this.ls.getItem(PATH_STORE_KEY);
                                    if (strData) {
                                        this._paths = JSON.parse(strData);
                                    }
                                } catch (e) {}
                                // if not in localStorage yet then create new path data
                                if (!this._paths) {
                                    this._paths = [];
                                }
                            }
                            // return the in-memory data
                            return this._paths;
                        }
                    }
                }, {
                    key: 'getCurrentPath',
                    value: function getCurrentPath() {
                        // remove leading # to get the path
                        return this.location.hash.slice(1);
                    }
                }]);

                return UrlStateManager;
            })();

            PATH_STORE_KEY = 'ionic:history';
            MAX_PATH_STORE = 20;

            IonicRouter.registerStateManager('url', UrlStateManager);
        }
    };
});
System.register('ionic/util/activator', ['./dom'], function (_export) {
    'use strict';

    var raf, queueElements, activeElements, keyId, ACTIVATED_CLASS, DEACTIVATE_TIMEOUT, Activator;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_dom) {
            raf = _dom.raf;
        }],
        execute: function () {
            queueElements = {};
            // elements that should get an active state in XX milliseconds
            activeElements = {};
            // elements that are currently active
            keyId = 0;
            // a counter for unique keys for the above ojects
            ACTIVATED_CLASS = 'activated';
            DEACTIVATE_TIMEOUT = 180;

            Activator = (function () {
                function Activator() {
                    _classCallCheck(this, Activator);
                }

                _createClass(Activator, null, [{
                    key: 'start',
                    value: function start(ele) {
                        queueElements[++keyId] = ele;
                        if (keyId > 9) keyId = 0;
                        raf(Activator.activate);
                    }
                }, {
                    key: 'activate',
                    value: function activate() {
                        // activate all elements in the queue
                        for (var key in queueElements) {
                            if (queueElements[key]) {
                                queueElements[key].classList.add(ACTIVATED_CLASS);
                                activeElements[key] = queueElements[key];
                            }
                        }
                        queueElements = {};
                    }
                }, {
                    key: 'end',
                    value: function end() {
                        setTimeout(Activator.clear, DEACTIVATE_TIMEOUT);
                    }
                }, {
                    key: 'clear',
                    value: function clear() {
                        // clear out any elements that are queued to be set to active
                        queueElements = {};
                        // in the next frame, remove the active class from all active elements
                        raf(Activator.deactivate);
                    }
                }, {
                    key: 'deactivate',
                    value: function deactivate() {
                        for (var key in activeElements) {
                            if (activeElements[key]) {
                                activeElements[key].classList.remove(ACTIVATED_CLASS);
                            }
                            delete activeElements[key];
                        }
                    }
                }, {
                    key: 'moveListeners',
                    value: function moveListeners(pointerMove, shouldAdd) {
                        document.removeEventListener('touchmove', pointerMove);
                        document.removeEventListener('mousemove', pointerMove);
                        if (shouldAdd) {
                            document.addEventListener('touchmove', pointerMove);
                            document.addEventListener('mousemove', pointerMove);
                        }
                    }
                }]);

                return Activator;
            })();

            _export('Activator', Activator);
        }
    };
});
System.register('ionic/util/click-block', [], function (_export) {
    'use strict';

    var CSS_CLICK_BLOCK, DEFAULT_EXPIRE, cbEle, fallbackTimerId, isShowing, ClickBlock;

    function disableInput(ev) {
        ev.preventDefault();
        ev.stopPropagation();
    }
    function show(expire) {
        clearTimeout(fallbackTimerId);
        fallbackTimerId = setTimeout(hide, expire || DEFAULT_EXPIRE);
        if (!isShowing) {
            isShowing = true;
            if (cbEle) {
                cbEle.classList.add(CSS_CLICK_BLOCK);
            } else {
                cbEle = document.createElement('div');
                cbEle.className = 'click-block ' + CSS_CLICK_BLOCK;
                document.body.appendChild(cbEle);
            }
            cbEle.addEventListener('touchmove', disableInput);
        }
    }
    function hide() {
        clearTimeout(fallbackTimerId);
        if (isShowing) {
            cbEle.classList.remove(CSS_CLICK_BLOCK);
            isShowing = false;
            cbEle.removeEventListener('touchmove', disableInput);
        }
    }
    return {
        setters: [],
        execute: function () {
            CSS_CLICK_BLOCK = 'click-block-active';
            DEFAULT_EXPIRE = 330;
            cbEle = undefined;
            fallbackTimerId = undefined;
            isShowing = false;

            ClickBlock = function ClickBlock(shouldShow, expire) {
                (shouldShow ? show : hide)(expire);
            };

            _export('ClickBlock', ClickBlock);
        }
    };
});
System.register('ionic/util/dom', ['angular2/src/facade/async'], function (_export) {
    'use strict';

    var Promise, nativeRaf, nativeCancelRaf, raf, rafCancel, CSS;

    _export('rafPromise', rafPromise);

    _export('transitionEnd', transitionEnd);

    _export('animationStart', animationStart);

    _export('animationEnd', animationEnd);

    _export('ready', ready);

    _export('windowLoad', windowLoad);

    _export('pointerCoord', pointerCoord);

    _export('hasPointerMoved', hasPointerMoved);

    _export('hasFocus', hasFocus);

    function rafPromise() {
        return new Promise(function (resolve) {
            return raf(resolve);
        });
    }

    function transitionEnd(el) {
        return cssPromise(el, CSS.transitionEnd);
    }

    function animationStart(el, animationName) {
        return cssPromise(el, CSS.animationStart, animationName);
    }

    function animationEnd(el, animationName) {
        return cssPromise(el, CSS.animationEnd, animationName);
    }

    function cssPromise(el, eventNames, animationName) {
        return new Promise(function (resolve) {
            eventNames.split(' ').forEach(function (eventName) {
                el.addEventListener(eventName, onEvent);
            });
            function onEvent(ev) {
                if (ev.animationName && animationName) {
                    // do not resolve if a bubbled up ev.animationName
                    // is not the same as the passed in animationName arg
                    if (ev.animationName !== animationName) {
                        return;
                    }
                } else if (ev.target !== el) {
                    // do not resolve if the event's target element is not
                    // the same as the element the listener was added to
                    return;
                }
                ev.stopPropagation();
                eventNames.split(' ').forEach(function (eventName) {
                    el.removeEventListener(eventName, onEvent);
                });
                resolve(ev);
            }
        });
    }

    function ready(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    document.removeEventListener('DOMContentLoaded', completed, false);
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                document.addEventListener('DOMContentLoaded', completed, false);
                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function windowLoad(callback) {
        var promise = null;
        if (!callback) {
            // a callback wasn't provided, so let's return a promise instead
            promise = new Promise(function (resolve) {
                callback = resolve;
            });
        }
        if (document.readyState === 'complete') {
            callback();
        } else {
            (function () {
                var completed = function completed() {
                    window.removeEventListener('load', completed, false);
                    callback();
                };

                window.addEventListener('load', completed, false);
            })();
        }
        return promise;
    }

    function pointerCoord(ev) {
        // get coordinates for either a mouse click
        // or a touch depending on the given event
        var c = { x: 0, y: 0 };
        if (ev) {
            var touches = ev.touches && ev.touches.length ? ev.touches : [ev];
            var e = ev.changedTouches && ev.changedTouches[0] || touches[0];
            if (e) {
                c.x = e.clientX || e.pageX || 0;
                c.y = e.clientY || e.pageY || 0;
            }
        }
        return c;
    }

    function hasPointerMoved(threshold, startCoord, endCoord) {
        return startCoord && endCoord && (Math.abs(startCoord.x - endCoord.x) > threshold || Math.abs(startCoord.y - endCoord.y) > threshold);
    }

    function hasFocus(ele) {
        return !!(ele && (document.activeElement === ele.nativeElement || document.activeElement === ele));
    }

    return {
        setters: [function (_angular2SrcFacadeAsync) {
            Promise = _angular2SrcFacadeAsync.Promise;
        }],
        execute: function () {
            nativeRaf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
            nativeCancelRaf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;

            raf = nativeRaf || function (callback) {
                var timeCurrent = new Date().getTime(),
                    timeDelta = undefined;
                /* Dynamically set delay on a per-tick basis to match 60fps. */
                /* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
                timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
                timeLast = timeCurrent + timeDelta;
                return setTimeout(function () {
                    callback(timeCurrent + timeDelta);
                }, timeDelta);
            };

            _export('raf', raf);

            rafCancel = nativeRaf ? nativeCancelRaf : function (id) {
                return window.cancelTimeout(id);
            };

            _export('rafCancel', rafCancel);

            CSS = {};

            _export('CSS', CSS);

            (function () {
                // transform
                var i,
                    keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transform = keys[i];
                        break;
                    }
                }
                // transition
                keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
                for (i = 0; i < keys.length; i++) {
                    if (document.documentElement.style[keys[i]] !== undefined) {
                        CSS.transition = keys[i];
                        break;
                    }
                }
                // The only prefix we care about is webkit for transitions.
                var isWebkit = CSS.transition.indexOf('webkit') > -1;
                CSS.prefix = isWebkit ? '-webkit-' : '';
                // transition duration
                CSS.transitionDuration = (isWebkit ? '-webkit-' : '') + 'transition-duration';
                // To be sure transitionend works everywhere, include *both* the webkit and non-webkit events
                CSS.transitionEnd = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
            })();
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS.animation = 'WebkitAnimation';
                CSS.animationStart = 'webkitAnimationStart animationstart';
                CSS.animationEnd = 'webkitAnimationEnd animationend';
            } else {
                CSS.animation = 'animation';
                CSS.animationStart = 'animationstart';
                CSS.animationEnd = 'animationend';
            }
        }
    };
});
System.register('ionic/util/focus', ['./dom'], function (_export) {
    'use strict';

    var raf, ready, isKeyInputEnabled;

    function keyDown(ev) {
        if (!isKeyInputEnabled && ev.keyCode == 9) {
            isKeyInputEnabled = true;
            raf(enableKeyInput);
        }
    }
    function enableKeyInput() {
        document.body.classList[isKeyInputEnabled ? 'add' : 'remove']('key-input');
        if (isKeyInputEnabled) {
            document.addEventListener('mousedown', pointerDown);
            document.addEventListener('touchstart', pointerDown);
        } else {
            document.removeEventListener('mousedown', pointerDown);
            document.removeEventListener('touchstart', pointerDown);
        }
    }
    function pointerDown() {
        isKeyInputEnabled = false;
        raf(enableKeyInput);
    }
    return {
        setters: [function (_dom) {
            raf = _dom.raf;
            ready = _dom.ready;
        }],
        execute: function () {
            /* Focus Outline
             * --------------------------------------------------
             * When a keydown event happens, from a tab key, then the
             * 'key-input' class is added to the body element so focusable
             * elements have an outline. On a mousedown or touchstart
             * event then the 'key-input' class is removed.
             */
            isKeyInputEnabled = false;
            ready().then(function () {
                document.addEventListener('keydown', keyDown);
            });
        }
    };
});
System.register('ionic/util/util', [], function (_export) {
    // Simple noop function
    'use strict';

    var isBoolean, isString, isNumber, isFunction, isDefined, isUndefined, isBlank, isObject, isArray, uid, Log, array;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export('noop', noop);

    _export('clamp', clamp);

    _export('extend', extend);

    _export('merge', merge);

    _export('defaults', defaults);

    _export('pascalCaseToDashCase', pascalCaseToDashCase);

    _export('nextUid', nextUid);

    _export('getQuerystring', getQuerystring);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function noop() {}

    /**
     * Given a min and max, restrict the given number
     * to the range.
     * @param min the minimum
     * @param n the value
     * @param max the maximum
     */

    function clamp(min, n, max) {
        return Math.max(min, Math.min(n, max));
    }

    /**
     * Extend the destination with an arbitrary number of other objects.
     * @param dst the destination
     * @param ... the param objects
     */

    function extend(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), false);
    }

    /**
     * Do a deep extend (merge).
     * @param dst the destination
     * @param ... the param objects
     */

    function merge(dst) {
        return _baseExtend(dst, [].slice.call(arguments, 1), true);
    }

    function _baseExtend(dst, objs, deep) {
        for (var i = 0, ii = objs.length; i < ii; ++i) {
            var obj = objs[i];
            if (!obj || !isObject(obj) && !isFunction(obj)) continue;
            var keys = Object.keys(obj);
            for (var j = 0, jj = keys.length; j < jj; j++) {
                var key = keys[j];
                var src = obj[key];
                if (deep && isObject(src)) {
                    if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                    _baseExtend(dst[key], [src], true);
                } else {
                    dst[key] = src;
                }
            }
        }
        return dst;
    }
    /**
     * Apply default arguments if they don't exist in
     * the first object.
     * @param the destination to apply defaults to.
     */

    function defaults(dest) {
        for (var i = arguments.length - 1; i >= 1; i--) {
            var source = arguments[i] || {};
            for (var key in source) {
                if (source.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {
                    dest[key] = source[key];
                }
            }
        }
        return dest;
    }

    /**
     * Convert a string in the format thisIsAString to a slug format this-is-a-string
     */

    function pascalCaseToDashCase() {
        var str = arguments[0] === undefined ? '' : arguments[0];

        return str.charAt(0).toLowerCase() + str.substring(1).replace(/[A-Z]/g, function (match) {
            return '-' + match.toLowerCase();
        });
    }

    function nextUid() {
        return ++uid;
    }

    /**
     * Grab the query string param value for the given key.
     * @param key the key to look for
     */

    function getQuerystring(url, key) {
        var queryParams = {};
        if (url) {
            var startIndex = url.indexOf('?');
            if (startIndex !== -1) {
                var queries = url.slice(startIndex + 1).split('&');
                if (queries.length) {
                    queries.forEach(function (param) {
                        var split = param.split('=');
                        queryParams[split[0]] = split[1].split('#')[0];
                    });
                }
            }
            if (key) {
                return queryParams[key] || '';
            }
        }
        return queryParams;
    }

    return {
        setters: [],
        execute: function () {
            ;
            isBoolean = function isBoolean(val) {
                return typeof val === 'boolean';
            };

            _export('isBoolean', isBoolean);

            isString = function isString(val) {
                return typeof val === 'string';
            };

            _export('isString', isString);

            isNumber = function isNumber(val) {
                return typeof val === 'number';
            };

            _export('isNumber', isNumber);

            isFunction = function isFunction(val) {
                return typeof val === 'function';
            };

            _export('isFunction', isFunction);

            isDefined = function isDefined(val) {
                return typeof val !== 'undefined';
            };

            _export('isDefined', isDefined);

            isUndefined = function isUndefined(val) {
                return typeof val === 'undefined';
            };

            _export('isUndefined', isUndefined);

            isBlank = function isBlank(val) {
                return val === undefined || val === null;
            };

            _export('isBlank', isBlank);

            isObject = function isObject(val) {
                return typeof val === 'object';
            };

            _export('isObject', isObject);

            isArray = Array.isArray;

            _export('isArray', isArray);

            uid = 0;

            /**
             * A simple logger class.
             */

            Log = (function () {
                function Log() {
                    _classCallCheck(this, Log);
                }

                _createClass(Log, null, [{
                    key: 'log',
                    value: function log() {
                        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                            args[_key] = arguments[_key];
                        }

                        console.log.apply(console, args);
                    }
                }, {
                    key: 'info',
                    value: function info() {
                        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }

                        console.info.apply(console, args);
                    }
                }, {
                    key: 'warn',
                    value: function warn() {
                        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                            args[_key3] = arguments[_key3];
                        }

                        console.warn.apply(console, args);
                    }
                }, {
                    key: 'error',
                    value: function error() {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                            args[_key4] = arguments[_key4];
                        }

                        console.error.apply(console, args);
                    }
                }]);

                return Log;
            })();

            _export('Log', Log);

            array = {
                find: function find(arr, cb) {
                    for (var i = 0, ii = arr.length; i < ii; i++) {
                        if (cb(arr[i], i)) return arr[i];
                    }
                },
                remove: function remove(arr, itemOrIndex) {
                    var index = -1;
                    if (isNumber(itemOrIndex)) {
                        index = itemOrIndex;
                    } else {
                        index = arr.indexOf(itemOrIndex);
                    }
                    if (index < 0) {
                        return false;
                    }
                    arr.splice(index, 1);
                    return true;
                }
            };

            _export('array', array);
        }
    };
});
System.register('ionic/transitions/ios-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, OPACITY, TRANSLATEX, OFF_RIGHT, OFF_LEFT, CENTER, OFF_OPACITY, IOSTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 600;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            OPACITY = 'opacity';
            TRANSLATEX = 'translateX';
            OFF_RIGHT = '100%';
            OFF_LEFT = '-33%';
            CENTER = '0%';
            OFF_OPACITY = 0.8;

            IOSTransition = (function (_Transition) {
                function IOSTransition(nav, opts) {
                    _classCallCheck(this, IOSTransition);

                    _get(Object.getPrototypeOf(IOSTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves to center
                    this.enteringView.to(TRANSLATEX, CENTER).to(OPACITY, 1).before.setStyles({ zIndex: this.entering.index });
                    this.enteringTitle.fadeIn().to(TRANSLATEX, CENTER);
                    // leaving view moves off screen
                    this.leavingView.from(TRANSLATEX, CENTER).from(OPACITY, 1).before.setStyles({ zIndex: this.leaving.index });
                    this.leavingTitle.from(TRANSLATEX, CENTER).from(OPACITY, 1);
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEX, OFF_LEFT).from(OPACITY, OFF_OPACITY).to(OPACITY, 1);
                        this.enteringTitle.from(TRANSLATEX, OFF_LEFT);
                        this.leavingNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.leavingView.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 1);
                        this.leavingTitle.to(TRANSLATEX, OFF_RIGHT).to(OPACITY, 0);
                        if (this.leaving.enableBack() && this.viewWidth() > 200) {
                            var leavingBackButtonText = new Animation(this.leaving.backButtonTextElement());
                            leavingBackButtonText.fromTo(TRANSLATEX, CENTER, this.viewWidth() / 2 + 'px');
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEX, OFF_RIGHT).from(OPACITY, 1);
                        this.enteringNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.enteringTitle.from(TRANSLATEX, OFF_RIGHT);
                        this.leavingView.to(TRANSLATEX, OFF_LEFT).to(OPACITY, OFF_OPACITY);
                        this.leavingTitle.to(TRANSLATEX, OFF_LEFT).to(OPACITY, 0);
                        if (this.entering.enableBack() && this.viewWidth() > 200) {
                            var enteringBackButtonText = new Animation(this.entering.backButtonTextElement());
                            enteringBackButtonText.fromTo(TRANSLATEX, this.viewWidth() / 2 + 'px', CENTER);
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                _inherits(IOSTransition, _Transition);

                return IOSTransition;
            })(Transition);

            Transition.register('ios', IOSTransition);
        }
    };
});
System.register('ionic/transitions/md-transition', ['./transition', '../animations/animation'], function (_export) {
    'use strict';

    var Transition, Animation, DURATION, EASING, TRANSLATEY, OFF_BOTTOM, CENTER, MaterialTransition;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_transition) {
            Transition = _transition.Transition;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            DURATION = 300;
            EASING = 'cubic-bezier(0.36,0.66,0.04,1)';
            TRANSLATEY = 'translateY';
            OFF_BOTTOM = '5%';
            CENTER = '0%';

            MaterialTransition = (function (_Transition) {
                function MaterialTransition(nav, opts) {
                    _classCallCheck(this, MaterialTransition);

                    _get(Object.getPrototypeOf(MaterialTransition.prototype), 'constructor', this).call(this, nav, opts);
                    // global duration and easing for all child animations
                    this.duration(DURATION);
                    this.easing(EASING);
                    // entering item moves in bottom to center
                    this.enteringView.to(TRANSLATEY, CENTER).before.setStyles({ zIndex: this.entering.index });
                    // entering title fades in
                    this.enteringTitle.fadeIn();
                    // leaving view stays put
                    this.leavingView.before.setStyles({ zIndex: this.leaving.index });
                    // leaving title fades out
                    this.leavingTitle.fadeOut();
                    // set properties depending on direction
                    if (opts.direction === 'back') {
                        // back direction
                        this.enteringView.from(TRANSLATEY, CENTER);
                        this.leavingNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        this.leavingTitle.fadeOut();
                        // leaving view goes center to bottom
                        this.leavingView.fromTo(TRANSLATEY, CENTER, OFF_BOTTOM).fadeOut();
                        if (this.leaving.enableBack()) {
                            var leavingBackButtonText = new Animation(this.leaving.backButtonTextElement());
                            leavingBackButtonText.fadeOut();
                            this.leavingNavbar.add(leavingBackButtonText);
                        }
                    } else {
                        // forward direction
                        this.enteringView.from(TRANSLATEY, OFF_BOTTOM).fadeIn();
                        this.enteringNavbar.before.addClass('transparent-navbar').after.removeClass('transparent-navbar');
                        if (this.entering.enableBack()) {
                            var enteringBackButtonText = new Animation(this.entering.backButtonTextElement());
                            enteringBackButtonText.fadeIn();
                            this.enteringNavbar.add(enteringBackButtonText);
                        }
                    }
                }

                _inherits(MaterialTransition, _Transition);

                return MaterialTransition;
            })(Transition);

            Transition.register('md', MaterialTransition);
        }
    };
});
System.register('ionic/transitions/transition', ['../animations/animation'], function (_export) {
    'use strict';

    var Animation, SHOW_NAVBAR_CSS, SHOW_VIEW_CSS, SHOW_BACK_BUTTON, TransitionRegistry, Transition;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }],
        execute: function () {
            SHOW_NAVBAR_CSS = 'show-navbar';
            SHOW_VIEW_CSS = 'show-view';
            SHOW_BACK_BUTTON = 'show-back-button';
            TransitionRegistry = {};

            Transition = (function (_Animation) {
                function Transition(nav, opts) {
                    _classCallCheck(this, Transition);

                    _get(Object.getPrototypeOf(Transition.prototype), 'constructor', this).call(this);
                    // get the entering and leaving items
                    var enteringItem = this.entering = nav.getStagedEnteringItem();
                    var leavingItem = this.leaving = nav.getStagedLeavingItem();
                    // create animation for the entering item's "ion-view" element
                    this.enteringView = new Animation(enteringItem.viewElementRef());
                    this.enteringView.before.addClass(SHOW_VIEW_CSS);
                    this.enteringView.onPlay(function () {
                        enteringItem.postRender();
                    });
                    this.add(this.enteringView);
                    if (opts.navbar !== false) {
                        var enteringNavbar = this.enteringNavbar = new Animation(enteringItem.navbarElement());
                        enteringNavbar.before.addClass(SHOW_NAVBAR_CSS);
                        if (enteringItem.enableBack()) {
                            // only animate in the back button if the entering view has it enabled
                            var enteringBackButton = this.enteringBackButton = new Animation(enteringItem.backButtonElement());
                            enteringBackButton.before.addClass(SHOW_BACK_BUTTON).fadeIn();
                            enteringNavbar.add(enteringBackButton);
                        }
                        this.enteringTitle = new Animation(enteringItem.titleElement());
                        enteringNavbar.add(this.enteringTitle);
                        this.add(enteringNavbar);
                        this.enteringNavbarItems = new Animation(enteringItem.navbarItemElements());
                        this.enteringNavbarItems.fadeIn();
                        enteringNavbar.add(this.enteringNavbarItems);
                    }
                    if (leavingItem) {
                        // setup the leaving item if one exists (initial viewing wouldn't have a leaving item)
                        this.leavingView = new Animation(leavingItem.viewElementRef());
                        this.leavingView.after.removeClass(SHOW_VIEW_CSS);
                        var leavingNavbar = this.leavingNavbar = new Animation(leavingItem.navbarElement());
                        leavingNavbar.after.removeClass(SHOW_NAVBAR_CSS);
                        var leavingBackButton = this.leavingBackButton = new Animation(leavingItem.backButtonElement());
                        leavingBackButton.after.removeClass(SHOW_BACK_BUTTON).fadeOut();
                        leavingNavbar.add(leavingBackButton);
                        this.leavingTitle = new Animation(leavingItem.titleElement());
                        leavingNavbar.add(this.leavingTitle);
                        this.leavingNavbarItems = new Animation(leavingItem.navbarItemElements());
                        this.leavingNavbarItems.fadeOut();
                        leavingNavbar.add(this.leavingNavbarItems);
                        this.add(this.leavingView, leavingNavbar);
                    }
                }

                _inherits(Transition, _Animation);

                _createClass(Transition, [{
                    key: 'viewWidth',
                    value: function viewWidth() {
                        // TODO: MAKE MORE BETTER
                        return this._w || (this._w = this.leaving && this.leaving.viewElementRef().nativeElement.offsetWidth);
                    }
                }], [{
                    key: 'create',

                    /*
                     STATIC CLASSES
                     */
                    value: function create(nav) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        //const name = opts.animation || IonicConfig.global.setting('viewTransition') || 'ios';
                        var name = opts.animation || 'ios';
                        var TransitionClass = TransitionRegistry[name];
                        if (!TransitionClass) {
                            // transition wasn't found, default to a 'none' transition
                            // which doesn't animate anything, just shows and hides
                            TransitionClass = Transition;
                        }
                        return new TransitionClass(nav, opts);
                    }
                }, {
                    key: 'register',
                    value: function register(name, TransitionClass) {
                        TransitionRegistry[name] = TransitionClass;
                    }
                }]);

                return Transition;
            })(Animation);

            _export('Transition', Transition);
        }
    };
});
System.register("ionic/components/action-menu/action-menu", ["angular2/angular2", "../button/button", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    /**
    * @ngdoc service
    * @name ActionMenu
    * @module ionic
    * @description
    * The ActionMenu is a modal menu with options to select based on an action.
    */
    "use strict";

    var View, Injectable, NgFor, NgIf, CSSClass, TapClick, Overlay, Animation, util, __decorate, __metadata, ActionMenuDirective, ActionMenu, OVERLAY_TYPE, ActionMenuAnimation, ActionMenuSlideIn, ActionMenuSlideOut;

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            NgFor = _angular2Angular2.NgFor;
            NgIf = _angular2Angular2.NgIf;
            CSSClass = _angular2Angular2.CSSClass;
        }, function (_buttonButton) {
            TapClick = _buttonButton.TapClick;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ActionMenuDirective = (function () {
                var _class = function ActionMenuDirective() {
                    _classCallCheck(this, _class);
                };

                _createClass(_class, [{
                    key: "_cancel",
                    value: function _cancel() {
                        this.cancel && this.cancel();
                        return this.overlayRef.close();
                    }
                }, {
                    key: "_destructive",
                    value: function _destructive() {
                        var shouldClose = this.destructiveButtonClicked();
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_buttonClicked",
                    value: function _buttonClicked(index) {
                        var shouldClose = this.buttonClicked(index);
                        if (shouldClose === true) {
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return _class;
            })();

            ActionMenuDirective = __decorate([View({
                template: "<backdrop (click)=\"_cancel()\" tappable></backdrop>" + "<action-menu-wrapper>" + "<div class=\"action-menu-container\">" + "<div class=\"action-menu-group action-menu-options\">" + "<div class=\"action-menu-title\" *ng-if=\"titleText\">{{titleText}}</div>" + "<button (^click)=\"_buttonClicked(index)\" *ng-for=\"#b of buttons; #index = index\" class=\"action-menu-option\">" + "<i class=\"icon\" [class]=\"b.icon\" *ng-if=\"b.icon\"></i> " + "{{b.text}}" + "</button>" + "<button *ng-if=\"destructiveText\" (click)=\"_destructive()\" class=\"destructive action-menu-destructive\">" + "<i class=\"icon\" [class]=\"destructiveIcon\" *ng-if=\"destructiveIcon\"></i> " + "{{destructiveText}}</button>" + "</div>" + "<div class=\"action-menu-group action-menu-cancel\" *ng-if=\"cancelText\">" + "<button (click)=\"_cancel()\"><i class=\"icon\" [class]=\"cancelIcon\"></i> {{cancelText}}</button>" + "</div>" + "</div>" + "</action-menu-wrapper>",
                directives: [NgFor, NgIf, CSSClass, TapClick]
            }), __metadata("design:paramtypes", [])], ActionMenuDirective);

            ActionMenu = (function (_Overlay) {
                var _class2 = function ActionMenu() {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class2, _Overlay);

                _createClass(_class2, [{
                    key: "open",

                    /**
                     * Create and open a new Action Menu. This is the
                     * public API, and most often you will only use ActionMenu.open()
                     *
                     * @return Promise that resolves when the action menu is open.
                     */
                    value: function open() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        var defaults = {
                            enterAnimation: "action-menu-slide-in",
                            leaveAnimation: "action-menu-slide-out"
                        };
                        var contextDefaults = {
                            cancelIcon: "ion-close",
                            destructiveIcon: "ion-trash-a"
                        };
                        var context = util.extend(contextDefaults, opts);
                        return this.create(OVERLAY_TYPE, ActionMenuDirective, util.extend(defaults, opts), context);
                    }
                }, {
                    key: "get",
                    value: function get() {
                        return Modal.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class2;
            })(Overlay);

            _export("ActionMenu", ActionMenu);

            _export("ActionMenu", ActionMenu = __decorate([Injectable(), __metadata("design:paramtypes", [])], ActionMenu));
            OVERLAY_TYPE = "action-menu";

            /**
             * Animations for action sheet
             */

            ActionMenuAnimation = (function (_Animation) {
                function ActionMenuAnimation(element) {
                    _classCallCheck(this, ActionMenuAnimation);

                    _get(Object.getPrototypeOf(ActionMenuAnimation.prototype), "constructor", this).call(this, element);
                    this.easing("cubic-bezier(.36, .66, .04, 1)").duration(400);
                    this.backdrop = new Animation(element.querySelector("backdrop"));
                    this.wrapper = new Animation(element.querySelector("action-menu-wrapper"));
                    this.add(this.backdrop, this.wrapper);
                }

                _inherits(ActionMenuAnimation, _Animation);

                return ActionMenuAnimation;
            })(Animation);

            ActionMenuSlideIn = (function (_ActionMenuAnimation) {
                function ActionMenuSlideIn(element) {
                    _classCallCheck(this, ActionMenuSlideIn);

                    _get(Object.getPrototypeOf(ActionMenuSlideIn.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo("opacity", 0, 0.4);
                    this.wrapper.fromTo("translateY", "100%", "0%");
                }

                _inherits(ActionMenuSlideIn, _ActionMenuAnimation);

                return ActionMenuSlideIn;
            })(ActionMenuAnimation);

            Animation.register("action-menu-slide-in", ActionMenuSlideIn);

            ActionMenuSlideOut = (function (_ActionMenuAnimation2) {
                function ActionMenuSlideOut(element) {
                    _classCallCheck(this, ActionMenuSlideOut);

                    _get(Object.getPrototypeOf(ActionMenuSlideOut.prototype), "constructor", this).call(this, element);
                    this.backdrop.fromTo("opacity", 0.4, 0);
                    this.wrapper.fromTo("translateY", "0%", "100%");
                }

                _inherits(ActionMenuSlideOut, _ActionMenuAnimation2);

                return ActionMenuSlideOut;
            })(ActionMenuAnimation);

            Animation.register("action-menu-slide-out", ActionMenuSlideOut);
        }
    };
});
System.register("ionic/components/app/app", ["angular2/angular2", "../../routing/router", "../../config/config", "../../platform/platform", "../action-menu/action-menu", "../modal/modal", "../popup/popup", "../form/focus-holder"], function (_export) {
    "use strict";

    var Component, View, bootstrap, ElementRef, NgZone, bind, DynamicComponentLoader, Injector, IonicRouter, IonicConfig, Platform, ActionMenu, Modal, Popup, FocusHolder, __decorate, __metadata, IonicApp, RootAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    _export("ionicBootstrap", ionicBootstrap);

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function initApp(window, document, config) {
        // create the base IonicApp
        var app = new IonicApp();
        app.isRTL(document.documentElement.getAttribute("dir") == "rtl");
        // load all platform data
        // Platform is a global singleton
        Platform.url(window.location.href);
        Platform.userAgent(window.navigator.userAgent);
        Platform.navigatorPlatform(window.navigator.platform);
        Platform.load(config);
        // on resize be sure to clear out existing window dimensions
        window.addEventListener("resize", Platform.winResize);
        return app;
    }

    function ionicBootstrap(rootComponentType, config, router) {
        return new Promise(function (resolve) {
            try {
                (function () {
                    // get the user config, or create one if wasn't passed in
                    if (typeof config !== IonicConfig) {
                        config = new IonicConfig(config);
                    }
                    // create the base IonicApp
                    var app = initApp(window, document, config);
                    // copy default platform settings into the user config platform settings
                    // user config platform settings should override default platform settings
                    config.setPlatform(Platform);
                    // config and platform settings have been figured out
                    // apply the correct CSS to the app
                    app.applyBodyCss(document.body, Platform, config);
                    // prepare the ready promise to fire....when ready
                    Platform.prepareReady(config);
                    // setup router
                    if (typeof router !== IonicRouter) {
                        router = new IonicRouter(router);
                    }
                    router.app(app);
                    // TODO: don't wire these together
                    app.router = router;
                    // TODO: probs need a better way to inject global injectables
                    var actionMenu = new ActionMenu(app, config);
                    var modal = new Modal(app, config);
                    var popup = new Popup(app, config);
                    // add injectables that will be available to all child components
                    var appBindings = Injector.resolve([bind(IonicApp).toValue(app), bind(IonicConfig).toValue(config), bind(IonicRouter).toValue(router), bind(ActionMenu).toValue(actionMenu), bind(Modal).toValue(modal), bind(Popup).toValue(popup)]);
                    bootstrap(rootComponentType, appBindings).then(function (appRef) {
                        app.load(appRef);
                        // Adding a anchor to add overlays off of...huh??
                        var elementRefs = appRef._hostComponent.hostView._view.elementRefs;
                        var lastElementRef = elementRefs[1];
                        var injector = lastElementRef.parentView._view.rootElementInjectors[0]._injector;
                        var loader = injector.get(DynamicComponentLoader);
                        loader.loadNextToLocation(RootAnchor, lastElementRef).then(function () {
                            // append the focus holder if its needed
                            if (config.setting("keyboardScrollAssist")) {
                                app.appendComponent(FocusHolder).then(function (ref) {
                                    app.focusHolder(ref.instance);
                                });
                            }
                        })["catch"](function (err) {
                            console.error(err);
                        });
                        router.load(window, app, config).then(function () {
                            // resolve that the app has loaded
                            resolve(app);
                        });
                    })["catch"](function (err) {
                        console.error("ionicBootstrap", err);
                    });
                })();
            } catch (err) {
                console.error(err);
            }
        });
    }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            bootstrap = _angular2Angular2.bootstrap;
            ElementRef = _angular2Angular2.ElementRef;
            NgZone = _angular2Angular2.NgZone;
            bind = _angular2Angular2.bind;
            DynamicComponentLoader = _angular2Angular2.DynamicComponentLoader;
            Injector = _angular2Angular2.Injector;
        }, function (_routingRouter) {
            IonicRouter = _routingRouter.IonicRouter;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }, function (_actionMenuActionMenu) {
            ActionMenu = _actionMenuActionMenu.ActionMenu;
        }, function (_modalModal) {
            Modal = _modalModal.Modal;
        }, function (_popupPopup) {
            Popup = _popupPopup.Popup;
        }, function (_formFocusHolder) {
            FocusHolder = _formFocusHolder.FocusHolder;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            IonicApp = (function () {
                function IonicApp() {
                    _classCallCheck(this, IonicApp);

                    this.overlays = [];
                    // Our component registry map
                    this.components = {};
                    this._activeViewId = null;
                }

                _createClass(IonicApp, [{
                    key: "load",
                    value: function load(appRef) {
                        this.ref(appRef);
                        this._zone = appRef.injector.get(NgZone);
                    }
                }, {
                    key: "focusHolder",
                    value: function focusHolder(val) {
                        if (arguments.length) {
                            this._focusHolder = val;
                        }
                        return this._focusHolder;
                    }
                }, {
                    key: "title",
                    value: function title(val) {
                        document.title = val;
                    }
                }, {
                    key: "ref",
                    value: function ref(val) {
                        if (arguments.length) {
                            this._ref = val;
                        }
                        return this._ref;
                    }
                }, {
                    key: "zoneRun",
                    value: function zoneRun(fn) {
                        this._zone.run(fn);
                    }
                }, {
                    key: "stateChange",
                    value: function stateChange(type, activeView) {
                        if (this._activeViewId !== activeView.id) {
                            this.router.stateChange(type, activeView);
                            this._activeViewId = activeView.id;
                        }
                    }
                }, {
                    key: "stateClear",
                    value: function stateClear() {
                        this.router.stateClear();
                    }
                }, {
                    key: "register",

                    /**
                     * Register a known component with a key, for easy lookups later.
                     */
                    value: function register(key, component) {
                        this.components[key] = component;
                        // TODO(mlynch): We need to track the lifecycle of this component to remove it onDehydrate
                    }
                }, {
                    key: "getComponent",

                    /**
                     * Get the component for the given key.
                     */
                    value: function getComponent(key) {
                        return this.components[key];
                    }
                }, {
                    key: "appendComponent",

                    /**
                     * Create and append the given component into the root
                     * element of the app.
                     *
                     * @param Component the component to create and insert
                     * @return Promise that resolves with the ContainerRef created
                     */
                    value: function appendComponent(componentType) {
                        var context = arguments[1] === undefined ? null : arguments[1];

                        return this.rootAnchor.append(componentType);
                    }
                }, {
                    key: "applyBodyCss",
                    value: function applyBodyCss(bodyEle, platform, config) {
                        var versions = platform.versions();
                        platform.platforms().forEach(function (platformName) {
                            // platform-ios
                            var platformClass = "platform-" + platformName;
                            bodyEle.classList.add(platformClass);
                            var platformVersion = versions[platformName];
                            if (platformVersion) {
                                // platform-ios_8
                                platformClass += "_" + platformVersion.major;
                                bodyEle.classList.add(platformClass);
                                // platform-ios_8_3
                                bodyEle.classList.add(platformClass + "_" + platformVersion.minor);
                            }
                        });
                        bodyEle.setAttribute("mode", config.setting("mode"));
                    }
                }, {
                    key: "isRTL",
                    value: function isRTL(val) {
                        if (arguments.length) {
                            this._rtl = val;
                        }
                        return this._rtl;
                    }
                }, {
                    key: "injector",
                    get: function get() {
                        return this._ref.injector;
                    }
                }]);

                return IonicApp;
            })();

            _export("IonicApp", IonicApp);

            RootAnchor = (function () {
                var _class = function RootAnchor(app, elementRef, loader) {
                    _classCallCheck(this, _class);

                    this.elementRef = elementRef;
                    this.loader = loader;
                    app.rootAnchor = this;
                };

                _createClass(_class, [{
                    key: "append",
                    value: function append(componentType) {
                        return this.loader.loadNextToLocation(componentType, this.elementRef)["catch"](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return _class;
            })();

            RootAnchor = __decorate([Component({
                selector: "root-anchor"
            }), View({
                template: ""
            }), __metadata("design:paramtypes", [IonicApp, typeof ElementRef !== "undefined" && ElementRef || Object, typeof DynamicComponentLoader !== "undefined" && DynamicComponentLoader || Object])], RootAnchor);
        }
    };
});
System.register("ionic/components/button/button", ["angular2/angular2", "../../config/config", "../../util/activator", "../../util/dom"], function (_export) {
    "use strict";

    var Directive, ElementRef, Optional, Ancestor, NgZone, IonicConfig, Activator, dom, __decorate, __metadata, __param, Button, TapDisabled, TapClick;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            NgZone = _angular2Angular2.NgZone;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilActivator) {
            Activator = _utilActivator.Activator;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Button = (function () {
                var _class = function Button() {
                    _classCallCheck(this, _class);

                    this.iconLeft = this.iconRight = this.iconOnly = false;
                };

                _createClass(_class, [{
                    key: "registerIcon",
                    value: function registerIcon(icon) {
                        this.iconLeft = icon.iconLeft;
                        this.iconRight = icon.iconRight;
                        this.iconOnly = icon.iconOnly;
                    }
                }]);

                return _class;
            })();

            _export("Button", Button);

            _export("Button", Button = __decorate([Directive({
                selector: "button,[button]",
                host: {
                    "[class.icon-left]": "iconLeft",
                    "[class.icon-right]": "iconRight",
                    "[class.icon-only]": "iconOnly"
                }
            }), __metadata("design:paramtypes", [])], Button));

            TapDisabled = (function () {
                var _class2 = function TapDisabled() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("TapDisabled", TapDisabled);

            _export("TapDisabled", TapDisabled = __decorate([Directive({
                selector: "[tap-disabled]"
            }), __metadata("design:paramtypes", [])], TapDisabled));

            TapClick = (function () {
                var _class3 = function TapClick(elementRef, config, ngZone, tapDisabled) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.nativeElement;
                    this.tapEnabled = !tapDisabled;
                    this.tapPolyfill = config.setting("tapPolyfill");
                    this.zone = ngZone;
                    var self = this;
                    self.pointerMove = function (ev) {
                        var moveCoord = dom.pointerCoord(ev);
                        console.log("pointerMove", moveCoord, self.start);
                        if (dom.hasPointerMoved(10, self.start, moveCoord)) {
                            self.pointerCancel();
                        }
                    };
                };

                _createClass(_class3, [{
                    key: "touchStart",
                    value: function touchStart(ev) {
                        this.pointerStart(ev);
                    }
                }, {
                    key: "touchEnd",
                    value: function touchEnd(ev) {
                        var self = this;
                        if (this.tapPolyfill && this.tapEnabled) {
                            var endCoord = dom.pointerCoord(ev);
                            this.disableClick = true;
                            this.zone.runOutsideAngular(function () {
                                clearTimeout(self.disableTimer);
                                self.disableTimer = setTimeout(function () {
                                    self.disableClick = false;
                                }, 600);
                            });
                            if (this.start && !dom.hasPointerMoved(3, this.start, endCoord)) {
                                var clickEvent = document.createEvent("MouseEvents");
                                clickEvent.initMouseEvent("click", true, true, window, 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);
                                clickEvent.isIonicTap = true;
                                this.ele.dispatchEvent(clickEvent);
                            }
                        }
                        this.pointerEnd();
                    }
                }, {
                    key: "mouseDown",
                    value: function mouseDown(ev) {
                        if (this.disableClick) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        } else {
                            this.pointerStart(ev);
                        }
                    }
                }, {
                    key: "mouseUp",
                    value: function mouseUp(ev) {
                        if (this.disableClick) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                        this.pointerEnd();
                    }
                }, {
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        var _this = this;

                        this.start = dom.pointerCoord(ev);
                        this.zone.runOutsideAngular(function () {
                            Activator.start(ev.currentTarget);
                            Activator.moveListeners(_this.pointerMove, true);
                        });
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd() {
                        var _this2 = this;

                        this.zone.runOutsideAngular(function () {
                            Activator.end();
                            Activator.moveListeners(_this2.pointerMove, false);
                        });
                    }
                }, {
                    key: "pointerCancel",
                    value: function pointerCancel() {
                        var _this3 = this;

                        this.start = null;
                        this.zone.runOutsideAngular(function () {
                            Activator.clear();
                            Activator.moveListeners(_this3.pointerMove, false);
                        });
                    }
                }, {
                    key: "allowClick",
                    value: function allowClick(ev) {
                        if (!ev.isIonicTap) {
                            if (this.disableClick || !this.start) {
                                return false;
                            }
                        }
                        return true;
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        if (!this.allowClick(ev)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.ele = null;
                    }
                }]);

                return _class3;
            })();

            _export("TapClick", TapClick);

            _export("TapClick", TapClick = __decorate([Directive({
                selector: "button,[button],[tappable],ion-checkbox",
                host: {
                    "(^touchstart)": "touchStart($event)",
                    "(^touchend)": "touchEnd($event)",
                    "(^touchcancel)": "pointerCancel()",
                    "(^mousedown)": "mouseDown($event)",
                    "(^mouseup)": "mouseUp($event)",
                    "(^click)": "click($event)"
                }
            }), __param(3, Optional()), __param(3, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof NgZone !== "undefined" && NgZone || Object, TapDisabled])], TapClick));
        }
    };
});
System.register("ionic/components/aside/aside", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations", "./extensions/types", "./extensions/gestures", "ionic/util"], function (_export) {
    "use strict";

    var View, EventEmitter, ElementRef, Ion, IonicConfig, IonicComponent, types, gestures, dom, __decorate, __metadata, Aside;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            EventEmitter = _angular2Angular2.EventEmitter;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_extensionsTypes) {
            types = _extensionsTypes;
        }, function (_extensionsGestures) {
            gestures = _extensionsGestures;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * TODO (?) add docs about how to have a root aside and a nested aside, then hide the root one
             */

            Aside = (function (_Ion) {
                var _class = function Aside(elementRef, ionicConfig) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.opening = new EventEmitter("opening");
                    // TODO: Use Animation Class
                    this.getNativeElement().addEventListener("transitionend", function (ev) {
                        _this.setChanging(false);
                    });
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        this.contentElement = this.content instanceof Node ? this.content : this.content.getNativeElement();
                        this.gestureDelegate = this.getDelegate("gesture");
                        this.typeDelegate = this.getDelegate("type");
                    }
                }, {
                    key: "getContentElement",
                    value: function getContentElement() {
                        return this.contentElement;
                    }
                }, {
                    key: "setOpenAmt",
                    value: function setOpenAmt(v) {
                        this.opening.next(v);
                    }
                }, {
                    key: "setTransform",
                    value: function setTransform(transform) {
                        this.typeDelegate.setTransform(transform);
                    }
                }, {
                    key: "setSliding",
                    value: function setSliding(isSliding) {
                        if (isSliding !== this.isSliding) {
                            this.typeDelegate.setSliding(isSliding);
                        }
                    }
                }, {
                    key: "setChanging",
                    value: function setChanging(isChanging) {
                        if (isChanging !== this.isChanging) {
                            this.isChanging = isChanging;
                            this.getNativeElement().classList[isChanging ? "add" : "remove"]("changing");
                        }
                    }
                }, {
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this2 = this;

                        console.log("SET OPEN", isOpen);
                        console.trace();
                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            this.setChanging(true);
                            // Set full or closed amount
                            this.setOpenAmt(isOpen ? 1 : 0);
                            return dom.rafPromise().then(function () {
                                _this2.typeDelegate.setOpen(isOpen);
                            });
                        }
                    }
                }, {
                    key: "open",
                    value: function open() {
                        return this.setOpen(true);
                    }
                }, {
                    key: "close",
                    value: function close() {
                        return this.setOpen(false);
                    }
                }, {
                    key: "toggle",
                    value: function toggle() {
                        return this.setOpen(!this.isOpen);
                    }
                }]);

                return _class;
            })(Ion);

            _export("Aside", Aside);

            _export("Aside", Aside = __decorate([IonicComponent({
                selector: "ion-aside",
                properties: ["content", "dragThreshold"],
                defaultProperties: {
                    "side": "left",
                    "type": "reveal"
                },
                delegates: {
                    gesture: [[function (instance) {
                        return instance.side == "top";
                    }, gestures.TopAsideGesture], [function (instance) {
                        return instance.side == "bottom";
                    }, gestures.BottomAsideGesture], [function (instance) {
                        return instance.side == "right";
                    }, gestures.RightAsideGesture], [function (instance) {
                        return instance.side == "left";
                    }, gestures.LeftAsideGesture]],
                    type: [[function (instance) {
                        return instance.type == "overlay";
                    }, types.AsideTypeOverlay], [function (instance) {
                        return instance.type == "reveal";
                    }, types.AsideTypeReveal], [function (instance) {
                        return instance.type == "push";
                    }, types.AsideTypePush]]
                },
                events: ["opening"]
            }), View({
                template: "<ng-content></ng-content>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Aside));
        }
    };
});
System.register('ionic/components/aside/config', ['ionic/config/component', 'ionic/components/aside/aside'], function (_export) {
    'use strict';

    var ComponentConfig, Aside, AsideConfig;
    return {
        setters: [function (_ionicConfigComponent) {
            ComponentConfig = _ionicConfigComponent.ComponentConfig;
        }, function (_ionicComponentsAsideAside) {
            Aside = _ionicComponentsAsideAside.Aside;
        }],
        execute: function () {
            AsideConfig = new ComponentConfig(Aside);

            _export('AsideConfig', AsideConfig);

            AsideConfig.classes('side', 'type');
            AsideConfig.delegate('gesture').when({ side: 'left' }, gestures.LeftAsideGesture).when({ side: 'right' }, gestures.RightAsideGesture).when({ side: 'top' }, gestures.TopAsideGesture).when({ side: 'bottom' }, gestures.BottomAsideGesture);
            AsideConfig.delegate('type').when({ type: 'overlay' }, types.AsideTypeOverlay).when({ type: 'push' }, types.AsideTypePush).when({ type: 'reveal' }, types.AsideTypeReveal);
            AsideConfig.platform('android').defaults({ type: 'overlay' });
            AsideConfig.platform('ios').defaults({ type: 'reveal' });
        }
    };
});
System.register("ionic/components/card/card", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, __decorate, __metadata, Card;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Card = (function (_Ion) {
                var _class = function Card(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class, _Ion);

                return _class;
            })(Ion);

            _export("Card", Card);

            _export("Card", Card = __decorate([IonicDirective({
                selector: "ion-card",
                host: {
                    "class": "list"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Card));
        }
    };
});
System.register("ionic/components/checkbox/checkbox", ["angular2/angular2", "../form/input", "../../config/config", "../../config/annotations", "../button/button"], function (_export) {
    "use strict";

    var ElementRef, Optional, NgControl, IonInputItem, IonicConfig, IonicComponent, IonicView, TapClick, __decorate, __metadata, __param, Checkbox;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_formInput) {
            IonInputItem = _formInput.IonInputItem;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_buttonButton) {
            TapClick = _buttonButton.TapClick;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Checkbox = (function (_IonInputItem) {
                var _class = function Checkbox(cd, elementRef, config, tapClick) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.tapClick = tapClick;
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.cd = cd;
                    if (cd) cd.valueAccessor = this;
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        this.labelId = "label-" + this.id;
                    }
                }, {
                    key: "onAllChangesDone",
                    value: function onAllChangesDone() {
                        this.input.checked = this.checked;
                        this.input.disabled = this.disabled;
                        this.input.value = this.value;
                    }
                }, {
                    key: "toggle",
                    value: function toggle() {
                        this.input.checked = this.checked = !this.input.checked;
                        this.onChange(this.checked);
                    }
                }, {
                    key: "click",
                    value: function click(ev) {
                        if (this.tapClick.allowClick(ev)) {
                            ev.preventDefault();
                            ev.stopPropagation();
                            this.toggle();
                        }
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(modelValue) {
                        this.input.checked = modelValue;
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Checkbox", Checkbox);

            _export("Checkbox", Checkbox = __decorate([IonicComponent({
                selector: "ion-checkbox",
                properties: ["value", "checked", "disabled"],
                host: {
                    "class": "item",
                    "role": "checkbox",
                    "[attr.aria-checked]": "input.checked",
                    "[attr.aria-disabled]": "input.disabled",
                    "[attr.aria-labelledby]": "labelId",
                    "(^click)": "click($event)"
                },
                exportAs: "checkbox"
            }), IonicView({
                template: "<div class=\"item-media media-checkbox\">" + "<input type=\"checkbox\" aria-hidden=\"true\">" + "<div class=\"checkbox-icon\"></div>" + "</div>" + "<div class=\"item-content\" id=\"{{labelId}}\">" + "<ng-content></ng-content>" + "</div>"
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof TapClick !== "undefined" && TapClick || Object])], Checkbox));
        }
    };
});
System.register("ionic/components/content/content", ["angular2/angular2", "../ion", "../../config/config", "../../animations/scroll-to"], function (_export) {
    "use strict";

    var Component, View, ElementRef, Ion, IonicConfig, ScrollTo, __decorate, __metadata, Content;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_animationsScrollTo) {
            ScrollTo = _animationsScrollTo.ScrollTo;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Content = (function (_Ion) {
                var _class = function Content(elementRef, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.scrollPadding = config.setting("keyboardScrollAssist");
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        this.scrollElement = this.getNativeElement().children[0];
                    }
                }, {
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("scroll", handler);
                        return function () {
                            _this.scrollElement.removeEventListener("scroll", handler);
                        };
                    }
                }, {
                    key: "addTouchMoveListener",
                    value: function addTouchMoveListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("touchmove", handler);
                        return function () {
                            _this2.scrollElement.removeEventListener("touchmove", handler);
                        };
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y, duration, tolerance) {
                        if (this._scrollTo) {
                            this._scrollTo.dispose();
                        }
                        this._scrollTo = new ScrollTo(this.scrollElement);
                        return this._scrollTo.start(x, y, duration, tolerance);
                    }
                }, {
                    key: "scrollPadding",
                    get: function get() {
                        return this._sp;
                    },
                    set: function set(val) {
                        this._sp = val;
                    }
                }]);

                return _class;
            })(Ion);

            _export("Content", Content);

            _export("Content", Content = __decorate([Component({
                selector: "ion-content",
                properties: ["parallax"],
                host: _defineProperty({}, "[class.scroll-padding]", "scrollPadding")
            }), View({
                template: "<div class=\"scroll-content\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Content));
        }
    };
});
System.register("ionic/components/form/focus-holder", ["angular2/angular2", "./input"], function (_export) {
    "use strict";

    var Component, Directive, View, Ancestor, ElementRef, forwardRef, IonInput, __decorate, __metadata, __param, FocusHolder, FocusInput, PREVIOUS_TAB_INDEX, ACTIVE_TAB_INDEX, NEXT_TAB_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_input) {
            IonInput = _input.IonInput;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            FocusHolder = (function () {
                var _class = function FocusHolder() {
                    _classCallCheck(this, _class);

                    this.i = [];
                };

                _createClass(_class, [{
                    key: "setFocusHolder",
                    value: function setFocusHolder(inputType) {
                        IonInput.clearTabIndexes();
                        this.i[1].tabIndex = ACTIVE_TAB_INDEX;
                        this.i[1].type = inputType;
                        this.i[1].focus();
                    }
                }, {
                    key: "setActiveInput",
                    value: function setActiveInput(input) {
                        IonInput.clearTabIndexes();
                        this.i[1].tabIndex = -1;
                        input.tabIndex = ACTIVE_TAB_INDEX;
                    }
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(tabIndex) {
                        if (tabIndex === PREVIOUS_TAB_INDEX) {
                            // they tabbed back one input
                            // reset the focus to the center focus holder
                            this.i[1].focus();
                            // focus on the previous input
                            IonInput.focusPrevious();
                        } else if (tabIndex === NEXT_TAB_INDEX) {
                            // they tabbed to the next input
                            // reset the focus to the center focus holder
                            this.i[1].focus();
                            // focus on the next input
                            IonInput.focusNext();
                        }
                    }
                }, {
                    key: "register",
                    value: function register(input) {
                        // register each of the focus holder inputs
                        // assign them their correct tab indexes
                        input.tabIndex = PREVIOUS_TAB_INDEX + this.i.length;
                        this.i.push(input);
                    }
                }]);

                return _class;
            })();

            _export("FocusHolder", FocusHolder);

            _export("FocusHolder", FocusHolder = __decorate([Component({
                selector: "focus-holder"
            }), View({
                template: "<input><input><input>",
                directives: [forwardRef(function () {
                    return FocusInput;
                })]
            }), __metadata("design:paramtypes", [])], FocusHolder));

            FocusInput = (function () {
                var _class2 = function FocusInput(elementRef, holder) {
                    _classCallCheck(this, _class2);

                    this.elementRef = elementRef;
                    holder.register(this);
                    this.holder = holder;
                };

                _createClass(_class2, [{
                    key: "focus",
                    value: function focus() {
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: "keydown",
                    value: function keydown(ev) {
                        // prevent any keyboard typing when a holder has focus
                        if (ev.keyCode !== 9) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    }
                }, {
                    key: "type",
                    get: function get() {
                        // default to text type if unknown
                        return this._t || "text";
                    },
                    set: function set(val) {
                        this._t = val;
                    }
                }]);

                return _class2;
            })();

            FocusInput = __decorate([Directive({
                selector: "input",
                properties: ["tabIndex"],
                host: {
                    "[tabIndex]": "tabIndex",
                    "[type]": "type",
                    "(focus)": "holder.receivedFocus(tabIndex)",
                    "(keydown)": "keydown($event)"
                }
            }), __param(1, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, FocusHolder])], FocusInput);
            PREVIOUS_TAB_INDEX = 999;
            ACTIVE_TAB_INDEX = 1000;
            NEXT_TAB_INDEX = 1001;
        }
    };
});
System.register('ionic/components/form/form', ['./focus-holder', './input', './tap-input', './text-input'], function (_export) {
  'use strict';

  return {
    setters: [function (_focusHolder) {
      for (var _key in _focusHolder) {
        _export(_key, _focusHolder[_key]);
      }
    }, function (_input) {
      for (var _key2 in _input) {
        _export(_key2, _input[_key2]);
      }
    }, function (_tapInput) {
      for (var _key3 in _tapInput) {
        _export(_key3, _tapInput[_key3]);
      }
    }, function (_textInput) {
      for (var _key4 in _textInput) {
        _export(_key4, _textInput[_key4]);
      }
    }],
    execute: function () {}
  };
});
System.register('ionic/components/form/input', ['../ion', '../../util/dom'], function (_export) {
    'use strict';

    var Ion, dom, inputRegistry, itemRegistry, inputItemIds, activeInput, lastInput, IonInput, IonInputItem;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ion) {
            Ion = _ion.Ion;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            inputRegistry = [];
            itemRegistry = [];
            inputItemIds = -1;
            activeInput = null;
            lastInput = null;

            // Input element (not the container)

            IonInput = (function () {
                function IonInput(elementRef, app, config, scrollView) {
                    _classCallCheck(this, IonInput);

                    this.elementRef = elementRef;
                    this.app = app;
                    this.scrollView = scrollView;
                    this.scrollAssist = config.setting('keyboardScrollAssist');
                    inputRegistry.push(this);
                }

                _createClass(IonInput, [{
                    key: 'hasFocus',
                    value: function hasFocus() {
                        return dom.hasFocus(this.elementRef);
                    }
                }, {
                    key: 'focus',
                    value: function focus() {
                        this.setFocus();
                    }
                }, {
                    key: 'setFocus',
                    value: function setFocus() {
                        // TODO: How do you do this w/ NG2?
                        this.elementRef.nativeElement.focus();
                    }
                }, {
                    key: 'setFocusHolder',
                    value: function setFocusHolder(type) {
                        var focusHolder = this.app.focusHolder();
                        focusHolder && focusHolder.setFocusHolder(type);
                    }
                }, {
                    key: 'isActiveInput',
                    value: function isActiveInput(shouldBeActive) {
                        if (shouldBeActive) {
                            if (activeInput && activeInput !== lastInput) {
                                lastInput = activeInput;
                            }
                            activeInput = this;
                            var focusHolder = this.app.focusHolder();
                            focusHolder && focusHolder.setActiveInput(activeInput);
                        } else if (activeInput === this) {
                            lastInput = activeInput;
                            activeInput = null;
                        }
                    }
                }, {
                    key: 'sibling',
                    value: function sibling(inc) {
                        var index = inputRegistry.indexOf(this);
                        if (index > -1) {
                            return inputRegistry[index + inc];
                        }
                    }
                }], [{
                    key: 'focusPrevious',
                    value: function focusPrevious() {
                        this.focusMove(-1);
                    }
                }, {
                    key: 'focusNext',
                    value: function focusNext() {
                        this.focusMove(1);
                    }
                }, {
                    key: 'focusMove',
                    value: function focusMove(inc) {
                        var input = activeInput || lastInput;
                        if (input) {
                            var siblingInput = input.sibling(inc);
                            siblingInput && siblingInput.focus();
                        }
                    }
                }, {
                    key: 'clearTabIndexes',
                    value: function clearTabIndexes() {
                        for (var i = 0; i < inputRegistry.length; i++) {
                            inputRegistry[i].tabIndex = -1;
                        }
                    }
                }]);

                return IonInput;
            })();

            _export('IonInput', IonInput);

            // Container element for the label and input element

            IonInputItem = (function (_Ion) {
                function IonInputItem(elementRef, ionicConfig) {
                    _classCallCheck(this, IonInputItem);

                    _get(Object.getPrototypeOf(IonInputItem.prototype), 'constructor', this).call(this, elementRef, ionicConfig);
                    this.id = ++inputItemIds;
                    itemRegistry.push(this);
                }

                _inherits(IonInputItem, _Ion);

                _createClass(IonInputItem, [{
                    key: 'onInit',
                    value: function onInit() {
                        _get(Object.getPrototypeOf(IonInputItem.prototype), 'onInit', this).call(this);
                        if (this.input && this.label) {
                            this.input.id = this.input.id || 'input-' + this.id;
                            this.label.labelFor = this.input.id;
                        }
                    }
                }, {
                    key: 'registerInput',
                    value: function registerInput(input) {
                        this.input = input;
                    }
                }, {
                    key: 'registerLabel',
                    value: function registerLabel(label) {
                        this.label = label;
                    }
                }]);

                return IonInputItem;
            })(Ion);

            _export('IonInputItem', IonInputItem);
        }
    };
});
System.register("ionic/components/form/label", ["angular2/angular2", "../../config/config", "../../util/dom", "./text-input", "../checkbox/checkbox", "../radio/radio", "../switch/switch"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, IonicConfig, dom, Input, Checkbox, RadioButton, Switch, __decorate, __metadata, __param, Label;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_utilDom) {
            dom = _utilDom;
        }, function (_textInput) {
            Input = _textInput.Input;
        }, function (_checkboxCheckbox) {
            Checkbox = _checkboxCheckbox.Checkbox;
        }, function (_radioRadio) {
            RadioButton = _radioRadio.RadioButton;
        }, function (_switchSwitch) {
            Switch = _switchSwitch.Switch;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Label = (function () {
                var _class = function Label(textContainer, checkboxContainer, radioContainer, switchContainer, config) {
                    _classCallCheck(this, _class);

                    this.container = textContainer || checkboxContainer || radioContainer || switchContainer;
                    if (this.container) {
                        this.container.registerLabel(this);
                        this.inputLabel = true;
                    }
                    this.scrollAssist = config.setting("keyboardScrollAssist");
                };

                _createClass(_class, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                        }
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.container) {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            if (!dom.hasPointerMoved(20, this.startCoord, endCoord)) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.container instanceof Input ? this.container.focus() : this.container.toggle();
                            }
                            this.startCoord = null;
                        }
                    }
                }]);

                return _class;
            })();

            _export("Label", Label);

            _export("Label", Label = __decorate([Directive({
                selector: "label",
                host: {
                    "[attr.for]": "labelFor",
                    "[class.input-label]": "inputLabel",
                    "(touchstart)": "pointerStart($event)",
                    "(touchend)": "pointerEnd($event)",
                    "(mousedown)": "pointerStart($event)",
                    "(mouseup)": "pointerEnd($event)"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Optional()), __param(2, Ancestor()), __param(3, Optional()), __param(3, Ancestor()), __metadata("design:paramtypes", [typeof Input !== "undefined" && Input || Object, typeof Checkbox !== "undefined" && Checkbox || Object, typeof RadioButton !== "undefined" && RadioButton || Object, typeof Switch !== "undefined" && Switch || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Label));
        }
    };
});
System.register("ionic/components/form/tap-input", ["angular2/angular2", "./input", "../app/app", "../../config/config", "../content/content", "../checkbox/checkbox", "../radio/radio"], function (_export) {
    "use strict";

    var Ancestor, Optional, ElementRef, Attribute, Directive, IonInput, IonicApp, IonicConfig, Content, Checkbox, RadioButton, __decorate, __metadata, __param, TapInput;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
            Directive = _angular2Angular2.Directive;
        }, function (_input) {
            IonInput = _input.IonInput;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_checkboxCheckbox) {
            Checkbox = _checkboxCheckbox.Checkbox;
        }, function (_radioRadio) {
            RadioButton = _radioRadio.RadioButton;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            TapInput = (function (_IonInput) {
                var _class = function TapInput(checkboxContainer, radioContainer, scrollView, type, elementRef, app, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, app, config, scrollView);
                    var container = checkboxContainer || radioContainer;
                    if (container) {
                        container.registerInput(this);
                        this.container = container;
                    }
                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || "";
                };

                _inherits(_class, _IonInput);

                return _class;
            })(IonInput);

            _export("TapInput", TapInput);

            _export("TapInput", TapInput = __decorate([Directive({
                selector: "input[type=checkbox],input[type=radio]",
                properties: ["checked", "name", "value"],
                host: {
                    "[checked]": "checked",
                    "[value]": "value",
                    "[attr.name]": "name",
                    "class": "tap-input input"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Optional()), __param(2, Ancestor()), __param(3, Attribute("type")), __metadata("design:paramtypes", [typeof Checkbox !== "undefined" && Checkbox || Object, typeof RadioButton !== "undefined" && RadioButton || Object, typeof Content !== "undefined" && Content || Object, String, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], TapInput));
        }
    };
});
System.register("ionic/components/form/text-input", ["angular2/angular2", "../../config/annotations", "../../config/config", "./input", "../app/app", "../content/content", "../../util/click-block", "../../util/dom"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, ElementRef, Attribute, IonicDirective, IonicConfig, IonInput, IonInputItem, IonicApp, Content, ClickBlock, dom, __decorate, __metadata, __param, Input, TextInput, SCROLL_INTO_VIEW_DURATION, SCROLL_Y_PADDING;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            Attribute = _angular2Angular2.Attribute;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_input) {
            IonInput = _input.IonInput;
            IonInputItem = _input.IonInputItem;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_utilDom) {
            dom = _utilDom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Input = (function (_IonInputItem) {
                var _class = function Input(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "focus",
                    value: function focus() {
                        this.input && this.input.focus();
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Input", Input);

            _export("Input", Input = __decorate([IonicDirective({
                selector: "ion-input",
                classId: "item-input",
                host: {
                    "class": "item"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Input));

            TextInput = (function (_IonInput) {
                var _class2 = function TextInput(container, scrollView, type, elementRef, app, config) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, app, config, scrollView);
                    if (container) {
                        container.registerInput(this);
                        this.container = container;
                    }
                    this.type = type;
                    this.elementRef = elementRef;
                    this.tabIndex = this.tabIndex || "";
                };

                _inherits(_class2, _IonInput);

                _createClass(_class2, [{
                    key: "pointerStart",
                    value: function pointerStart(ev) {
                        if (this.scrollAssist) {
                            // remember where the touchstart/mousedown started
                            this.startCoord = dom.pointerCoord(ev);
                            this.pressStart = Date.now();
                        }
                    }
                }, {
                    key: "pointerEnd",
                    value: function pointerEnd(ev) {
                        if (this.scrollAssist) {
                            // get where the touchend/mouseup ended
                            var endCoord = dom.pointerCoord(ev);
                            // focus this input if the pointer hasn't moved XX pixels
                            // and the input doesn't already have focus
                            if (!dom.hasPointerMoved(20, this.startCoord, endCoord) && !this.hasFocus()) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                this.focus();
                            }
                            this.startCoord = this.pressStart = null;
                        }
                    }
                }, {
                    key: "focus",
                    value: function focus() {
                        var _this = this;

                        var scrollView = this.scrollView;
                        if (scrollView && this.scrollAssist) {
                            // this input is inside of a scroll view
                            // scroll the input to the top
                            var inputY = this.elementRef.nativeElement.offsetTop - SCROLL_Y_PADDING;
                            // do not allow any clicks while it's scrolling
                            ClickBlock(true, SCROLL_INTO_VIEW_DURATION + 200);
                            // used to put a lot of padding on the bottom of the scroll view
                            scrollView.scrollPadding = true;
                            // temporarily move the focus to the focus holder so the browser
                            // doesn't freak out while it's trying to get the input in place
                            this.setFocusHolder(this.type);
                            // scroll the input into place
                            scrollView.scrollTo(0, inputY, SCROLL_INTO_VIEW_DURATION, 8).then(function () {
                                // the scroll view is in the correct position now
                                // give the native input the focus
                                _this.setFocus();
                                // all good, allow clicks again
                                ClickBlock(false);
                            });
                        } else {
                            // not inside of a scroll view, just focus it
                            this.setFocus();
                        }
                    }
                }, {
                    key: "receivedFocus",
                    value: function receivedFocus(_receivedFocus) {
                        var self = this;
                        var scrollView = self.scrollView;
                        self.isActiveInput(_receivedFocus);
                        function touchMove(ev) {
                            if (!self.isPressHold()) {
                                self.setFocusHolder(self.type);
                                self.deregTouchMove();
                            }
                        }
                        if (scrollView && this.scrollAssist) {
                            if (_receivedFocus) {
                                // when the input has focus, then the focus holder
                                // should not be able to be focused
                                self.deregTouchMove = scrollView && scrollView.addTouchMoveListener(touchMove);
                            } else {
                                // the input no longer has focus
                                self.deregTouchMove && self.deregTouchMove();
                            }
                        }
                    }
                }, {
                    key: "isPressHold",
                    value: function isPressHold() {
                        return this.pressStart && this.pressStart + 500 < Date.now();
                    }
                }]);

                return _class2;
            })(IonInput);

            _export("TextInput", TextInput);

            _export("TextInput", TextInput = __decorate([Directive({
                selector: "textarea,input[type=text],input[type=password],input[type=number],input[type=search],input[type=email],input[type=url],input[type=tel]",
                property: ["tabIndex"],
                host: {
                    "[tabIndex]": "tabIndex",
                    "(focus)": "receivedFocus(true)",
                    "(blur)": "receivedFocus(false)",
                    "(touchstart)": "pointerStart($event)",
                    "(touchend)": "pointerEnd($event)",
                    "(mousedown)": "pointerStart($event)",
                    "(mouseup)": "pointerEnd($event)",
                    "[attr.id]": "id",
                    "class": "text-input input"
                }
            }), __param(0, Optional()), __param(0, Ancestor()), __param(1, Optional()), __param(1, Ancestor()), __param(2, Attribute("type")), __metadata("design:paramtypes", [Input, typeof Content !== "undefined" && Content || Object, String, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], TextInput));
            SCROLL_INTO_VIEW_DURATION = 500;
            SCROLL_Y_PADDING = 28;
        }
    };
});
System.register("ionic/components/icon/icon", ["angular2/angular2", "../../config/config", "../../config/annotations", "../ion", "../button/button"], function (_export) {
    "use strict";

    var Directive, View, CSSClass, ElementRef, Optional, Ancestor, Attribute, Renderer, IonicConfig, IonicComponent, Ion, Button, __decorate, __metadata, __param, IconDirective, Icon;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            CSSClass = _angular2Angular2.CSSClass;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            Attribute = _angular2Angular2.Attribute;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_buttonButton) {
            Button = _buttonButton.Button;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            /*
            
            'home': {
              ios: ['ion-ios-home', 'ion-ios-home-outline'],
              md: 'ion-md-home'
            }
            
            1-for-1 swap
            Map of stuff that's 1-for-1
            <icon name="home"></icon>
            <icon class="ion-ios-home"></icon>
            <icon class="ion-md-home"></icon>
            
            
            Always use the same no matter what
            Cuz it's not in the map of 1-for-1's
            <icon name="alert"></icon>
            <icon class="ion-alert"></icon>
            
            
            Different between modes
            Used different attributes
            <icon ios-name="search3" md-name="search2"></icon>
            <icon class="ion-ios-search3"></icon>
            <icon class="ion-md-search2"></icon>
            
            
            
            Ionicons SVG
            <icon svg="home"></icon>
            <icon><svg>...ios...</svg></icon>
            <icon><svg>...md...</svg></icon>
            
            
            Custom SVG File
            <icon svg-src="home.svg"></icon>
            
            
            Custom Font Icon
            <icon class="fa-home"></icon>
            
            */

            IconDirective = (function () {
                var _class = function IconDirective(_elementRef, AncestorButton, forward, config, _renderer) {
                    _classCallCheck(this, _class);

                    this._elementRef = _elementRef;
                    this._renderer = _renderer;
                    var ele = this.ele = _elementRef.nativeElement;
                    this.iconLeft = this.iconRight = this.iconOnly = false;
                    this.ariaHidden = true;
                    if (forward !== null) {
                        this.fwdIcon = config.setting("forwardIcon");
                    }
                    if (AncestorButton) {
                        // this icon is within a button
                        this.withinButton = true;
                        // check if there is a sibling element (that's not aria hidden)
                        var hasPreviousSiblingElement = !!ele.previousElementSibling;
                        var hasNextSiblingElement = ele.nextElementSibling && ele.nextElementSibling.getAttribute("aria-hidden") !== "true";
                        if (!hasPreviousSiblingElement && !hasNextSiblingElement) {
                            // this icon is within a button, and doesn't have a sibling element
                            // check for text nodes to the right and left of this icon element
                            this.iconLeft = (ele.nextSibling && ele.nextSibling.textContent || "").trim() !== "";
                            this.iconRight = (ele.previousSibling && ele.previousSibling.textContent || "").trim() !== "";
                            this.iconOnly = !this.iconLeft && !this.iconRight;
                        }
                        // tell the button there's a child icon
                        // the button will set the correct css classes on itself
                        AncestorButton.registerIcon(this);
                    }
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        if (this.fwdIcon) {
                            this.name = this.fwdIcon;
                        }
                        if (!this.name) return;
                        // add the css class to show the icon font
                        this._renderer.setElementClass(this._elementRef, this.name, true);
                        // hide the icon when it's within a button
                        // and the button isn't an icon only button
                        this.ariaHidden = this.withinButton && !this.iconOnly;
                        if (!this.ariaHidden) {
                            // the icon is either not within a button
                            // or the icon is within a button, and its an icon only button
                            this.label = this.name.replace("ion-", "").replace("ios-", "").replace("md-", "").replace("-", "");
                        }
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.ele = null;
                    }
                }]);

                return _class;
            })();

            _export("IconDirective", IconDirective);

            _export("IconDirective", IconDirective = __decorate([Directive({
                selector: "icon",
                properties: ["name", "iconName"],
                host: {
                    "[attr.aria-label]": "label",
                    "[attr.aria-hidden]": "ariaHidden",
                    "role": "img"
                }
            }), __param(1, Optional()), __param(1, Ancestor()), __param(2, Attribute("forward")), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof Button !== "undefined" && Button || Object, String, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof Renderer !== "undefined" && Renderer || Object])], IconDirective));

            Icon = (function (_Ion) {
                var _class2 = function Icon(elementRef, ionicConfig) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                };

                _inherits(_class2, _Ion);

                _createClass(_class2, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        var _this = this;

                        this.iconClass = this.ios;
                        console.log("ICON", this.mode);
                        setTimeout(function () {
                            console.log("MODE", _this.mode);
                        });
                    }
                }]);

                return _class2;
            })(Ion);

            _export("Icon", Icon);

            _export("Icon", Icon = __decorate([IonicComponent({
                selector: "ion-icon",
                properties: ["md", "ios"],
                host: {
                    "mode": "mode"
                }
            }), View({
                template: "<i class=\"icon\" [class]=\"iconClass\">",
                directives: [CSSClass]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Icon));
        }
    };
});
System.register("ionic/components/item/item-group", ["angular2/angular2"], function (_export) {
    "use strict";

    var Directive, ElementRef, __decorate, __metadata, ItemGroup, ItemGroupTitle;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemGroup = (function () {
                var _class = function ItemGroup(elementRef) {
                    _classCallCheck(this, _class);

                    this.ele = elementRef.nativeElement;
                };

                return _class;
            })();

            _export("ItemGroup", ItemGroup);

            _export("ItemGroup", ItemGroup = __decorate([Directive({
                selector: "ion-item-group",
                host: {
                    "class": "item-group"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], ItemGroup));

            ItemGroupTitle = (function () {
                var _class2 = function ItemGroupTitle(elementRef) {
                    _classCallCheck(this, _class2);

                    this.isSticky = true;
                    this.ele = elementRef.nativeElement;
                };

                return _class2;
            })();

            _export("ItemGroupTitle", ItemGroupTitle);

            _export("ItemGroupTitle", ItemGroupTitle = __decorate([Directive({
                selector: "ion-item-group-title",
                host: {
                    "class": "item-group-title",
                    "[class.sticky]": "isSticky"
                }
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], ItemGroupTitle));
        }
    };
});
System.register("ionic/components/item/item-options", [], function (_export) {
    "use strict";

    var __decorate, __metadata, ItemPrimaryOptions, ItemSecondaryOptions;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            ItemPrimaryOptions = (function () {
                var _class = function ItemPrimaryOptions() {
                    _classCallCheck(this, _class);
                };

                return _class;
            })();

            _export("ItemPrimaryOptions", ItemPrimaryOptions);

            _export("ItemPrimaryOptions", ItemPrimaryOptions = __decorate([Decorator({
                selector: "ion-primary-options"
            }), __metadata("design:paramtypes", [])], ItemPrimaryOptions));

            ItemSecondaryOptions = (function () {
                var _class2 = function ItemSecondaryOptions() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("ItemSecondaryOptions", ItemSecondaryOptions);

            _export("ItemSecondaryOptions", ItemSecondaryOptions = __decorate([Decorator({
                selector: "ion-secondary-options"
            }), __metadata("design:paramtypes", [])], ItemSecondaryOptions));
        }
    };
});
System.register("ionic/components/item/item-swipe-buttons", ["angular2/angular2", "ionic/components/item/item", "ionic/gestures/slide-gesture"], function (_export) {
    "use strict";

    var ElementRef, Ancestor, Directive, Item, SlideGesture, __decorate, __metadata, __param, ItemPrimarySwipeButtons, ItemSecondarySwipeButtons, ItemSlideGesture;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            Directive = _angular2Angular2.Directive;
        }, function (_ionicComponentsItemItem) {
            Item = _ionicComponentsItemItem.Item;
        }, function (_ionicGesturesSlideGesture) {
            SlideGesture = _ionicGesturesSlideGesture.SlideGesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ItemPrimarySwipeButtons = (function () {
                var _class = function ItemPrimarySwipeButtons(elementRef, item) {
                    _classCallCheck(this, _class);

                    item.primarySwipeButtons = this;
                    this.ele = elementRef.nativeElement;
                    this.AncestorItem = item;
                    this.gesture = new ItemSlideGesture(this);
                    this.gesture.listen();
                };

                _createClass(_class, [{
                    key: "setOpen",
                    value: function setOpen(isOpen) {
                        var _this = this;

                        if (isOpen !== this.isOpen) {
                            this.isOpen = isOpen;
                            requestAnimationFrame(function () {
                                _this.ele.classList[isOpen ? "add" : "remove"](isOpen);
                            });
                        }
                    }
                }]);

                return _class;
            })();

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons);

            _export("ItemPrimarySwipeButtons", ItemPrimarySwipeButtons = __decorate([Directive({
                selector: "ion-primary-swipe-buttons"
            }), __param(1, Ancestor()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof Item !== "undefined" && Item || Object])], ItemPrimarySwipeButtons));

            ItemSecondarySwipeButtons = (function () {
                var _class2 = function ItemSecondarySwipeButtons() {
                    _classCallCheck(this, _class2);
                };

                return _class2;
            })();

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons);

            _export("ItemSecondarySwipeButtons", ItemSecondarySwipeButtons = __decorate([Directive({
                selector: "ion-secondary-swipe-buttons"
            }), __metadata("design:paramtypes", [])], ItemSecondarySwipeButtons));

            ItemSlideGesture = (function (_SlideGesture) {
                function ItemSlideGesture(buttons) {
                    _classCallCheck(this, ItemSlideGesture);

                    _get(Object.getPrototypeOf(ItemSlideGesture.prototype), "constructor", this).call(this, buttons.AncestorItem.ele);
                    this.buttons = buttons;
                }

                _inherits(ItemSlideGesture, _SlideGesture);

                _createClass(ItemSlideGesture, [{
                    key: "getSlideBoundaries",
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.buttons.ele.offsetWidth,
                            max: 0
                        };
                    }
                }, {
                    key: "getElementStartPos",
                    value: function getElementStartPos(slide, ev) {
                        return this.buttons.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: "onSlideBeforeStart",
                    value: function onSlideBeforeStart() {
                        this.buttons.ele.classList.add("changing");
                        this.buttons.ele.classList.add("no-transition");
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: "onSlide",
                    value: function onSlide(slide, ev) {
                        this.buttons.ele.style.transform = "translate3d(" + slide.distance + "px,0,0)";
                    }
                }, {
                    key: "onSlideEnd",
                    value: function onSlideEnd(slide, ev) {
                        this.buttons.ele.style.transform = "";
                        this.buttons.ele.classList.remove("no-transition");
                        if (Math.abs(ev.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.buttons.setOpen(!this.buttons.isOpen);
                        }
                    }
                }]);

                return ItemSlideGesture;
            })(SlideGesture);
        }
    };
});
System.register("ionic/components/item/item", ["angular2/angular2", "ionic/util"], function (_export) {
    "use strict";

    var Component, View, ElementRef, dom, __decorate, __metadata, Item, Slideable, ItemSlideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Item = (function () {
                var _class = function Item(elementRef) {
                    _classCallCheck(this, _class);

                    this._isOpen = false;
                    this._isSlideActive = false;
                    this._isTransitioning = false;
                    this._transform = "";
                    this.ele = elementRef.nativeElement;
                    this.swipeButtons = {};
                    this.optionButtons = {};
                };

                return _class;
            })();

            _export("Item", Item);

            _export("Item", Item = __decorate([Component({
                selector: "ion-item",
                host: {
                    "class": "item"
                }
            }), View({
                template: "\n    <!--\n    <ng-content select=\"ion-primary-options\"></ng-content>\n    <ng-content select=\"ion-primary-swipe-buttons\"></ng-content>\n    -->\n    <div class=\"item-content\">\n      <div class=\"item-media\">\n      </div>\n      <div class=\"item-accessory\">\n        <!--<ng-content select=\"ion-item-accessory\"></ng-content>-->\n      </div>\n      <div class=\"item-label\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n    <!--\n    <ng-content select=\"ion-secondary-options\"></ng-content>\n    <ng-content select=\"ion-secondary-swipe-buttons\"></ng-content>\n    -->\n  "
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Item));

            Slideable = (function () {
                function Slideable(slideElement) {
                    _classCallCheck(this, Slideable);
                }

                _createClass(Slideable, [{
                    key: "onTransform",

                    // override
                    value: function onTransform(str) {}
                }, {
                    key: "onTransitionActive",

                    // override
                    value: function onTransitionActive(active) {}
                }, {
                    key: "onSlideActive",

                    //override
                    value: function onSlideActive(active) {}
                }, {
                    key: "transform",
                    value: function transform(str) {
                        if (arguments.length && str !== this._transform) {
                            this.onTransform();
                        }
                    }
                }, {
                    key: "isTransitionActive",
                    value: function isTransitionActive(active) {
                        if (arguments.length && active !== this._isTransitionActive) {
                            this._isTransitionActive = active;
                            this.onSetTransitionActive(active);
                        }
                        return this._isTransitioning;
                    }
                }, {
                    key: "isSlideActive",
                    value: function isSlideActive(active) {
                        if (arguments.length && active !== this._isSlideActive) {
                            this._isSlideActive = active;
                            this.onSetDragActive(active);
                        }
                        return this._isSlideActive;
                    }
                }, {
                    key: "isOpen",
                    value: (function (_isOpen) {
                        function isOpen(_x) {
                            return _isOpen.apply(this, arguments);
                        }

                        isOpen.toString = function () {
                            return _isOpen.toString();
                        };

                        return isOpen;
                    })(function (open) {
                        var _this = this;

                        if (arguments.length && open !== this._isOpen) {
                            this.isTransitionActive(true);
                            dom.raf(function () {
                                _this.isOpen = isOpen;
                                _this.onSetIsOpen(open);
                            });
                        }
                    })
                }]);

                return Slideable;
            })();

            ItemSlideGesture = function ItemSlideGesture() {
                _classCallCheck(this, ItemSlideGesture);
            };
        }
    };
});
System.register("ionic/components/layout/layout", ["angular2/angular2"], function (_export) {
    "use strict";

    var Component, View, ElementRef, __decorate, __metadata, __param, Layout;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Layout = (function () {
                var _class = function Layout(elementRef) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    this.ele = ngElement.nativeElement;
                    this.eqEle = this.ele.lastElementChild;
                    window.requestAnimationFrame(function () {
                        _this.initLayout();
                    });
                };

                _createClass(_class, [{
                    key: "initLayout",
                    value: function initLayout() {
                        var _this2 = this;

                        this.mqs = {};

                        var _loop = function (x) {
                            var attr = _this2.ele.attributes[x];
                            var val = attr.nodeValue;
                            var mqClassname = attr.nodeName;
                            if (val.indexOf("(") > -1 && val.indexOf(")") > -1) {
                                var mql = _this2.eqEle.contentDocument.defaultView.matchMedia(val);
                                if (mql.media !== "not all") {
                                    _this2.mqs[mql.media] = function (mql) {
                                        console.log(mql.media, mql.matches, mqClassname);
                                        window.requestAnimationFrame(function () {
                                            _this2.ele.classList[mql.matches ? "add" : "remove"](mqClassname);
                                        });
                                    };
                                    _this2.mqs[mql.media](mql);
                                    mql.addListener(_this2.mqs[mql.media]);
                                }
                            }
                        };

                        for (var x = 0; x < this.ele.attributes.length; x++) {
                            _loop(x);
                        }
                    }
                }]);

                return _class;
            })();

            _export("Layout", Layout);

            _export("Layout", Layout = __decorate([Component({
                selector: "layout,[layout]"
            }), View({
                template: "\n    <ng-content></ng-content>\n    <object class=\"ele-qry\" data=\"about:blank\"></object>\n  "
            }), __param(0, ElementRef()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Layout));
        }
    };
});
System.register("ionic/components/list/list", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations", "./virtual", "ionic/util"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicDirective, ListVirtualScroll, util, __decorate, __metadata, List;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_virtual) {
            ListVirtualScroll = _virtual.ListVirtualScroll;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            List = (function (_Ion) {
                var _class = function List(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        if (util.isDefined(this.virtual)) {
                            console.log("Content", this.content);
                            console.log("Virtual?", this.virtual);
                            console.log("Items?", this.items.length, "of 'em");
                            this._initVirtualScrolling();
                        }
                    }
                }, {
                    key: "_initVirtualScrolling",
                    value: function _initVirtualScrolling() {
                        if (!this.content) {
                            return;
                        }
                        this._virtualScrollingManager = new ListVirtualScroll(this);
                    }
                }, {
                    key: "setItemTemplate",
                    value: function setItemTemplate(item) {
                        this.itemTemplate = item;
                    }
                }]);

                return _class;
            })(Ion);

            _export("List", List);

            _export("List", List = __decorate([IonicDirective({
                selector: "ion-list",
                properties: ["items", "virtual", "content"]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], List));
        }
    };
});
System.register('ionic/components/list/virtual', [], function (_export) {
    'use strict';

    var ListVirtualScroll, VirtualItemRef;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            ListVirtualScroll = (function () {
                function ListVirtualScroll(list) {
                    var _this = this;

                    _classCallCheck(this, ListVirtualScroll);

                    this.list = list;
                    this.content = this.list.content;
                    this.viewportHeight = this.content.height();
                    this.viewContainer = this.list.itemTemplate.viewContainer;
                    this.itemHeight = 60;
                    this.shownItems = {};
                    this.enteringItems = [];
                    this.leavingItems = [];
                    // Compute the initial sizes
                    setTimeout(function () {
                        _this.resize();
                        // Simulate the first event to start layout
                        _this._handleVirtualScroll({
                            target: _this.content.scrollElement
                        });
                    });
                    this.content.addScrollEventListener(function (event) {
                        _this._handleVirtualScroll(event);
                    });
                }

                _createClass(ListVirtualScroll, [{
                    key: 'resize',
                    value: function resize() {
                        this.viewportHeight = this.content.height();
                        this.viewportScrollHeight = this.content.scrollElement.scrollHeight;
                        this.virtualHeight = this.list.items.length * this.itemHeight;
                        this.itemsPerScreen = this.viewportHeight / this.itemHeight;
                        console.log('VIRTUAL: resize(viewportHeight:', this.viewportHeight, 'viewportScrollHeight:', this.viewportScrollHeight, 'virtualHeight:', this.virtualHeight, ', itemsPerScreen:', this.itemsPerScreen, ')');
                    }
                }, {
                    key: '_handleVirtualScroll',
                    value: function _handleVirtualScroll(event) {
                        var item = undefined;
                        var shownItemRef = undefined;
                        var st = event.target.scrollTop;
                        var sh = event.target.scrollHeight;
                        var topIndex = Math.floor(st / this.itemHeight);
                        var bottomIndex = Math.floor(st / this.itemHeight + this.itemsPerScreen);
                        var items = this.list.items;
                        // Key iterate the shown items map
                        // and compare the index to our index range,
                        // pushing the items to remove to our leaving
                        // list if they're ouside this range.
                        for (var i in this.shownItems) {
                            if (i < topIndex || i > bottomIndex) {
                                this.leavingItems.push(this.shownItems[i]);
                                delete this.shownItems[i];
                            }
                        }
                        var realIndex = 0;
                        // Iterate the set of items that will be rendered, using the
                        // index from the actual items list as the map for the
                        // virtual items we draw
                        for (var i = topIndex, _realIndex = 0; i < bottomIndex && i < items.length; i++, _realIndex++) {
                            item = items[i];
                            console.log('Drawing item', i, item.title);
                            shownItemRef = this.shownItems[i];
                            // Is this a new item?
                            if (!shownItemRef) {
                                var itemView = this.viewContainer.create(this.list.itemTemplate.protoViewRef, _realIndex);
                                itemView.setLocal('$implicit', item);
                                itemView.setLocal('$item', item);
                                shownItemRef = new VirtualItemRef(item, i, _realIndex, itemView);
                                this.shownItems[i] = shownItemRef;
                                this.enteringItems.push(shownItemRef);
                            }
                        }
                        while (this.leavingItems.length) {
                            var itemRef = this.leavingItems.pop();
                            console.log('Removing item', itemRef.item, itemRef.realIndex);
                            this.viewContainer.remove(itemRef.realIndex);
                        }
                        console.log('VIRTUAL SCROLL: scroll(scrollTop:', st, 'topIndex:', topIndex, 'bottomIndex:', bottomIndex, ')');
                        console.log('Container has', this.list.getNativeElement().children.length, 'children');
                    }
                }, {
                    key: 'cellAtIndex',
                    value: function cellAtIndex(index) {}
                }]);

                return ListVirtualScroll;
            })();

            _export('ListVirtualScroll', ListVirtualScroll);

            VirtualItemRef = function VirtualItemRef(item, index, realIndex, view) {
                _classCallCheck(this, VirtualItemRef);

                this.item = item;
                this.index = index;
                this.realIndex = realIndex;
                this.view = view;
            };
        }
    };
});
System.register("ionic/components/material/button", ["angular2/angular2", "../../config/config", "../material/ripple"], function (_export) {
    "use strict";

    var ElementRef, Directive, onDestroy, IonicConfig, MaterialRippleEffect, __decorate, __metadata, MaterialButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            onDestroy = _angular2Angular2.onDestroy;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_materialRipple) {
            MaterialRippleEffect = _materialRipple.MaterialRippleEffect;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            MaterialButton = (function () {
                var _class = function MaterialButton(elementRef, config) {
                    _classCallCheck(this, _class);

                    this.elementRef = elementRef;
                    if (config.setting("mdRipple")) {
                        this.ripple = new MaterialRippleEffect(this);
                    }
                };

                _createClass(_class, [{
                    key: "onDestroy",
                    value: function onDestroy() {}
                }]);

                return _class;
            })();

            _export("MaterialButton", MaterialButton);

            _export("MaterialButton", MaterialButton = __decorate([Directive({
                selector: "button,[button]",
                lifecycle: [onDestroy]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], MaterialButton));
        }
    };
});
System.register('ionic/components/material/ripple', [], function (_export) {
    /**
     * Lovingly Adapted from Material Design Lite
     * Copyright Google, 2015, Licensed under the Apache 2 license.
     * https://github.com/google/material-design-lite
     */
    'use strict';

    var MaterialRippleEffect;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [],
        execute: function () {
            MaterialRippleEffect = (function () {
                function MaterialRippleEffect(button) {
                    _classCallCheck(this, MaterialRippleEffect);

                    this.elementRef = button.elementRef;
                    this.element = this.elementRef.nativeElement;
                    var rippleContainer = document.createElement('span');
                    rippleContainer.classList.add('md-ripple-container');
                    rippleContainer.setAttribute('aria-hidden', 'true');
                    this.rippleElement = document.createElement('span');
                    this.rippleElement.classList.add('md-ripple');
                    rippleContainer.appendChild(this.rippleElement);
                    this.recentering = false; //this.element.classList.contains(this.CssClasses_.RIPPLE_CENTER);
                    this.INITIAL_SCALE = 'scale(0.0001, 0.0001)';
                    this.INITIAL_SIZE = '1px';
                    this.INITIAL_OPACITY = '0.4';
                    this.FINAL_OPACITY = '0';
                    this.FINAL_SCALE = '';
                    //this.boundRippleBlurHandler = this.blurHandler.bind(this);
                    //this.rippleElement_.addEventListener('mouseup', this.boundRippleBlurHandler);
                    this.elementRef.nativeElement.appendChild(rippleContainer);
                    this._initRipple();
                }

                _createClass(MaterialRippleEffect, [{
                    key: '_initRipple',
                    value: function _initRipple() {
                        this.frameCount = 0;
                        this.rippleSize = 0;
                        this.x = 0;
                        this.y = 0;
                        // Touch start produces a compat mouse down event, which would cause a
                        // second ripples. To avoid that, we use this property to ignore the first
                        // mouse down after a touch start.
                        this.ignoringMouseDown = false;
                        this.boundDownHandler = this.downHandler.bind(this);
                        this.element.addEventListener('mousedown', this.boundDownHandler);
                        this.element.addEventListener('touchstart', this.boundDownHandler);
                        this.boundUpHandler = this.upHandler.bind(this);
                        this.element.addEventListener('mouseup', this.boundUpHandler);
                        this.element.addEventListener('mouseleave', this.boundUpHandler);
                        this.element.addEventListener('touchend', this.boundUpHandler);
                        this.element.addEventListener('blur', this.boundUpHandler);
                    }
                }, {
                    key: 'downHandler',

                    /**
                     * Handle mouse / finger down on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                    value: function downHandler(event) {
                        'use strict';
                        if (!this.rippleElement.style.width && !this.rippleElement.style.height) {
                            var rect = this.element.getBoundingClientRect();
                            this.boundHeight = rect.height;
                            this.boundWidth = rect.width;
                            this.rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
                            this.rippleElement.style.width = this.rippleSize + 'px';
                            this.rippleElement.style.height = this.rippleSize + 'px';
                        }
                        this.rippleElement.classList.add('is-visible');
                        if (event.type === 'mousedown' && this.ignoringMouseDown) {
                            this.ignoringMouseDown = false;
                        } else {
                            if (event.type === 'touchstart') {
                                this.ignoringMouseDown = true;
                            }
                            var frameCount = this.getFrameCount();
                            if (frameCount > 0) {
                                return;
                            }
                            this.setFrameCount(1);
                            var bound = event.currentTarget.getBoundingClientRect();
                            var x;
                            var y;
                            // Check if we are handling a keyboard click.
                            if (event.clientX === 0 && event.clientY === 0) {
                                x = Math.round(bound.width / 2);
                                y = Math.round(bound.height / 2);
                            } else {
                                var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
                                var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
                                x = Math.round(clientX - bound.left);
                                y = Math.round(clientY - bound.top);
                            }
                            this.setRippleXY(x, y);
                            this.setRippleStyles(true);
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        }
                    }
                }, {
                    key: 'upHandler',

                    /**
                     * Handle mouse / finger up on element.
                     * @param {Event} event The event that fired.
                     * @private
                     */
                    value: function upHandler(event) {
                        'use strict';

                        var _this = this;

                        // Don't fire for the artificial "mouseup" generated by a double-click.
                        if (event && event.detail !== 2) {
                            setTimeout(function () {
                                _this.rippleElement.classList.remove('is-visible');
                            });
                        }
                    }
                }, {
                    key: 'getFrameCount',
                    value: function getFrameCount() {
                        return this.frameCount;
                    }
                }, {
                    key: 'setFrameCount',
                    value: function setFrameCount(fC) {
                        this.frameCount = fC;
                    }
                }, {
                    key: 'getRippleElement',
                    value: function getRippleElement() {
                        return this.rippleElement;
                    }
                }, {
                    key: 'setRippleXY',
                    value: function setRippleXY(newX, newY) {
                        this.x = newX;
                        this.y = newY;
                    }
                }, {
                    key: 'setRippleStyles',
                    value: function setRippleStyles(start) {
                        if (this.rippleElement !== null) {
                            var transformString;
                            var scale;
                            var size;
                            var offset = 'translate(' + this.x + 'px, ' + this.y + 'px)';
                            if (start) {
                                scale = this.INITIAL_SCALE;
                                size = this.INITIAL_SIZE;
                            } else {
                                scale = this.FINAL_SCALE;
                                size = this.rippleSize + 'px';
                                if (this.recentering) {
                                    offset = 'translate(' + this.boundWidth / 2 + 'px, ' + this.boundHeight / 2 + 'px)';
                                }
                            }
                            transformString = 'translate(-50%, -50%) ' + offset + scale;
                            this.rippleElement.style.webkitTransform = transformString;
                            this.rippleElement.style.msTransform = transformString;
                            this.rippleElement.style.transform = transformString;
                            if (start) {
                                this.rippleElement.classList.remove('md-ripple-animating');
                            } else {
                                this.rippleElement.classList.add('md-ripple-animating');
                            }
                        }
                    }
                }, {
                    key: 'animFrameHandler',
                    value: function animFrameHandler() {
                        if (this.frameCount-- > 0) {
                            window.requestAnimationFrame(this.animFrameHandler.bind(this));
                        } else {
                            this.setRippleStyles(false);
                        }
                    }
                }, {
                    key: 'elementClicked',
                    value: function elementClicked(event) {}
                }]);

                return MaterialRippleEffect;
            })();

            _export('MaterialRippleEffect', MaterialRippleEffect);
        }
    };
});
System.register("ionic/components/modal/modal", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    "use strict";

    var Injectable, Overlay, Animation, util, __decorate, __metadata, Modal, OVERLAY_TYPE, ModalSlideIn, ModalSlideOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Injectable = _angular2Angular2.Injectable;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Modal = (function (_Overlay) {
                var _class = function Modal() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class, _Overlay);

                _createClass(_class, [{
                    key: "open",
                    value: function open(ComponentType) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        var defaults = {
                            enterAnimation: "modal-slide-in",
                            leaveAnimation: "modal-slide-out"
                        };
                        return this.create(OVERLAY_TYPE, ComponentType, util.extend(defaults, opts));
                    }
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class;
            })(Overlay);

            _export("Modal", Modal);

            _export("Modal", Modal = __decorate([Injectable(), __metadata("design:paramtypes", [])], Modal));
            OVERLAY_TYPE = "modal";

            /**
             * Animations for modals
             */

            ModalSlideIn = (function (_Animation) {
                function ModalSlideIn(element) {
                    _classCallCheck(this, ModalSlideIn);

                    _get(Object.getPrototypeOf(ModalSlideIn.prototype), "constructor", this).call(this, element);
                    this.easing("cubic-bezier(.36,.66,.04,1)").duration(400).fromTo("translateY", "100%", "0%");
                }

                _inherits(ModalSlideIn, _Animation);

                return ModalSlideIn;
            })(Animation);

            Animation.register("modal-slide-in", ModalSlideIn);

            ModalSlideOut = (function (_Animation2) {
                function ModalSlideOut(element) {
                    _classCallCheck(this, ModalSlideOut);

                    _get(Object.getPrototypeOf(ModalSlideOut.prototype), "constructor", this).call(this, element);
                    this.easing("ease-out").duration(250).fromTo("translateY", "0%", "100%");
                }

                _inherits(ModalSlideOut, _Animation2);

                return ModalSlideOut;
            })(Animation);

            Animation.register("modal-slide-out", ModalSlideOut);
        }
    };
});
System.register("ionic/components/nav/anchors", ["angular2/angular2", "angular2/src/core/compiler/view_container_ref", "./pane", "../view/view-controller"], function (_export) {
    "use strict";

    var Component, View, Directive, Ancestor, ElementRef, forwardRef, Inject, ViewContainerRef, Pane, ViewController, __decorate, __metadata, __param, PaneAnchor, PaneContentAnchor, NavBarAnchor, NavBarContainer;

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Inject = _angular2Angular2.Inject;
        }, function (_angular2SrcCoreCompilerView_container_ref) {
            ViewContainerRef = _angular2SrcCoreCompilerView_container_ref.ViewContainerRef;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneAnchor = (function () {
                var _class = function PaneAnchor(pane, elementRef) {
                    _classCallCheck(this, _class);

                    pane.sectionAnchorElementRef = elementRef;
                };

                return _class;
            })();

            _export("PaneAnchor", PaneAnchor);

            _export("PaneAnchor", PaneAnchor = __decorate([Directive({ selector: "template[pane-anchor]" }), __param(0, Ancestor()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof Pane !== "undefined" && Pane || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], PaneAnchor));

            PaneContentAnchor = (function () {
                var _class2 = function PaneContentAnchor(pane, viewContainerRef) {
                    _classCallCheck(this, _class2);

                    pane.contentContainerRef = viewContainerRef;
                };

                return _class2;
            })();

            _export("PaneContentAnchor", PaneContentAnchor);

            _export("PaneContentAnchor", PaneContentAnchor = __decorate([Directive({ selector: "template[content-anchor]" }), __param(0, Ancestor()), __param(0, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof Pane !== "undefined" && Pane || Object, typeof ViewContainerRef !== "undefined" && ViewContainerRef || Object])], PaneContentAnchor));

            NavBarAnchor = (function () {
                var _class3 = function NavBarAnchor(viewCtrl, viewContainerRef) {
                    _classCallCheck(this, _class3);

                    viewCtrl.navbarViewContainer(viewContainerRef);
                };

                return _class3;
            })();

            NavBarAnchor = __decorate([Directive({
                selector: "template[navbar-anchor]"
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ViewContainerRef !== "undefined" && ViewContainerRef || Object])], NavBarAnchor);

            NavBarContainer = (function () {
                var _class4 = function NavBarContainer() {
                    _classCallCheck(this, _class4);
                };

                return _class4;
            })();

            _export("NavBarContainer", NavBarContainer);

            _export("NavBarContainer", NavBarContainer = __decorate([Component({
                selector: "section",
                host: {
                    "class": "navbar-container"
                }
            }), View({
                template: "<template navbar-anchor></template>",
                directives: [NavBarAnchor]
            }), __metadata("design:paramtypes", [])], NavBarContainer));
        }
    };
});
System.register('ionic/components/nav/nav-controller', ['../../util/util'], function (_export) {
    'use strict';

    var extend, NavController, NavParams;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_utilUtil) {
            extend = _utilUtil.extend;
        }],
        execute: function () {
            NavController = (function () {
                function NavController(nav) {
                    _classCallCheck(this, NavController);

                    this._nav = nav;
                }

                _createClass(NavController, [{
                    key: 'setItems',

                    /**
                     * Set the history stack to match the list of component items.
                     */
                    value: function setItems(items) {
                        return this._nav.setItems(items);
                    }
                }, {
                    key: 'clear',

                    /**
                     * Clear the history stack.
                     */
                    value: function clear() {
                        return this._nav.clear();
                    }
                }, {
                    key: 'push',

                    /**
                     * Push an ew component onto the history stack.
                     */
                    value: function push() {
                        return this._nav.push.apply(this._nav, arguments);
                    }
                }, {
                    key: 'pop',

                    /**
                     * Pop the top most (visible) component off the history stack.
                     */
                    value: function pop() {
                        return this._nav.pop.apply(this._nav, arguments);
                    }
                }]);

                return NavController;
            })();

            _export('NavController', NavController);

            NavParams = function NavParams(params) {
                _classCallCheck(this, NavParams);

                extend(this, params);
            };

            _export('NavParams', NavParams);
        }
    };
});
System.register("ionic/components/nav/nav-push", ["angular2/angular2", "./nav-controller"], function (_export) {
    "use strict";

    var Directive, NavController, __decorate, __metadata, NavPush, NavPop;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
        }, function (_navController) {
            NavController = _navController.NavController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            NavPush = (function () {
                var _class = function NavPush(nav) {
                    _classCallCheck(this, _class);

                    this.nav = nav;
                };

                _createClass(_class, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.push(this.navPush, this.pushData);
                    }
                }]);

                return _class;
            })();

            _export("NavPush", NavPush);

            _export("NavPush", NavPush = __decorate([Directive({
                selector: "[nav-push]",
                properties: ["navPush", "pushData"],
                host: {
                    "(^click)": "onClick($event)",
                    "role": "link"
                }
            }), __metadata("design:paramtypes", [typeof NavController !== "undefined" && NavController || Object])], NavPush));

            NavPop = (function () {
                var _class2 = function NavPop(nav) {
                    _classCallCheck(this, _class2);

                    this.nav = nav;
                };

                _createClass(_class2, [{
                    key: "onClick",
                    value: function onClick(event) {
                        this.nav.pop();
                    }
                }]);

                return _class2;
            })();

            _export("NavPop", NavPop);

            _export("NavPop", NavPop = __decorate([Directive({
                selector: "[nav-pop]",
                host: {
                    "(^click)": "onClick($event)",
                    "role": "link"
                }
            }), __metadata("design:paramtypes", [typeof NavController !== "undefined" && NavController || Object])], NavPop));
        }
    };
});
System.register("ionic/components/nav/nav", ["angular2/angular2", "../../config/annotations", "../view/view-controller"], function (_export) {
    "use strict";

    var Directive, View, ElementRef, Ancestor, Optional, forwardRef, Injector, IonicComponent, ViewController, __decorate, __metadata, __param, Nav, NavPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Nav = (function (_ViewController) {
                var _class = function Nav(ancestorViewCtrl, injector, elementRef) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, ancestorViewCtrl, injector, elementRef);
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        if (this.root) {
                            this.push(this.root);
                        }
                        // default the swipe back to be enabled
                        var isSwipeBackEnabled = (this.swipeBackEnabled || "").toString() !== "false";
                        this.isSwipeBackEnabled(isSwipeBackEnabled);
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Nav", Nav);

            _export("Nav", Nav = __decorate([IonicComponent({
                selector: "ion-nav",
                properties: ["root"],
                defaultProperties: {
                    "swipeBackEnabled": true
                }
            }), View({
                template: "<template pane-anchor></template>",
                directives: [forwardRef(function () {
                    return NavPaneAnchor;
                })]
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof Injector !== "undefined" && Injector || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Nav));

            NavPaneAnchor = (function () {
                var _class2 = function NavPaneAnchor(nav, elementRef) {
                    _classCallCheck(this, _class2);

                    nav.anchorElementRef(elementRef);
                };

                return _class2;
            })();

            NavPaneAnchor = __decorate([Directive({ selector: "template[pane-anchor]" }), __param(0, Ancestor()), __metadata("design:paramtypes", [Nav, typeof ElementRef !== "undefined" && ElementRef || Object])], NavPaneAnchor);
        }
    };
});
System.register("ionic/components/nav/pane", ["angular2/angular2", "../ion", "../../config/config", "../view/view-controller", "./swipe-handle", "../../config/annotations", "./anchors"], function (_export) {
    "use strict";

    var View, ElementRef, Inject, forwardRef, Injector, bind, Ion, IonicConfig, ViewController, SwipeHandle, IonicComponent, PaneAnchor, PaneContentAnchor, NavBarContainer, __decorate, __metadata, __param, PaneController, Pane;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _defineProperty(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_swipeHandle) {
            SwipeHandle = _swipeHandle.SwipeHandle;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }, function (_anchors) {
            PaneAnchor = _anchors.PaneAnchor;
            PaneContentAnchor = _anchors.PaneContentAnchor;
            NavBarContainer = _anchors.NavBarContainer;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            PaneController = (function () {
                function PaneController(viewCtrl) {
                    _classCallCheck(this, PaneController);

                    this.panes = {};
                    this.viewCtrl = viewCtrl;
                    this.bindings = Injector.resolve([bind(ViewController).toValue(viewCtrl)]);
                }

                _createClass(PaneController, [{
                    key: "get",
                    value: function get(itemStructure, callback) {
                        var _this = this;

                        // this gets or creates the Pane which similar nav items live in
                        // Nav items with just a navbar/content would all use the same Pane
                        // Tabs and view's without a navbar would get a different Panes
                        var key = itemStructure.key;
                        var viewCtrl = this.viewCtrl;
                        var pane = this.panes[key];
                        if (pane) {
                            // nav pane which the entering component already exists
                            callback(pane);
                        } else {
                            // create a new nav pane
                            this.panes[key] = null;
                            viewCtrl.loader.loadNextToLocation(Pane, viewCtrl.anchorElementRef(), this.bindings).then(function () {
                                // get the pane reference by name
                                pane = _this.panes[key];
                                var sectionAnchorElementRef = pane && pane.sectionAnchorElementRef;
                                if (!sectionAnchorElementRef) {
                                    return callback();
                                }
                                var promises = [];
                                var sectionsToAdd = [];
                                // decide which sections should be added to this Pane, ie: nav bars, footers, etc.
                                // add only the sections it needs
                                if (itemStructure.navbar) {
                                    sectionsToAdd.push(NavBarContainer);
                                }
                                // add the sections which this type of Pane requires
                                sectionsToAdd.forEach(function (SectionClass) {
                                    // as each section is compiled and added to the Pane
                                    // the section will add a reference to itself in the Pane's sections object
                                    promises.push(viewCtrl.loader.loadNextToLocation(SectionClass, sectionAnchorElementRef));
                                });
                                // wait for all of the sections to resolve
                                Promise.all(promises).then(function () {
                                    callback(pane);
                                }, function (err) {
                                    console.error(err);
                                });
                            }, function (loaderErr) {
                                console.error(loaderErr);
                            })["catch"](function (err) {
                                console.error(err);
                            });
                        }
                    }
                }, {
                    key: "add",
                    value: function add(pane) {
                        for (var np in this.panes) {
                            if (this.panes[np] === null) {
                                this.panes[np] = pane;
                                return;
                            }
                        }
                    }
                }]);

                return PaneController;
            })();

            _export("PaneController", PaneController);

            Pane = (function (_Ion) {
                var _class = function Pane(viewCtrl, elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    viewCtrl.panes.add(this);
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "showPane",
                    set: function set(val) {
                        this._showPane = val;
                    },
                    get: function get() {
                        return this._showPane;
                    }
                }]);

                return _class;
            })(Ion);

            _export("Pane", Pane);

            _export("Pane", Pane = __decorate([IonicComponent({
                selector: "ion-pane",
                classId: "nav",
                host: _defineProperty({}, "[class.show-pane]", "showPane")
            }), View({
                template: "\n    <template pane-anchor></template>\n    <section class=\"content-container\">\n      <template content-anchor></template>\n      <div class=\"swipe-handle\"></div>\n    </section>\n  ",
                directives: [PaneAnchor, PaneContentAnchor, SwipeHandle]
            }), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Pane));
        }
    };
});
System.register("ionic/components/nav/swipe-handle", ["angular2/angular2", "../view/view-controller", "./pane", "ionic/gestures/gesture"], function (_export) {
    "use strict";

    var ElementRef, Directive, Ancestor, Optional, Inject, forwardRef, NgZone, ViewController, Pane, Gesture, __decorate, __metadata, __param, SwipeHandle;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            Inject = _angular2Angular2.Inject;
            forwardRef = _angular2Angular2.forwardRef;
            NgZone = _angular2Angular2.NgZone;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_pane) {
            Pane = _pane.Pane;
        }, function (_ionicGesturesGesture) {
            Gesture = _ionicGesturesGesture.Gesture;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            SwipeHandle = (function () {
                var _class = function SwipeHandle(viewCtrl, pane, elementRef, ngZone) {
                    _classCallCheck(this, _class);

                    if (!viewCtrl || !viewCtrl.isSwipeBackEnabled() || !pane) return;
                    var self = this;
                    self.pane = pane;
                    self.viewCtrl = viewCtrl;
                    self.zone = ngZone;
                    this.zone.runOutsideAngular(function () {
                        var gesture = self.gesture = new Gesture(elementRef.nativeElement);
                        gesture.listen();
                        function dragHorizontal(ev) {
                            self.onDragHorizontal(ev);
                        }
                        gesture.on("panend", function (gestureEv) {
                            self.onDragEnd(gestureEv.gesture);
                        });
                        gesture.on("panleft", dragHorizontal);
                        gesture.on("panright", dragHorizontal);
                    });
                    self.startX = null;
                    self.width = null;
                };

                _createClass(_class, [{
                    key: "onDragEnd",
                    value: function onDragEnd(gesture) {
                        var _this = this;

                        gesture.srcEvent.preventDefault();
                        gesture.srcEvent.stopPropagation();
                        // TODO: POLISH THESE NUMBERS WITH GOOD MATHIFICATION
                        var progress = (gesture.center.x - this.startX) / this.width;
                        var completeSwipeBack = progress > 0.5;
                        var playbackRate = 4;
                        if (completeSwipeBack) {
                            // complete swipe back
                            if (progress > 0.9) {
                                playbackRate = 1;
                            } else if (progress > 0.8) {
                                playbackRate = 2;
                            } else if (progress > 0.7) {
                                playbackRate = 3;
                            }
                        } else {
                            // cancel swipe back
                            if (progress < 0.1) {
                                playbackRate = 1;
                            } else if (progress < 0.2) {
                                playbackRate = 2;
                            } else if (progress < 0.3) {
                                playbackRate = 3;
                            }
                        }
                        this.zone.run(function () {
                            _this.viewCtrl.swipeBackEnd(completeSwipeBack, progress, playbackRate);
                        });
                        this.startX = null;
                    }
                }, {
                    key: "onDragHorizontal",
                    value: function onDragHorizontal(gestureEv) {
                        var _this2 = this;

                        this.zone.run(function () {
                            var gesture = gestureEv.gesture;
                            if (_this2.startX === null) {
                                // starting drag
                                gesture.srcEvent.preventDefault();
                                gesture.srcEvent.stopPropagation();
                                _this2.startX = gesture.center.x;
                                _this2.width = _this2.pane.width() - _this2.startX;
                                _this2.viewCtrl.swipeBackStart();
                            }
                            _this2.viewCtrl.swipeBackProgress((gesture.center.x - _this2.startX) / _this2.width);
                        });
                    }
                }, {
                    key: "onDestroy",
                    value: function onDestroy() {
                        this.gesture && this.gesture.destroy();
                    }
                }, {
                    key: "showHandle",
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.canSwipeBack() : false;
                    }
                }]);

                return _class;
            })();

            _export("SwipeHandle", SwipeHandle);

            _export("SwipeHandle", SwipeHandle = __decorate([Directive({
                selector: ".swipe-handle",
                host: {
                    "[class.show-handle]": "showHandle"
                }
            }), __param(0, Optional()), __param(0, Inject(forwardRef(function () {
                return ViewController;
            }))), __param(1, Ancestor()), __param(1, Inject(forwardRef(function () {
                return Pane;
            }))), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof Pane !== "undefined" && Pane || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof NgZone !== "undefined" && NgZone || Object])], SwipeHandle));
        }
    };
});
System.register("ionic/components/nav-bar/nav-bar", ["angular2/angular2", "../toolbar/toolbar", "../../config/config", "../../config/annotations", "../app/app", "../view/view-item"], function (_export) {
    "use strict";

    var Directive, Ancestor, Optional, ElementRef, forwardRef, TemplateRef, ToolbarBase, IonicConfig, IonicComponent, IonicView, IonicApp, ViewItem, __decorate, __metadata, __param, Navbar, BackButton, BackButtonText, Title, NavbarItem, NavbarTemplate;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Ancestor = _angular2Angular2.Ancestor;
            Optional = _angular2Angular2.Optional;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            TemplateRef = _angular2Angular2.TemplateRef;
        }, function (_toolbarToolbar) {
            ToolbarBase = _toolbarToolbar.ToolbarBase;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Navbar = (function (_ToolbarBase) {
                var _class = function Navbar(elementRef, config, app, item) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.app = app;
                    item && item.navbarView(this);
                    this.bbClass = config.setting("backButtonIcon");
                    this.bbDefault = config.setting("backButtonText");
                    this.bbText = "";
                };

                _inherits(_class, _ToolbarBase);

                _createClass(_class, [{
                    key: "backButtonElement",
                    value: function backButtonElement(eleRef) {
                        if (arguments.length) {
                            this._bbEle = eleRef;
                        }
                        return this._bbEle;
                    }
                }, {
                    key: "backButtonTextElement",
                    value: function backButtonTextElement(eleRef) {
                        if (arguments.length) {
                            this._bbTxEle = eleRef;
                        }
                        return this._bbTxEle;
                    }
                }, {
                    key: "didEnter",
                    value: function didEnter() {
                        var titleEle = this._ttEle || (this._ttEle = this.getNativeElement().querySelector("ion-title"));
                        titleEle && this.app.title(titleEle.textContent);
                    }
                }]);

                return _class;
            })(ToolbarBase);

            _export("Navbar", Navbar);

            _export("Navbar", Navbar = __decorate([IonicComponent({
                selector: "ion-navbar",
                host: {
                    "class": "toolbar"
                }
            }), IonicView({
                template: "\n    <div class=\"toolbar-inner\">\n      <button class=\"back-button\">\n        <icon class=\"back-button-icon\" [name]=\"bbClass\"></icon>\n        <span class=\"back-button-text\">\n          <span class=\"back-default\" [text-content]=\"bbDefault\"></span>\n          <span class=\"back-title\" [text-content]=\"bbText\"></span>\n        </span>\n      </button>\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return BackButton;
                }), forwardRef(function () {
                    return BackButtonText;
                }), forwardRef(function () {
                    return Title;
                }), forwardRef(function () {
                    return NavbarItem;
                })]
            }), __param(3, Optional()), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof IonicApp !== "undefined" && IonicApp || Object, typeof ViewItem !== "undefined" && ViewItem || Object])], Navbar));

            BackButton = (function () {
                var _class2 = function BackButton(navbar, item, elementRef) {
                    _classCallCheck(this, _class2);

                    this.item = item;
                    navbar.backButtonElement(elementRef);
                };

                _createClass(_class2, [{
                    key: "goBack",
                    value: function goBack(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.item && this.item.viewCtrl.pop();
                    }
                }]);

                return _class2;
            })();

            BackButton = __decorate([Directive({
                selector: ".back-button",
                host: {
                    "(^click)": "goBack($event)"
                }
            }), __param(0, Ancestor()), __param(1, Optional()), __metadata("design:paramtypes", [Navbar, typeof ViewItem !== "undefined" && ViewItem || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], BackButton);

            BackButtonText = (function () {
                var _class3 = function BackButtonText(navbar, elementRef) {
                    _classCallCheck(this, _class3);

                    navbar.backButtonTextElement(elementRef);
                };

                return _class3;
            })();

            BackButtonText = __decorate([Directive({
                selector: ".back-button-text"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], BackButtonText);

            Title = (function () {
                var _class4 = function Title(toolbar, elementRef) {
                    _classCallCheck(this, _class4);

                    toolbar.titleElement(elementRef);
                };

                return _class4;
            })();

            Title = __decorate([Directive({
                selector: ".toolbar-title"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], Title);

            NavbarItem = (function () {
                var _class5 = function NavbarItem(toolbar, elementRef) {
                    _classCallCheck(this, _class5);

                    toolbar.itemElements(elementRef);
                };

                return _class5;
            })();

            NavbarItem = __decorate([Directive({
                selector: ".toolbar-item"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Navbar, typeof ElementRef !== "undefined" && ElementRef || Object])], NavbarItem);
            /*
              Used to find and register headers in a view, and this directive's
              content will be moved up to the common navbar location, and created
              using the same context as the view's content area.
            */

            NavbarTemplate = (function () {
                var _class6 = function NavbarTemplate(item, templateRef) {
                    _classCallCheck(this, _class6);

                    item && item.addTemplateRef("navbar", templateRef);
                };

                return _class6;
            })();

            _export("NavbarTemplate", NavbarTemplate);

            _export("NavbarTemplate", NavbarTemplate = __decorate([Directive({
                selector: "template[navbar]"
            }), __param(0, Optional()), __param(1, Optional()), __metadata("design:paramtypes", [typeof ViewItem !== "undefined" && ViewItem || Object, typeof TemplateRef !== "undefined" && TemplateRef || Object])], NavbarTemplate));
        }
    };
});
System.register('ionic/components/overlay/overlay', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../../animations/animation', '../../util/click-block', 'ionic/util'], function (_export) {
    'use strict';

    var Component, DirectiveBinding, Animation, ClickBlock, util, Overlay, OverlayRef, ROOT_Z_INDEX;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            Overlay = (function () {
                function Overlay(app, config) {
                    _classCallCheck(this, Overlay);

                    this.app = app;
                    this.mode = config.setting('mode');
                }

                _createClass(Overlay, [{
                    key: 'create',
                    value: function create(overlayType, componentType) {
                        var _this = this;

                        var opts = arguments[2] === undefined ? {} : arguments[2];
                        var context = arguments[3] === undefined ? null : arguments[3];

                        return new Promise(function (resolve, reject) {
                            var app = _this.app;
                            var annotation = new Component({
                                selector: 'ion-' + overlayType,
                                host: {
                                    '[style.z-index]': 'zIndex',
                                    'mode': _this.mode,
                                    'class': overlayType
                                }
                            });
                            var overlayComponentType = DirectiveBinding.createFromType(componentType, annotation);
                            // create a unique token that works as a cache key
                            overlayComponentType.token = overlayType + componentType.name;
                            app.appendComponent(overlayComponentType).then(function (ref) {
                                var overlayRef = new OverlayRef(app, overlayType, opts, ref, context);
                                overlayRef._open(opts).then(function () {
                                    resolve(overlayRef);
                                });
                            })['catch'](function (err) {
                                console.error('Overlay appendComponent:', err);
                                reject(err);
                            });
                        })['catch'](function (err) {
                            console.error('Overlay create:', err);
                        });
                    }
                }, {
                    key: 'getByType',
                    value: function getByType(overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByHandle',
                    value: function getByHandle(handle, overlayType) {
                        if (this.app) {
                            for (var i = this.app.overlays.length - 1; i >= 0; i--) {
                                if (handle === this.app.overlays[i]._handle && overlayType === this.app.overlays[i]._type) {
                                    return this.app.overlays[i];
                                }
                            }
                        }
                        return null;
                    }
                }]);

                return Overlay;
            })();

            _export('Overlay', Overlay);

            OverlayRef = (function () {
                function OverlayRef(app, overlayType, opts, ref, context) {
                    var _this2 = this;

                    _classCallCheck(this, OverlayRef);

                    var overlayInstance = ref && ref.instance;
                    if (!overlayInstance) return;
                    if (context) {
                        util.extend(ref.instance, context);
                    }
                    this._instance = overlayInstance;
                    overlayInstance.viewLoaded && overlayInstance.viewLoaded();
                    this.zIndex = ROOT_Z_INDEX;
                    for (var i = 0; i < app.overlays.length; i++) {
                        if (app.overlays[i].zIndex >= this.zIndex) {
                            this.zIndex = app.overlays[i].zIndex + 1;
                        }
                    }
                    overlayInstance.zIndex = this.zIndex;
                    overlayInstance.overlayRef = this;
                    overlayInstance.close = function (instanceOpts) {
                        _this2.close(instanceOpts);
                    };
                    this._elementRef = ref.location;
                    this._type = overlayType;
                    this._opts = opts;
                    this._handle = opts.handle || this.zIndex;
                    this._dispose = function () {
                        _this2._instance = null;
                        ref.dispose && ref.dispose();
                        util.array.remove(app.overlays, _this2);
                    };
                    app.overlays.push(this);
                }

                _createClass(OverlayRef, [{
                    key: 'getElementRef',
                    value: function getElementRef() {
                        return this._elementRef;
                    }
                }, {
                    key: '_open',
                    value: function _open() {
                        var _this3 = this;

                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this3._instance || {};
                            instance.viewWillEnter && instance.viewWillEnter();
                            var animationName = opts && opts.animation || _this3._opts.enterAnimation;
                            var animation = Animation.create(_this3._elementRef.nativeElement, animationName);
                            animation.before.addClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            animation.play().then(function () {
                                ClickBlock(false);
                                animation.dispose();
                                instance.viewDidEnter && instance.viewDidEnter();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        var _this4 = this;

                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        return new Promise(function (resolve) {
                            var instance = _this4._instance || {};
                            instance.viewWillLeave && instance.viewWillLeave();
                            instance.viewWillUnload && instance.viewWillUnload();
                            var animationName = opts && opts.animation || _this4._opts.leaveAnimation;
                            var animation = Animation.create(_this4._elementRef.nativeElement, animationName);
                            animation.after.removeClass('show-overlay');
                            ClickBlock(true, animation.duration() + 200);
                            animation.play().then(function () {
                                instance.viewDidLeave && instance.viewDidLeave();
                                instance.viewDidUnload && instance.viewDidUnload();
                                _this4._dispose();
                                ClickBlock(false);
                                animation.dispose();
                                resolve();
                            });
                        })['catch'](function (err) {
                            console.error(err);
                        });
                    }
                }]);

                return OverlayRef;
            })();

            _export('OverlayRef', OverlayRef);

            ROOT_Z_INDEX = 1000;
        }
    };
});
System.register("ionic/components/popup/popup", ["angular2/angular2", "../overlay/overlay", "../../animations/animation", "ionic/util"], function (_export) {
    "use strict";

    var formDirectives, Component, View, Injectable, CSSClass, NgIf, NgFor, Overlay, Animation, util, __decorate, __metadata, Popup, OVERLAY_TYPE, StandardPopup, PopupAnimation, PopupPopIn, PopupPopOut;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x8, _x9, _x10) { var _again = true; _function: while (_again) { var object = _x8, property = _x9, receiver = _x10; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x8 = parent; _x9 = property; _x10 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            formDirectives = _angular2Angular2.formDirectives;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Injectable = _angular2Angular2.Injectable;
            CSSClass = _angular2Angular2.CSSClass;
            NgIf = _angular2Angular2.NgIf;
            NgFor = _angular2Angular2.NgFor;
        }, function (_overlayOverlay) {
            Overlay = _overlayOverlay.Overlay;
        }, function (_animationsAnimation) {
            Animation = _animationsAnimation.Animation;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            Popup = (function (_Overlay) {
                var _class = function Popup() {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).apply(this, arguments);
                };

                _inherits(_class, _Overlay);

                _createClass(_class, [{
                    key: "popup",
                    value: function popup(context) {
                        var _this = this;

                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        return new Promise(function (resolve, reject) {
                            var defaults = {
                                enterAnimation: "popup-pop-in",
                                leaveAnimation: "popup-pop-out"
                            };
                            context.promiseResolve = resolve;
                            context.promiseReject = reject;
                            return _this.create(OVERLAY_TYPE, StandardPopup, util.extend(defaults, opts), context);
                        });
                    }
                }, {
                    key: "alert",
                    value: function alert() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var button = {
                            text: "OK",
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [button]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "confirm",
                    value: function confirm() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: "OK",
                            onTap: function onTap(event, popupRef) {}
                        };
                        var cancelButton = {
                            text: "Cancel",
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "prompt",
                    value: function prompt() {
                        var context = arguments[0] === undefined ? {} : arguments[0];
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (typeof context === "string") {
                            context = {
                                title: context
                            };
                        }
                        var okButton = {
                            text: "Ok",
                            onTap: function onTap(event, popupRef) {}
                        };
                        var cancelButton = {
                            text: "Cancel",
                            isCancel: true,
                            onTap: function onTap(event, popupRef) {}
                        };
                        context = util.extend({
                            showPrompt: true,
                            promptPlaceholder: "",
                            cancel: function cancel() {},
                            buttons: [cancelButton, okButton]
                        }, context);
                        return this.popup(context, opts);
                    }
                }, {
                    key: "get",
                    value: function get(handle) {
                        if (handle) {
                            return this.getByHandle(handle, OVERLAY_TYPE);
                        }
                        return this.getByType(OVERLAY_TYPE);
                    }
                }]);

                return _class;
            })(Overlay);

            _export("Popup", Popup);

            _export("Popup", Popup = __decorate([Injectable(), __metadata("design:paramtypes", [])], Popup));
            OVERLAY_TYPE = "popup";

            StandardPopup = (function () {
                var _class2 = function StandardPopup(popup) {
                    _classCallCheck(this, _class2);

                    this.popup = popup;
                };

                _createClass(_class2, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        setTimeout(function () {
                            _this2.element = _this2.overlayRef.getElementRef().nativeElement;
                            _this2.promptInput = _this2.element.querySelector("input");
                            if (_this2.promptInput) {
                                _this2.promptInput.value = "";
                            }
                        });
                    }
                }, {
                    key: "buttonTapped",
                    value: function buttonTapped(button, event) {
                        var promptValue = this.promptInput && this.promptInput.value;
                        var retVal = button.onTap && button.onTap(event, this, {
                            promptValue: promptValue
                        });
                        // If the event.preventDefault() wasn't called, close
                        if (!event.defaultPrevented) {
                            // If this is a cancel button, reject the promise
                            if (button.isCancel) {
                                this.promiseReject();
                            } else {
                                // Resolve with the prompt value
                                this.promiseResolve(promptValue);
                            }
                            return this.overlayRef.close();
                        }
                    }
                }, {
                    key: "_cancel",
                    value: function _cancel(event) {
                        this.cancel && this.cancel(event);
                        if (!event.defaultPrevented) {
                            this.promiseReject();
                            return this.overlayRef.close();
                        }
                    }
                }]);

                return _class2;
            })();

            StandardPopup = __decorate([Component({
                selector: "ion-popup-default"
            }), View({
                template: "<backdrop (click)=\"_cancel($event)\" tappable></backdrop>" + "<popup-wrapper>" + "<div class=\"popup-head\">" + "<h3 class=\"popup-title\" [inner-html]=\"title\"></h3>" + "<h5 class=\"popup-sub-title\" [inner-html]=\"subTitle\" *ng-if=\"subTitle\"></h5>" + "</div>" + "<div class=\"popup-body\">" + "<input type=\"text\" *ng-if=\"showPrompt\" placeholder=\"{{promptPlaceholder}}\">" + "</div>" + "<div class=\"popup-buttons\" *ng-if=\"buttons.length\">" + "<button *ng-for=\"#button of buttons\" (click)=\"buttonTapped(button, $event)\" class=\"button\" [class]=\"button.type || 'button-default'\" [inner-html]=\"button.text\"></button>" + "</div>" + "</popup-wrapper>",
                directives: [formDirectives, CSSClass, NgIf, NgFor]
            }), __metadata("design:paramtypes", [Popup])], StandardPopup);

            PopupAnimation = (function (_Animation) {
                function PopupAnimation(element) {
                    _classCallCheck(this, PopupAnimation);

                    _get(Object.getPrototypeOf(PopupAnimation.prototype), "constructor", this).call(this, element);
                    this.easing("ease-in-out").duration(200);
                    this.backdrop = new Animation(element.querySelector("backdrop"));
                    this.wrapper = new Animation(element.querySelector("popup-wrapper"));
                    this.add(this.backdrop, this.wrapper);
                }

                _inherits(PopupAnimation, _Animation);

                return PopupAnimation;
            })(Animation);

            /**
             * Animations for modals
             */

            PopupPopIn = (function (_PopupAnimation) {
                function PopupPopIn(element) {
                    _classCallCheck(this, PopupPopIn);

                    _get(Object.getPrototypeOf(PopupPopIn.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo("opacity", "0", "1");
                    this.wrapper.fromTo("scale", "1.1", "1");
                    this.backdrop.fromTo("opacity", "0", "0.3");
                }

                _inherits(PopupPopIn, _PopupAnimation);

                return PopupPopIn;
            })(PopupAnimation);

            Animation.register("popup-pop-in", PopupPopIn);

            PopupPopOut = (function (_PopupAnimation2) {
                function PopupPopOut(element) {
                    _classCallCheck(this, PopupPopOut);

                    _get(Object.getPrototypeOf(PopupPopOut.prototype), "constructor", this).call(this, element);
                    this.wrapper.fromTo("opacity", "1", "0");
                    this.wrapper.fromTo("scale", "1", "0.9");
                    this.backdrop.fromTo("opacity", "0.3", "0");
                }

                _inherits(PopupPopOut, _PopupAnimation2);

                return PopupPopOut;
            })(PopupAnimation);

            Animation.register("popup-pop-out", PopupPopOut);
        }
    };
});

// Allow it to close
//resolve();

//reject();

// Allow it to close

// Allow it to close

// Allow it to close

// Allow it to close
System.register("ionic/components/radio/radio", ["angular2/angular2", "../../config/annotations", "../../config/config", "../ion", "../form/form"], function (_export) {
    "use strict";

    var ElementRef, Ancestor, NgControl, Renderer, IonicDirective, IonicComponent, IonicView, IonicConfig, Ion, IonInputItem, __decorate, __metadata, __param, groupName, RadioGroup, RadioButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            NgControl = _angular2Angular2.NgControl;
            Renderer = _angular2Angular2.Renderer;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_formForm) {
            IonInputItem = _formForm.IonInputItem;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            groupName = -1;

            RadioGroup = (function (_Ion) {
                var _class = function RadioGroup(cd, renderer, elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this._name = ++groupName;
                    this.buttons = [];
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    cd.valueAccessor = this;
                    this.value = "";
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "registerButton",
                    value: function registerButton(radioButton) {
                        this.buttons.push(radioButton);
                        var inputEl = radioButton.input.elementRef.nativeElement;
                        if (!inputEl.hasAttribute("name")) {
                            radioButton.input.name = this._name;
                        }
                    }
                }, {
                    key: "update",

                    //from clicking the label or switching inputs with keyboard
                    //view -> model (Control)
                    value: function update(input) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                button.input.checked = false;
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        input.checked = true;
                        this.onChange(input.value);
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(value) {
                        this.value = value;
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.input.checked = button.input.value == value;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(Ion);

            _export("RadioGroup", RadioGroup);

            _export("RadioGroup", RadioGroup = __decorate([IonicDirective({
                selector: "ion-radio-group",
                host: {
                    "class": "list"
                }
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], RadioGroup));

            RadioButton = (function (_IonInputItem) {
                var _class2 = function RadioButton(group, elementRef, config) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, elementRef, config);
                    this.group = group;
                };

                _inherits(_class2, _IonInputItem);

                _createClass(_class2, [{
                    key: "registerInput",
                    value: function registerInput(input) {
                        this.input = input;
                        this.group.registerButton(this);
                    }
                }, {
                    key: "toggle",

                    //from clicking the label or switching inputs with keyboard
                    //view -> model (Control)
                    value: function toggle() {
                        this.group.update(this.input);
                    }
                }]);

                return _class2;
            })(IonInputItem);

            _export("RadioButton", RadioButton);

            _export("RadioButton", RadioButton = __decorate([IonicComponent({
                selector: "ion-radio",
                host: {
                    "class": "item",
                    "[attr.aria-checked]": "input.checked"
                }
            }), IonicView({
                template: "<div class=\"item-content\">" + "<ng-content></ng-content>" + "</div>" + "<div class=\"item-media media-radio\">" + "<div class=\"radio-icon\"></div>" + "</div>"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [RadioGroup, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], RadioButton));
        }
    };
});
System.register("ionic/components/scroll/pull-to-refresh", ["angular2/angular2", "../content/content", "ionic/util", "ionic/util/dom"], function (_export) {
    "use strict";

    var Component, View, NgIf, CSSClass, ElementRef, EventEmitter, Ancestor, onInit, Content, util, raf, CSS, __decorate, __metadata, __param, Refresher;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            NgIf = _angular2Angular2.NgIf;
            CSSClass = _angular2Angular2.CSSClass;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Ancestor = _angular2Angular2.Ancestor;
            onInit = _angular2Angular2.onInit;
        }, function (_contentContent) {
            Content = _contentContent.Content;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }, function (_ionicUtilDom) {
            raf = _ionicUtilDom.raf;
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Refresher = (function () {
                var _class = function Refresher(content, element) {
                    _classCallCheck(this, _class);

                    this.ele = element.nativeElement;
                    this.ele.classList.add("content");
                    this.content = content;
                    this.refresh = new EventEmitter("refresh");
                    this.starting = new EventEmitter("starting");
                    this.pulling = new EventEmitter("pulling");
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.initEvents();
                    }
                }, {
                    key: "initEvents",
                    value: function initEvents() {
                        var sp = this.content.getNativeElement();
                        var sc = this.content.scrollElement;
                        this.isDragging = false;
                        this.isOverscrolling = false;
                        this.dragOffset = 0;
                        this.lastOverscroll = 0;
                        this.ptrThreshold = 60;
                        this.activated = false;
                        this.scrollTime = 500;
                        this.startY = null;
                        this.deltaY = null;
                        this.canOverscroll = true;
                        this.scrollAncestor = sp;
                        this.scrollChild = sc;
                        util.defaults(this, {
                            pullingIcon: "ion-android-arrow-down",
                            refreshingIcon: "ion-ionic"
                        });
                        this.showSpinner = !util.isDefined(this.refreshingIcon) && this.spinner != "none";
                        this.showIcon = util.isDefined(this.refreshingIcon);
                        this._touchMoveListener = this._handleTouchMove.bind(this);
                        this._touchEndListener = this._handleTouchEnd.bind(this);
                        this._handleScrollListener = this._handleScroll.bind(this);
                        sc.addEventListener("touchmove", this._touchMoveListener);
                        sc.addEventListener("touchend", this._touchEndListener);
                        sc.addEventListener("scroll", this._handleScrollListener);
                    }
                }, {
                    key: "onDehydrate",
                    value: function onDehydrate() {
                        console.log("DEHYDRATION");
                        var sc = this.content.scrollElement;
                        sc.removeEventListener("touchmove", this._touchMoveListener);
                        sc.removeEventListener("touchend", this._touchEndListener);
                        sc.removeEventListener("scroll", this._handleScrollListener);
                    }
                }, {
                    key: "overscroll",
                    value: function overscroll(val) {
                        this.scrollChild.style[CSS.transform] = "translateY(" + val + "px)";
                        this.lastOverscroll = val;
                    }
                }, {
                    key: "nativescroll",
                    value: function nativescroll(target, newScrollTop) {
                        // creates a scroll event that bubbles, can be cancelled, and with its view
                        // and detail property initialized to window and 1, respectively
                        target.scrollTop = newScrollTop;
                        var e = document.createEvent("UIEvents");
                        e.initUIEvent("scroll", true, true, window, 1);
                        target.dispatchEvent(e);
                    }
                }, {
                    key: "setScrollLock",
                    value: function setScrollLock(enabled) {
                        var _this = this;

                        // set the scrollbar to be position:fixed in preparation to overscroll
                        // or remove it so the app can be natively scrolled
                        if (enabled) {
                            raf(function () {
                                _this.scrollChild.classList.add("overscroll");
                                _this.show();
                            });
                        } else {
                            raf(function () {
                                _this.scrollChild.classList.remove("overscroll");
                                _this.hide();
                                _this.deactivate();
                            });
                        }
                    }
                }, {
                    key: "activate",
                    value: function activate() {
                        //this.ele.classList.add('active');
                        this.isActive = true;
                        //this.starting.next();
                    }
                }, {
                    key: "deactivate",
                    value: function deactivate() {
                        var _this2 = this;

                        // give tail 150ms to finish
                        setTimeout(function () {
                            _this2.isActive = false;
                            _this2.isRefreshing = false;
                            _this2.isRefreshingTail = false;
                            // deactivateCallback
                            if (_this2.activated) _this2.activated = false;
                        }, 150);
                    }
                }, {
                    key: "start",
                    value: function start() {
                        // startCallback
                        this.isRefreshing = true;
                        this.refresh.next(this);
                        //$scope.$onRefresh();
                    }
                }, {
                    key: "show",
                    value: function show() {
                        // showCallback
                        this.ele.classList.remove("invisible");
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        // showCallback
                        this.ele.classList.add("invisible");
                    }
                }, {
                    key: "tail",
                    value: function tail() {
                        // tailCallback
                        this.ele.classList.add("refreshing-tail");
                    }
                }, {
                    key: "complete",
                    value: function complete() {
                        var _this3 = this;

                        setTimeout(function () {
                            raf(_this3.tail.bind(_this3));
                            // scroll back to home during tail animation
                            _this3.scrollTo(0, _this3.scrollTime, _this3.deactivate.bind(_this3));
                            // return to native scrolling after tail animation has time to finish
                            setTimeout(function () {
                                if (_this3.isOverscrolling) {
                                    _this3.isOverscrolling = false;
                                    _this3.setScrollLock(false);
                                }
                            }, _this3.scrollTime);
                        }, this.scrollTime);
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(Y, duration, callback) {
                        // scroll animation loop w/ easing
                        // credit https://gist.github.com/dezinezync/5487119
                        var start = Date.now(),
                            from = this.lastOverscroll;
                        if (from === Y) {
                            callback();
                            return; /* Prevent scrolling to the Y point if already there */
                        }
                        // decelerating to zero velocity
                        function easeOutCubic(t) {
                            return --t * t * t + 1;
                        }
                        // scroll loop
                        function scroll() {
                            var currentTime = Date.now(),
                                time = Math.min(1, (currentTime - start) / duration),

                            // where .5 would be 50% of time on a linear scale easedT gives a
                            // fraction based on the easing method
                            easedT = easeOutCubic(time);
                            this.overscroll(parseInt(easedT * (Y - from) + from, 10));
                            if (time < 1) {
                                raf(scroll.bind(this));
                            } else {
                                if (Y < 5 && Y > -5) {
                                    this.isOverscrolling = false;
                                    this.setScrollLock(false);
                                }
                                callback && callback();
                            }
                        }
                        // start scroll loop
                        raf(scroll.bind(this));
                    }
                }, {
                    key: "_handleTouchMove",
                    value: function _handleTouchMove(e) {
                        //console.log('TOUCHMOVE', e);
                        // if multitouch or regular scroll event, get out immediately
                        if (!this.canOverscroll || e.touches.length > 1) {
                            return;
                        }
                        //if this is a new drag, keep track of where we start
                        if (this.startY === null) {
                            this.startY = parseInt(e.touches[0].screenY, 10);
                        }
                        // kitkat fix for touchcancel events http://updates.html5rocks.com/2014/05/A-More-Compatible-Smoother-Touch
                        /*
                        if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && scrollAncestor.scrollTop === 0) {
                          isDragging = true;
                          e.preventDefault();
                        }
                        */
                        // how far have we dragged so far?
                        this.deltaY = parseInt(e.touches[0].screenY, 10) - this.startY;
                        // if we've dragged up and back down in to native scroll territory
                        if (this.deltaY - this.dragOffset <= 0 || this.scrollAncestor.scrollTop !== 0) {
                            if (this.isOverscrolling) {
                                this.isOverscrolling = false;
                                this.setScrollLock(false);
                            }
                            if (this.isDragging) {
                                this.nativescroll(this.scrollAncestor, parseInt(this.deltaY - this.dragOffset, 10) * -1);
                            }
                            // if we're not at overscroll 0 yet, 0 out
                            if (this.lastOverscroll !== 0) {
                                this.overscroll(0);
                            }
                            return;
                        } else if (this.deltaY > 0 && this.scrollAncestor.scrollTop === 0 && !this.isOverscrolling) {
                            // starting overscroll, but drag started below scrollTop 0, so we need to offset the position
                            this.dragOffset = this.deltaY;
                        }
                        // prevent native scroll events while overscrolling
                        e.preventDefault();
                        // if not overscrolling yet, initiate overscrolling
                        if (!this.isOverscrolling) {
                            this.isOverscrolling = true;
                            this.setScrollLock(true);
                        }
                        this.isDragging = true;
                        // overscroll according to the user's drag so far
                        this.overscroll(parseInt((this.deltaY - this.dragOffset) / 3, 10));
                        // Pass an incremental pull amount to the EventEmitter
                        this.pulling.next(this.lastOverscroll);
                        // update the icon accordingly
                        if (!this.activated && this.lastOverscroll > this.ptrThreshold) {
                            this.activated = true;
                            raf(this.activate.bind(this));
                        } else if (this.activated && this.lastOverscroll < this.ptrThreshold) {
                            this.activated = false;
                            raf(this.deactivate.bind(this));
                        }
                    }
                }, {
                    key: "_handleTouchEnd",
                    value: function _handleTouchEnd(e) {
                        console.log("TOUCHEND", e);
                        // if this wasn't an overscroll, get out immediately
                        if (!this.canOverscroll && !this.isDragging) {
                            return;
                        }
                        // reset Y
                        this.startY = null;
                        // the user has overscrolled but went back to native scrolling
                        if (!this.isDragging) {
                            this.dragOffset = 0;
                            this.isOverscrolling = false;
                            this.setScrollLock(false);
                        } else {
                            this.isDragging = false;
                            this.dragOffset = 0;
                            // the user has scroll far enough to trigger a refresh
                            if (this.lastOverscroll > this.ptrThreshold) {
                                this.start();
                                this.scrollTo(this.ptrThreshold, this.scrollTime);
                            } else {
                                this.scrollTo(0, this.scrollTime, this.deactivate.bind(this));
                                this.isOverscrolling = false;
                            }
                        }
                    }
                }, {
                    key: "_handleScroll",
                    value: function _handleScroll(e) {
                        console.log("SCROLL", e.target.scrollTop);
                    }
                }]);

                return _class;
            })();

            _export("Refresher", Refresher);

            _export("Refresher", Refresher = __decorate([Component({
                selector: "ion-refresher",
                events: ["refresh", "starting", "pulling"],
                properties: ["pullingIcon", "pullingText", "refreshingIcon", "refreshingText", "spinner", "disablePullingRotation"],
                host: {
                    "[class.active]": "isActive",
                    "[class.refreshing]": "isRefreshing",
                    "[class.refreshingTail]": "isRefreshingTail"
                },
                lifecycle: [onInit]
            }), View({
                template: "<div class=\"refresher-content\" [class.refresher-with-text]=\"pullingText || refreshingText\">\n      <div class=\"icon-pulling\">\n        <i class=\"icon\" [class]=\"pullingIcon\"></i>\n      </div>\n      <div class=\"text-pulling\" [inner-html]=\"pullingText\" *ng-if=\"pullingText\"></div>\n      <div class=\"icon-refreshing\">\n        <!--<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>-->\n        <i class=\"icon\" [class]=\"refreshingIcon\"></i>\n      </div>\n      <div class=\"text-refreshing\" [inner-html]=\"refreshingText\" *ng-if=\"refreshingText\"></div>\n    </div>",
                directives: [NgIf, CSSClass]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [typeof Content !== "undefined" && Content || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Refresher));
        }
    };
});
System.register("ionic/components/scroll/scroll", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var View, ElementRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, Scroll;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            /**
             * ion-scroll is a non-flexboxed scroll area that can
             * scroll horizontally or vertically.
             */

            Scroll = (function (_Ion) {
                var _class = function Scroll(elementRef, ionicConfig) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    setTimeout(function () {
                        _this.scrollElement = _this.getNativeElement().children[0];
                    });
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "addScrollEventListener",
                    value: function addScrollEventListener(handler) {
                        var _this2 = this;

                        if (!this.scrollElement) {
                            return;
                        }
                        this.scrollElement.addEventListener("scroll", handler);
                        return function () {
                            _this2.scrollElement.removeEventListener("scroll", handler);
                        };
                    }
                }]);

                return _class;
            })(Ion);

            _export("Scroll", Scroll);

            _export("Scroll", Scroll = __decorate([IonicComponent({
                selector: "ion-scroll",
                properties: ["scrollX", "scrollY"],
                host: {
                    "[class.scroll-x]": "scrollX",
                    "[class.scroll-y]": "scrollY"
                }
            }), View({
                template: "<div class=\"scroll-content\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Scroll));
        }
    };
});
System.register("ionic/components/search-bar/search-bar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Ion, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, SearchBar;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            SearchBar = (function (_Ion) {
                var _class = function SearchBar(elementRef, ionicConfig //,
                ) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    // this.controlDirective = cd;
                    // cd.valueAccessor = this; //ControlDirective should inject CheckboxControlDirective
                    this.query = "";
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "writeValue",

                    /**
                     * Much like ngModel, this is called from our valueAccessor for the attached
                     * ControlDirective to update the value internally.
                     */
                    value: function writeValue(value) {
                        this.value = value;
                    }
                }, {
                    key: "inputChanged",
                    value: function inputChanged(event) {
                        this.value = event.target.value;
                        console.log("Search changed", this.value);
                        // TODO: Better way to do this?
                        this.controlDirective._control().updateValue(event.target.value);
                    }
                }, {
                    key: "inputFocused",
                    value: function inputFocused() {
                        this.isFocused = true;
                        this.shouldLeftAlign = true;
                    }
                }, {
                    key: "inputBlurred",
                    value: function inputBlurred() {
                        this.isFocused = false;
                        this.shouldLeftAlign = this.value.trim() != "";
                    }
                }]);

                return _class;
            })(Ion);

            _export("SearchBar", SearchBar);

            _export("SearchBar", SearchBar = __decorate([IonicComponent({
                selector: "ion-search-bar",
                properties: ["list", "query"],
                defaultProperties: {
                    "cancelText": "Cancel",
                    "placeholder": "Search"
                }
            }), IonicView({
                template: "\n  <div class=\"search-bar-input-container\" [class.left-align]=\"shouldLeftAlign\">\n    <div class=\"search-bar-icon\"></div>\n    <input (focus)=\"inputFocused()\" (blur)=\"inputBlurred()\"\n    (input)=\"inputChanged($event)\" class=\"search-bar-input\" type=\"search\" [attr.placeholder]=\"placeholder\">\n  </div>\n  <button class=\"search-bar-cancel\">{{cancelText}}</button>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], SearchBar));
            /*
            export class SearchPipe extends Pipe {
              constructor() {
                super();
                this.state = 0;
              }
            
              supports(newValue) {
                return true;
              }
            
              transform(value, ...args) {
                console.log('Transforming', value, args);
                return value;
                //return `${value} state:${this.state ++}`;
              }
            
              create(cdRef) {
                console.log('REF', cdRef);
                return new SearchPipe(cdRef);
              }
            }
            */
        }
    };
});
System.register("ionic/components/segment/segment", ["angular2/angular2", "angular2/forms", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var View, Renderer, ElementRef, EventEmitter, Ancestor, forwardRef, NgControl, Ion, IonicConfig, IonicDirective, IonicComponent, __decorate, __metadata, __param, Segment, SegmentControlValueAccessor, SegmentButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            View = _angular2Angular2.View;
            Renderer = _angular2Angular2.Renderer;
            ElementRef = _angular2Angular2.ElementRef;
            EventEmitter = _angular2Angular2.EventEmitter;
            Ancestor = _angular2Angular2.Ancestor;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_angular2Forms) {
            NgControl = _angular2Forms.NgControl;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicDirective = _configAnnotations.IonicDirective;
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Segment = (function (_Ion) {
                var _class = function Segment(cd, elementRef, ionicConfig, renderer) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.ele = elementRef.nativeElement;
                    this.elementRef = elementRef;
                    this.renderer = renderer;
                    this.change = new EventEmitter("change");
                    this.input = new EventEmitter("input");
                    this.cd = cd;
                    this.buttons = [];
                };

                _inherits(_class, _Ion);

                _createClass(_class, [{
                    key: "register",

                    /**
                     * Called by child SegmentButtons to bind themselves to
                     * the Segment.
                     */
                    value: function register(segmentButton) {
                        this.buttons.push(segmentButton);
                        // If this button is registered and matches our value,
                        // make sure to select it
                        if (this.value == segmentButton.value) {
                            this.selected(segmentButton);
                        }
                    }
                }, {
                    key: "selectFromValue",

                    /**
                     * Select the button with the given value.
                     */
                    value: function selectFromValue(value) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.buttons[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var button = _step.value;

                                if (button.value === value) {
                                    button.isActive = true;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator["return"]) {
                                    _iterator["return"]();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    }
                }, {
                    key: "selected",

                    /**
                     * Indicate a button should be selected.
                     */
                    value: function selected(segmentButton) {
                        var _this = this;

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            for (var _iterator2 = this.buttons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var button = _step2.value;

                                button.isActive = false;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
                                    _iterator2["return"]();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }

                        segmentButton.isActive = true;
                        //this.onChange();
                        setTimeout(function () {
                            _this.value = segmentButton.value;
                            _this.cd.valueAccessor.writeValue(segmentButton.value);
                            _this.selectFromValue(segmentButton.value);
                            _this.cd.control.updateValue(segmentButton.value);
                            // Trigger on change
                            _this.change.next();
                        });
                        //this.ngControl.control().updateValue(this.value);
                        // TODO: Better way to do this?
                        //this.controlDirective._control().updateValue(this.value);
                    }
                }]);

                return _class;
            })(Ion);

            _export("Segment", Segment);

            _export("Segment", Segment = __decorate([IonicComponent({
                selector: "ion-segment",
                appInjector: [NgControl],
                properties: ["value"],
                host: {
                    "(click)": "buttonClicked($event)",
                    "(change)": "onChange($event)"
                }
            }), View({
                template: "<div class=\"ion-segment\"><ng-content></ng-content></div>",
                directives: [forwardRef(function () {
                    return SegmentButton;
                })]
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object, typeof Renderer !== "undefined" && Renderer || Object])], Segment));

            SegmentControlValueAccessor = (function () {
                var _class2 = function SegmentControlValueAccessor(cd, renderer, elementRef, segment) {
                    _classCallCheck(this, _class2);

                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.cd = cd;
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.segment = segment;
                    cd.valueAccessor = this;
                };

                _createClass(_class2, [{
                    key: "writeValue",
                    value: function writeValue(value) {
                        // both this.value and setProperty are required at the moment
                        // remove when a proper imperative API is provided
                        this.value = !value ? "" : value;
                        this.renderer.setElementProperty(this.elementRef, "value", this.value);
                        this.segment.value = this.value;
                        this.segment.selectFromValue(value);
                    }
                }, {
                    key: "registerOnChange",
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class2;
            })();

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor);

            _export("SegmentControlValueAccessor", SegmentControlValueAccessor = __decorate([IonicDirective({
                selector: "ion-segment",
                //properties: ['value'],
                host: {
                    "(change)": "onChange($event.target.value)",
                    "(input)": "onChange($event.target.value)",
                    "(blur)": "onTouched()"
                }
            }), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, Segment])], SegmentControlValueAccessor));

            SegmentButton = (function () {
                var _class3 = function SegmentButton(segment, elementRef) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.ele;
                    this.segment = segment;
                };

                _createClass(_class3, [{
                    key: "onInit",
                    value: function onInit() {
                        this.segment.register(this);
                    }
                }, {
                    key: "buttonClicked",
                    value: function buttonClicked(event) {
                        this.segment.selected(this, event);
                        event.preventDefault();
                    }
                }]);

                return _class3;
            })();

            _export("SegmentButton", SegmentButton);

            _export("SegmentButton", SegmentButton = __decorate([IonicDirective({
                selector: "ion-segment-button",
                properties: ["value"],
                host: {
                    "(click)": "buttonClicked($event)",
                    "[class.active]": "isActive"
                }
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Segment, typeof ElementRef !== "undefined" && ElementRef || Object])], SegmentButton));
        }
    };
});
System.register("ionic/components/show-hide-when/show-hide-when", ["angular2/angular2", "../../platform/platform"], function (_export) {
    "use strict";

    var Directive, Attribute, NgZone, Platform, __decorate, __metadata, __param, DisplayWhen, ShowWhen, HideWhen;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Attribute = _angular2Angular2.Attribute;
            NgZone = _angular2Angular2.NgZone;
        }, function (_platformPlatform) {
            Platform = _platformPlatform.Platform;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            DisplayWhen = (function () {
                function DisplayWhen(conditions, ngZone) {
                    var _this = this;

                    _classCallCheck(this, DisplayWhen);

                    this.isMatch = false;
                    if (!conditions) return;
                    this.conditions = conditions.split(",");
                    // check if its one of the matching platforms first
                    // a platform does not change during the life of an app
                    for (var i = 0; i < this.conditions.length; i++) {
                        if (this.conditions[i] && Platform.is(this.conditions[i])) {
                            this.isMatch = true;
                            return;
                        }
                    }
                    if (this.orientation()) {
                        // add window resize listener
                        Platform.onResize(function () {
                            ngZone.run(function () {
                                _this.orientation();
                            });
                        });
                        return;
                    }
                }

                _createClass(DisplayWhen, [{
                    key: "orientation",
                    value: function orientation() {
                        for (var i = 0; i < this.conditions.length; i++) {
                            var condition = this.conditions[i];
                            if (condition == "portrait") {
                                this.isMatch = Platform.isPortrait();
                                return true;
                            }
                            if (condition == "landscape") {
                                this.isMatch = Platform.isLandscape();
                                return true;
                            }
                        }
                    }
                }]);

                return DisplayWhen;
            })();

            ShowWhen = (function (_DisplayWhen) {
                var _class = function ShowWhen(showWhen, ngZone) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, showWhen, ngZone);
                };

                _inherits(_class, _DisplayWhen);

                _createClass(_class, [{
                    key: "hidden",
                    get: function get() {
                        return !this.isMatch;
                    }
                }]);

                return _class;
            })(DisplayWhen);

            _export("ShowWhen", ShowWhen);

            _export("ShowWhen", ShowWhen = __decorate([Directive({
                selector: "[show-when]",
                host: {
                    "[hidden]": "hidden"
                }
            }), __param(0, Attribute("show-when")), __metadata("design:paramtypes", [String, typeof NgZone !== "undefined" && NgZone || Object])], ShowWhen));

            HideWhen = (function (_DisplayWhen2) {
                var _class2 = function HideWhen(hideWhen, ngZone) {
                    _classCallCheck(this, _class2);

                    _get(Object.getPrototypeOf(_class2.prototype), "constructor", this).call(this, hideWhen, ngZone);
                };

                _inherits(_class2, _DisplayWhen2);

                _createClass(_class2, [{
                    key: "hidden",
                    get: function get() {
                        return this.isMatch;
                    }
                }]);

                return _class2;
            })(DisplayWhen);

            _export("HideWhen", HideWhen);

            _export("HideWhen", HideWhen = __decorate([Directive({
                selector: "[hide-when]",
                host: {
                    "[hidden]": "hidden"
                }
            }), __param(0, Attribute("hide-when")), __metadata("design:paramtypes", [String, typeof NgZone !== "undefined" && NgZone || Object])], HideWhen));
        }
    };
});
System.register("ionic/components/slides/slides", ["angular2/angular2", "ionic/gestures/drag-gesture", "../../config/annotations", "ionic/util"], function (_export) {
    "use strict";

    var Component, View, ElementRef, Ancestor, NgFor, DragGesture, IonicComponent, IonicDirective, dom, util, __decorate, __metadata, __param, Slides, Slide, SlidePager, SlidesGesture;

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            ElementRef = _angular2Angular2.ElementRef;
            Ancestor = _angular2Angular2.Ancestor;
            NgFor = _angular2Angular2.NgFor;
        }, function (_ionicGesturesDragGesture) {
            DragGesture = _ionicGesturesDragGesture.DragGesture;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicDirective = _configAnnotations.IonicDirective;
        }, function (_ionicUtil) {
            dom = _ionicUtil.dom;
            util = _ionicUtil;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            /**
             * Slides is a slide box implementation based off of swipe.js
             * and the ionic1 implementation.
             *
             * May 21st, 2015
             * @maxlynch
             *
             * * TODO: Finish the slideshow, should continue on transition end or a
             *         similar event.
             * * TODO: Add support for 2 slide cloning
             * * TODO: Test support for N-slide sliding (like go 2 slides ahead)
             * * TODO: Analyze performance, add request animation frame if necessary
             * * TODO: Test mouse support
             * * TODO: Port over mouse handling
             */

            Slides = (function () {
                var _class = function Slides(elementRef) {
                    _classCallCheck(this, _class);

                    // Grab the main container, and the slides-view wrapper
                    this.ele = elementRef.nativeElement;
                    this.slides = [];
                    this.currentIndex = 0;
                    // How quickly to animate between slides
                    this.animateSpeed = 300;
                    // How often to switch slides automatically. Zero is no auto sliding
                    this.slideDelay = 0; //3000;
                    // Whether to bounce on the edges if not continuous (overscrolling)
                    this.bounce = false;
                    // Initialize our slides gesture handler
                    this.gesture = new SlidesGesture(this);
                    this.gesture.listen();
                };

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        this.continuous = util.isDefined(this.loop) && (this.slides.length > 1 ? true : false);
                        // Grab the wrapper element that contains the slides
                        this.wrapperElement = this.ele.children[0];
                        this.resize();
                        if (this.slideDelay) {
                            this.startShow();
                        }
                        //special case if two slides
                        /*
                        if (this.continuous && this.slides.length < 3) {
                          this.element.appendChild(this.slides[0].clone())//cloneNode(true));
                          element.appendChild(element.children[1].cloneNode(true));
                          slides = element.children;
                        }
                        */
                    }
                }, {
                    key: "startShow",

                    /**
                     * Start the slideshow.
                     */
                    value: function startShow() {
                        this._showTimeout = setTimeout(this.next.bind(this), this.slideDelay);
                    }
                }, {
                    key: "stopShow",

                    /**
                     * End the slideshow.
                     */
                    value: function stopShow() {
                        clearTimeout(this._showTimout);
                    }
                }, {
                    key: "setPager",

                    /**
                     * Set the pager element for handling rendering of page icons and
                     * switching slides through clicks, etc.
                     */
                    value: function setPager(pager) {
                        this._pager = pager;
                    }
                }, {
                    key: "resize",
                    value: function resize() {
                        // Get the width of the container, which is the viewport
                        // that the user will actually see.
                        this.containerWidth = this.ele.offsetWidth || this.ele.getBoundingClientRect().width;
                        // Set the wrapper element to the total width of the child elements
                        this.wrapperElement.style.width = this.containerWidth * this.slides.length + "px";
                        // Position all the child slides
                        this._bump();
                    }
                }, {
                    key: "add",

                    /**
                     * Add a new slide to the slides.
                     */
                    value: function add(slide) {
                        this._append(slide);
                    }
                }, {
                    key: "slide",
                    value: function slide(to, slideSpeed) {
                        var index = this.currentIndex;
                        var width = this.containerWidth;
                        // do nothing if already on requested slide
                        if (index == to) return;
                        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward
                        // get the actual position of the slide
                        if (this.continuous) {
                            var natural_direction = direction;
                            direction = -this.slides[this._circle(to)].x / width;
                            // if going forward but to < index, use to = slides.length + to
                            // if going backward but to > index, use to = -slides.length + to
                            if (direction !== natural_direction) to = -direction * this.slides.length + to;
                        }
                        var diff = Math.abs(index - to) - 1;
                        // move all the slides between index and to in the right direction
                        while (diff--) this._move(this._circle((to > index ? to : index) - diff - 1), width * direction, 0);
                        to = this._circle(to);
                        this._move(index, width * direction, slideSpeed || this.animateSpeed);
                        this._move(to, 0, slideSpeed || this.animateSpeed);
                        if (this.continuous) this._move(this._circle(to - direction), -(width * direction), 0); // we need to get the next in place
                        this.currentIndex = to;
                        //offloadFn(options.callback && options.callback(index, slides[index]));
                    }
                }, {
                    key: "prev",

                    /**
                     * Slide left, possibly wrapping around in continuous mode.
                     */
                    value: function prev() {
                        if (this.continuous) {
                            // Always allow us to go back
                            this.slide(this.currentIndex - 1);
                        } else if (this.currentIndex > 0) {
                            // If we have one slide to the left
                            this.slide(this.currentIndex - 1);
                        }
                    }
                }, {
                    key: "next",

                    /**
                     * Slide right, possibly wrapping around in continuous mode.
                     */
                    value: function next() {
                        if (this.continuous) {
                            // Always allow us to go next
                            this.slide(this.currentIndex + 1);
                        } else if (this.currentIndex < this.slides.length - 1) {
                            // If not in continuous mode, only slide if we have a right slide
                            this.slide(this.currentIndex + 1);
                        }
                    }
                }, {
                    key: "_bump",

                    // Reposition all the existing slides so they are in the right position
                    value: function _bump() {
                        var slide = undefined;
                        var tx = undefined;
                        var i = this.slides.length;
                        while (i--) {
                            slide = this.slides[i];
                            // Set the slide's left position to a negative of the current index and its width
                            slide.left = i * -this.containerWidth;
                            slide.width = this.containerWidth;
                            // Check if this slide is before or after the currently active one,
                            // since we have to position it before or after it
                            tx = 0;
                            if (this.currentIndex > i) {
                                tx = -this.containerWidth;
                            } else if (this.currentIndex < i) {
                                tx = this.containerWidth;
                            }
                            this._move(i, tx);
                        }
                        if (this.continuous) {
                            // If we are in continuous mode, we need to wrap the previous and
                            // last element to get a complete "circle"
                            var index1 = this._circle(this.currentIndex - 1);
                            var index2 = this._circle(this.currentIndex + 1);
                            this._move(index1, -this.containerWidth); //, 0);
                            this._move(index2, this.containerWidth); //, 0);
                        }
                    }
                }, {
                    key: "_dragStart",
                    value: function _dragStart(event) {
                        this._isScrolling = undefined;
                    }
                }, {
                    key: "_dragPre",

                    /**
                     * Code to run before operating on a drag.
                     */
                    value: function _dragPre(event) {
                        var dx = event.gesture.deltaX;
                        var dy = event.gesture.deltaY;
                        if (this.disableScroll) {
                            event.preventDefault();
                        }
                        // determine if scrolling test has run - one time test
                        if (typeof this._isScrolling == "undefined") {
                            this._isScrolling = !!(this._isScrolling || Math.abs(dx) < Math.abs(dy));
                        }
                        // If we're scrolling, never run the drag
                        if (this._isScrolling) {
                            return false;
                        }
                    }
                }, {
                    key: "_drag",

                    // Process a drag, with a deltaX value
                    value: function _drag(event) {
                        var dx = event.gesture.deltaX;
                        var width = this.containerWidth;
                        var index = this.currentIndex;
                        // Check if we should run (scroll detection, etc)
                        var shouldRun = this._dragPre(event);
                        if (shouldRun === false) {
                            return;
                        }
                        // We're doing this
                        event.preventDefault();
                        var index1 = undefined,
                            index2 = undefined,
                            index3 = undefined;
                        if (this.continuous) {
                            // Grab the left/center/right slides
                            index1 = this._circle(this.currentIndex - 1);
                            index2 = this.currentIndex;
                            index3 = this._circle(this.currentIndex + 1);
                        } else {
                            index1 = this.currentIndex - 1;
                            index2 = this.currentIndex;
                            index3 = this.currentIndex + 1;
                            var isPastBounds = index == 0 && dx > 0 // if first slide and slide amt is greater than 0
                            || index == this.slides.length - 1 && dx < 0; // or if last slide and slide amt is less than 0
                            if (this.bounce) {
                                // If we have drag bouncing/overscroll enabled,
                                // let's slow down the drag on the edges
                                // if first slide and sliding left
                                // or if last slide and sliding right
                                // and if sliding at all,
                                // Adjust resistance
                                dx = dx / (!index && dx > 0 || index == this.slides.length - 1 && dx < 0 ? Math.abs(dx) / width + 1 : 1);
                            } else if (isPastBounds) {
                                // We aren't overscrolling (bouncing), and we're past the bounds
                                var slide = this.slides[index];
                                return;
                            }
                        }
                        var s1 = this.slides[index1];
                        var s2 = this.slides[index2];
                        var s3 = this.slides[index3];
                        // Translate the left/center/right slides based on the deltaX of the drag
                        if (s1) {
                            s1.translate(dx + s1.x);
                        }
                        if (s2) {
                            s2.translate(dx + s2.x);
                        }
                        if (s3) {
                            s3.translate(dx + s3.x);
                        }
                    }
                }, {
                    key: "_endDrag",
                    value: function _endDrag(event, drag) {
                        this._finish(event, drag);
                    }
                }, {
                    key: "_finish",
                    value: function _finish(event, drag) {
                        var delta = {
                            x: event.gesture.deltaX,
                            y: event.gesture.deltaY
                        };
                        var width = this.containerWidth;
                        var index = this.currentIndex;
                        var slides = this.slides;
                        var move = this._move.bind(this);
                        var circle = this._circle.bind(this);
                        var isScrolling = this._isScrolling;
                        var speed = this.animateSpeed;
                        // measure duration
                        var duration = +new Date() - drag.time;
                        // determine if slide attempt triggers next/prev slide
                        var isValidSlide = Number(duration) < 250 // if slide duration is less than 250ms
                        && Math.abs(delta.x) > 20 // and if slide amt is greater than 20px
                        || Math.abs(delta.x) > width / 3; // or if slide amt is greater than half the width
                        // determine if slide attempt is past start and end
                        var isPastBounds = !index && delta.x > 0 // if first slide and slide amt is greater than 0
                        || index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0
                        if (this.continuous) isPastBounds = false;
                        // determine direction of swipe (true:right, false:left)
                        var direction = delta.x < 0;
                        // if not scrolling vertically
                        if (!isScrolling) {
                            if (isValidSlide && !isPastBounds) {
                                if (direction) {
                                    if (this.continuous) {
                                        move(circle(index - 1), -width, 0);
                                        move(circle(index + 2), width, 0);
                                    } else {
                                        move(index - 1, -width, 0);
                                    }
                                    move(index, slides[index].x - width, speed);
                                    move(circle(index + 1), slides[circle(index + 1)].x - width, speed);
                                    this.currentIndex = circle(index + 1);
                                } else {
                                    if (this.continuous) {
                                        move(circle(index + 1), width, 0);
                                        move(circle(index - 2), -width, 0);
                                    } else {
                                        move(index + 1, width, 0);
                                    }
                                    move(index, slides[index].x + width, speed);
                                    move(circle(index - 1), slides[circle(index - 1)].x + width, speed);
                                    this.currentIndex = circle(index - 1);
                                }
                            } else {
                                if (this.continuous) {
                                    move(circle(index - 1), -width, speed);
                                    move(index, 0, speed);
                                    move(circle(index + 1), width, speed);
                                } else {
                                    move(index - 1, -width, speed);
                                    move(index, 0, speed);
                                    move(index + 1, width, speed);
                                }
                            }
                        }
                        // kill touchmove and touchend event listeners until touchstart called again
                        //element.removeEventListener('touchmove', events, false)
                        //element.removeEventListener('touchend', events, false)
                    }
                }, {
                    key: "_move",
                    value: function _move(pos, translateX, speed) {
                        // Should already be wrapped with circle
                        var slide = this.slides[pos];
                        if (!slide) {
                            return;
                        }
                        slide.translate(translateX, speed);
                        slide.x = translateX;
                    }
                }, {
                    key: "_circle",

                    // A modulo "circle" to stay in the bounds of the slide array
                    value: function _circle(i) {
                        return (this.slides.length + i % this.slides.length) % this.slides.length;
                    }
                }, {
                    key: "_append",
                    value: function _append(slide) {
                        this.slides.push(slide);
                    }
                }, {
                    key: "_prepend",
                    value: function _prepend(slide) {
                        this.slides.unshift(slide);
                    }
                }]);

                return _class;
            })();

            _export("Slides", Slides);

            _export("Slides", Slides = __decorate([IonicComponent({
                selector: "ion-slides",
                properties: ["loop", "index", "bounce"]
            }), View({
                template: "<div class=\"slides-view\"><ng-content></ng-content></div>"
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object])], Slides));

            Slide = (function () {
                var _class2 = function Slide(slides, elementRef) {
                    _classCallCheck(this, _class2);

                    this.ele = elementRef.nativeElement;
                    slides.add(this);
                };

                _createClass(_class2, [{
                    key: "translate",
                    value: function translate(x, duration) {
                        this._translateX = x;
                        duration = duration || 0;
                        this.ele.style[dom.CSS.transition + "Duration"] = duration + "ms";
                        this.ele.style[dom.CSS.transform] = "translate3d(" + x + "px, 0, 0)";
                    }
                }, {
                    key: "translateX",
                    get: function get() {
                        return this._translateX;
                    }
                }, {
                    key: "left",
                    set: function set(x) {
                        this._left = x;
                        this.ele.style.left = x + "px";
                    },
                    get: function get() {
                        return this._left;
                    }
                }, {
                    key: "width",
                    set: function set(width) {
                        this._width = width;
                        this.ele.style.width = width + "px";
                    },
                    get: function get() {
                        return this._width;
                    }
                }]);

                return _class2;
            })();

            _export("Slide", Slide);

            _export("Slide", Slide = __decorate([IonicDirective({
                selector: "ion-slide"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Slides, typeof ElementRef !== "undefined" && ElementRef || Object])], Slide));

            SlidePager = (function () {
                var _class3 = function SlidePager(slides, elementRef) {
                    _classCallCheck(this, _class3);

                    this.ele = elementRef.nativeElement;
                    this.slides = slides;
                    this.slides.setPager(this);
                };

                _createClass(_class3, [{
                    key: "getSlides",
                    value: function getSlides() {
                        return this.slides.slides;
                    }
                }]);

                return _class3;
            })();

            _export("SlidePager", SlidePager);

            _export("SlidePager", SlidePager = __decorate([Component({
                selector: "ion-pager"
            }), View({
                //[class.active]="$index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
                template: "<span class=\"slide-pager-page\" *ng-for=\"#page of getSlides()\">{{page.width}}<i class=\"icon ion-record\"></i>X</span>",
                directives: [NgFor]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Slides, typeof ElementRef !== "undefined" && ElementRef || Object])], SlidePager));

            SlidesGesture = (function (_DragGesture) {
                function SlidesGesture(slides) {
                    _classCallCheck(this, SlidesGesture);

                    _get(Object.getPrototypeOf(SlidesGesture.prototype), "constructor", this).call(this, slides.ele);
                    this.slides = slides;
                }

                _inherits(SlidesGesture, _DragGesture);

                _createClass(SlidesGesture, [{
                    key: "onDrag",
                    value: function onDrag(event) {
                        var x = event.gesture.center.x;
                        var y = event.gesture.center.y;
                        this._drag.x = x;
                        this._drag.y = y;
                        this.slides._drag(event);
                    }
                }, {
                    key: "onDragStart",
                    value: function onDragStart(event) {
                        this._drag = {
                            startX: event.gesture.center.x,
                            startY: event.gesture.center.y,
                            time: +new Date()
                        };
                        this.slides._dragStart(event, this._drag);
                    }
                }, {
                    key: "onDragEnd",
                    value: function onDragEnd(event) {
                        this.slides._endDrag(event, this._drag);
                    }
                }]);

                return SlidesGesture;
            })(DragGesture);

            _export("SlidesGesture", SlidesGesture);
        }
    };
});
// determine resistance level
System.register("ionic/components/switch/switch", ["angular2/angular2", "../form/input", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var ElementRef, Renderer, Optional, NgControl, IonInputItem, IonicConfig, IonicComponent, IonicView, __decorate, __metadata, __param, Switch;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            ElementRef = _angular2Angular2.ElementRef;
            Renderer = _angular2Angular2.Renderer;
            Optional = _angular2Angular2.Optional;
            NgControl = _angular2Angular2.NgControl;
        }, function (_formInput) {
            IonInputItem = _formInput.IonInputItem;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Switch = (function (_IonInputItem) {
                var _class = function Switch(cd, renderer, elementRef, config) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, config);
                    this.onChange = function (_) {};
                    this.onTouched = function (_) {};
                    this.renderer = renderer;
                    this.elementRef = elementRef;
                    this.cd = cd;
                    if (cd) cd.valueAccessor = this;
                };

                _inherits(_class, _IonInputItem);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        _get(Object.getPrototypeOf(_class.prototype), "onInit", this).call(this);
                        console.log("switch onInit");
                    }
                }, {
                    key: "onAllChangesDone",
                    value: function onAllChangesDone() {
                        return;
                        console.log("switch onAllChangesDone");
                        if (this._checked !== void 0 && this.input.checked != this._checked) {
                            if (this.input.checked !== void 0) {
                                console.warn("switch checked is set in view template and Control declaration.\n" + "Value: " + !!this._checked + " from Control takes precedence");
                            }
                            this.input.checked = !!this._checked;
                        }
                        if (this._value !== void 0 && this.input.value != this._value) {
                            if (this.input.value !== void 0) {
                                console.warn("switch value is set in view template and Control declaration.\n" + "Value: " + this._value + " from Control takes precedence");
                            }
                            this.input.value = this._value;
                        }
                        if (this.input.value === void 0) {
                            this.input.value = "on";
                        }
                        if (this.input.checked === void 0) {
                            this.input.checked = false;
                        }
                        //TODO check validity
                        this.cd.control._value = { "checked": !!this.input.checked, "value": this.input.value };
                        //TODO only want to call this once, we want to set input.checked directly on subsequent
                        // writeValue's
                        this.onAllChangesDone = function () {};
                        // this.onChange({"checked": this.input.checked, "value": this.input.value});
                    }
                }, {
                    key: "toggle",

                    //from clicking the label or selecting with keyboard
                    //view -> model (Control)
                    value: function toggle() {
                        this.input.checked = this._checked = !this.input.checked;
                        this.onChange({ "checked": this.input.checked, "value": this.input.value });
                    }
                }, {
                    key: "writeValue",

                    // Called by the model (Control) to update the view
                    value: function writeValue(modelValue) {
                        var type = typeof modelValue;
                        switch (type) {
                            case "boolean":
                                // don't set input.value here, do it in onAllChangesDone
                                // because they might have set it in the view
                                this._checked = modelValue;
                                break;
                            case "object":
                                if (modelValue.checked !== void 0) this._checked = !!modelValue.checked;
                                if (modelValue.value !== void 0) this._value = modelValue.value.toString();
                                break;
                            default:
                                // don't set input.checked here, do it in onAllChangesDone
                                // because they might have set it in the view
                                this._value = modelValue.toString();
                        }
                        //TODO we want to set input.checked directly after the first time
                        console.log("writeValue, " + this.input.id + " checked: " + this._checked);
                        console.log("writeValue " + this.input.id + " value: " + this._value);
                        // this.cd.control._value = {"checked": this.input.checked, "value": this.input.value};
                    }
                }, {
                    key: "registerOnChange",

                    // Used by the view to update the model (Control)
                    // Up to us to call it in update()
                    value: function registerOnChange(fn) {
                        this.onChange = fn;
                    }
                }, {
                    key: "registerOnTouched",
                    value: function registerOnTouched(fn) {
                        this.onTouched = fn;
                    }
                }]);

                return _class;
            })(IonInputItem);

            _export("Switch", Switch);

            _export("Switch", Switch = __decorate([IonicComponent({
                selector: "ion-switch",
                host: {
                    "class": "item"
                }
            }), IonicView({
                template: "<div class=\"item-content\">" + "<ng-content></ng-content>" + "</div>" + "<div class=\"item-media media-switch\">" + "<div class=\"switch-track\">" + "<div class=\"switch-handle\"></div>" + "</div>" + "</div>"
            }), __param(0, Optional()), __metadata("design:paramtypes", [typeof NgControl !== "undefined" && NgControl || Object, typeof Renderer !== "undefined" && Renderer || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Switch));
        }
    };
});
System.register("ionic/components/tabs/tab", ["angular2/angular2", "../view/view-controller", "../view/view-item", "./tabs"], function (_export) {
    "use strict";

    var Directive, Component, View, Ancestor, ElementRef, forwardRef, Injector, ViewController, ViewItem, Tabs, __decorate, __metadata, __param, Tab, TabPaneAnchor;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Component = _angular2Angular2.Component;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
            Injector = _angular2Angular2.Injector;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_tabs) {
            Tabs = _tabs.Tabs;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tab = (function (_ViewController) {
                var _class = function Tab(tabs, elementRef, injector) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    // A Tab is both a container of many views, and is a view itself.
                    // A Tab is one ViewItem within it's Ancestor Tabs (which extends ViewController)
                    // A Tab is a ViewController for its child ViewItems
                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, tabs, injector, elementRef);
                    this.tabs = tabs;
                    this.childNavbar(true);
                    var item = this.item = new ViewItem(tabs.Ancestor);
                    item.setInstance(this);
                    item.viewElementRef(elementRef);
                    tabs.addTab(this);
                    this.navbarView = item.navbarView = function () {
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.navbarView();
                    };
                    item.enableBack = function () {
                        // override ViewItem's enableBack(), should use the
                        // active child nav item's enableBack() instead
                        var activeItem = _this.getActive();
                        return activeItem && activeItem.enableBack();
                    };
                    this.panelId = "tab-panel-" + item.id;
                    this.labeledBy = "tab-button-" + item.id;
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "onInit",
                    value: function onInit() {
                        var _this2 = this;

                        if (this._initialResolve) {
                            this.tabs.select(this).then(function () {
                                _this2._initialResolve();
                                _this2._initialResolve = null;
                            });
                        }
                    }
                }, {
                    key: "load",
                    value: function load(callback) {
                        if (!this._loaded && this.root) {
                            var opts = {
                                animate: false,
                                navbar: false
                            };
                            this.push(this.root, null, opts).then(function () {
                                callback && callback();
                            });
                            this._loaded = true;
                        } else {
                            callback && callback();
                        }
                    }
                }, {
                    key: "queueInitial",
                    value: function queueInitial() {
                        var _this3 = this;

                        // this Tab will be used as the initial one for the first load of Tabs
                        return new Promise(function (res) {
                            _this3._initialResolve = res;
                        });
                    }
                }, {
                    key: "isSelected",
                    get: function get() {
                        return this.tabs.isActive(this.item);
                    }
                }, {
                    key: "isNotSelected",
                    get: function get() {
                        return !this.tabs.isActive(this.item);
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Tab", Tab);

            _export("Tab", Tab = __decorate([Component({
                selector: "ion-tab",
                properties: ["root", "tabTitle", "tabIcon"],
                host: {
                    "[attr.id]": "panelId",
                    "[attr.aria-labelledby]": "labeledBy",
                    "[attr.aria-hidden]": "isNotSelected",
                    "[class.tab-selected]": "isSelected",
                    "role": "tabpanel"
                }
            }), View({
                template: "<template pane-anchor></template><ng-content></ng-content>",
                directives: [forwardRef(function () {
                    return TabPaneAnchor;
                })]
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [typeof Tabs !== "undefined" && Tabs || Object, typeof ElementRef !== "undefined" && ElementRef || Object, typeof Injector !== "undefined" && Injector || Object])], Tab));

            TabPaneAnchor = (function () {
                var _class2 = function TabPaneAnchor(tab, elementRef) {
                    _classCallCheck(this, _class2);

                    tab.anchorElementRef(elementRef);
                };

                return _class2;
            })();

            TabPaneAnchor = __decorate([Directive({
                selector: "template[pane-anchor]"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Tab, typeof ElementRef !== "undefined" && ElementRef || Object])], TabPaneAnchor);
        }
    };
});
System.register("ionic/components/tabs/tabs", ["angular2/angular2", "../view/view-controller", "../view/view-item", "../../config/annotations"], function (_export) {
    "use strict";

    var Directive, Injector, ElementRef, Optional, Ancestor, forwardRef, ViewController, ViewItem, IonicComponent, IonicView, __decorate, __metadata, __param, Tabs, TabButton;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            Injector = _angular2Angular2.Injector;
            ElementRef = _angular2Angular2.ElementRef;
            Optional = _angular2Angular2.Optional;
            Ancestor = _angular2Angular2.Ancestor;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_viewViewController) {
            ViewController = _viewViewController.ViewController;
        }, function (_viewViewItem) {
            ViewItem = _viewViewItem.ViewItem;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
            IonicView = _configAnnotations.IonicView;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            Tabs = (function (_ViewController) {
                var _class = function Tabs(AncestorViewCtrl, viewItem, injector, elementRef) {
                    var _this = this;

                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, AncestorViewCtrl, injector, elementRef);
                    // Tabs may also be an actual ViewItem which was navigated to
                    // if Tabs is static and not navigated to within a ViewController
                    // then skip this and don't treat it as it's own ViewItem
                    if (viewItem) {
                        this.item = viewItem;
                        // special overrides for the Tabs ViewItem
                        // the Tabs ViewItem does not have it's own navbar
                        // so find the navbar it should use within it's active Tab
                        viewItem.navbarView = function () {
                            var activeTab = _this.getActive();
                            if (activeTab && activeTab.instance) {
                                return activeTab.instance.navbarView();
                            }
                        };
                        // a Tabs ViewItem should not have a back button
                        // enableBack back button will later be determined
                        // by the active ViewItem that has a navbar
                        viewItem.enableBack = function () {
                            return false;
                        };
                    }
                };

                _inherits(_class, _ViewController);

                _createClass(_class, [{
                    key: "addTab",
                    value: function addTab(tab) {
                        // tab.item refers to the ViewItem of the individual Tab being added to Tabs (ViewController)
                        // this.item refers to the ViewItem instsance on Tabs
                        this.add(tab.item);
                        if (this.length() === 1) {
                            // this was the first tab added, queue this one to be loaded and selected
                            var promise = tab.queueInitial();
                            this.item && this.item.addPromise(promise);
                        }
                    }
                }, {
                    key: "select",
                    value: function select(tab) {
                        var _this2 = this;

                        var enteringItem = null;
                        if (typeof tab === "number") {
                            enteringItem = this.getByIndex(tab);
                        } else {
                            enteringItem = this.getByInstance(tab);
                        }
                        if (!enteringItem || !enteringItem.instance || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        return new Promise(function (resolve) {
                            enteringItem.instance.load(function () {
                                var opts = {
                                    animate: false
                                };
                                var leavingItem = _this2.getActive() || new ViewItem();
                                leavingItem.shouldDestroy = false;
                                leavingItem.shouldCache = true;
                                _this2.transition(enteringItem, leavingItem, opts, function () {
                                    resolve();
                                });
                            });
                        });
                    }
                }, {
                    key: "tabs",
                    get: function get() {
                        return this.instances();
                    }
                }]);

                return _class;
            })(ViewController);

            _export("Tabs", Tabs);

            _export("Tabs", Tabs = __decorate([IonicComponent({
                selector: "ion-tabs",
                defaultProperties: {
                    "tabBarPlacement": "bottom",
                    "tabBarIcons": "top"
                }
            }), IonicView({
                template: "" + "<nav class=\"tab-bar-container\">" + "<div class=\"tab-bar\" role=\"tablist\">" + "<button *ng-for=\"#t of tabs\" [tab]=\"t\" class=\"tab-button\" role=\"tab\">" + "<icon [name]=\"t.tabIcon\" class=\"tab-button-icon\"></icon>" + "<span class=\"tab-button-text\">{{t.tabTitle}}</span>" + "</button>" + "</div>" + "</nav>" + "<section class=\"content-container\">" + "<ng-content></ng-content>" + "</section>",
                directives: [forwardRef(function () {
                    return TabButton;
                })]
            }), __param(0, Optional()), __param(1, Optional()), __metadata("design:paramtypes", [typeof ViewController !== "undefined" && ViewController || Object, typeof ViewItem !== "undefined" && ViewItem || Object, typeof Injector !== "undefined" && Injector || Object, typeof ElementRef !== "undefined" && ElementRef || Object])], Tabs));

            TabButton = (function () {
                var _class2 = function TabButton(tabs) {
                    _classCallCheck(this, _class2);

                    this.tabs = tabs;
                };

                _createClass(_class2, [{
                    key: "onInit",
                    value: function onInit() {
                        var id = this.tab.item.id;
                        this.btnId = "tab-button-" + id;
                        this.panelId = "tab-panel-" + id;
                        this.hasTitle = !!this.tab.tabTitle;
                        this.hasIcon = !!this.tab.tabIcon;
                        this.hasTitleOnly = this.hasTitle && !this.hasIcon;
                        this.hasIconOnly = this.hasIcon && !this.hasTitle;
                    }
                }, {
                    key: "onClick",
                    value: function onClick(ev) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        this.tabs.select(this.tab);
                    }
                }]);

                return _class2;
            })();

            TabButton = __decorate([Directive({
                selector: "button.tab-button",
                properties: ["tab"],
                host: {
                    "[attr.id]": "btnId",
                    "[attr.aria-controls]": "panelId",
                    "[attr.aria-selected]": "tab.isSelected",
                    "[class.has-title]": "hasTitle",
                    "[class.has-icon]": "hasIcon",
                    "[class.has-title-only]": "hasTitleOnly",
                    "[class.icon-only]": "hasIconOnly",
                    "(^click)": "onClick($event)"
                }
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Tabs])], TabButton);
        }
    };
});
System.register("ionic/components/toolbar/toolbar", ["angular2/angular2", "../ion", "../../config/config", "../../config/annotations"], function (_export) {
    "use strict";

    var Directive, View, Ancestor, ElementRef, forwardRef, Ion, IonicConfig, IonicComponent, __decorate, __metadata, __param, ToolbarBase, Toolbar, ToolbarTitle, ToolbarItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Directive = _angular2Angular2.Directive;
            View = _angular2Angular2.View;
            Ancestor = _angular2Angular2.Ancestor;
            ElementRef = _angular2Angular2.ElementRef;
            forwardRef = _angular2Angular2.forwardRef;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_configAnnotations) {
            IonicComponent = _configAnnotations.IonicComponent;
        }],
        execute: function () {
            __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
                switch (arguments.length) {
                    case 2:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(o) || o;
                        }, target);
                    case 3:
                        return decorators.reduceRight(function (o, d) {
                            return (d && d(target, key), void 0);
                        }, void 0);
                    case 4:
                        return decorators.reduceRight(function (o, d) {
                            return d && d(target, key, o) || o;
                        }, desc);
                }
            };

            __metadata = undefined && undefined.__metadata || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };

            __param = undefined && undefined.__param || function (paramIndex, decorator) {
                return function (target, key) {
                    decorator(target, key, paramIndex);
                };
            };

            ToolbarBase = (function (_Ion) {
                function ToolbarBase(elementRef, config) {
                    _classCallCheck(this, ToolbarBase);

                    _get(Object.getPrototypeOf(ToolbarBase.prototype), "constructor", this).call(this, elementRef, config);
                    this.titleAlign = config.setting("navTitleAlign");
                    this.itemEles = [];
                }

                _inherits(ToolbarBase, _Ion);

                _createClass(ToolbarBase, [{
                    key: "titleElement",
                    value: function titleElement(eleRef) {
                        if (arguments.length) {
                            this._nbTlEle = eleRef;
                        }
                        return this._nbTlEle;
                    }
                }, {
                    key: "itemElements",
                    value: function itemElements(eleRef) {
                        if (arguments.length) {
                            this.itemEles.push(eleRef);
                        }
                        return this.itemEles;
                    }
                }, {
                    key: "titleText",
                    value: function titleText(eleRef) {
                        if (arguments.length) {
                            this._ttTxt.push(eleRef);
                        }
                        return this._ttTxt;
                    }
                }, {
                    key: "alignTitle",
                    value: function alignTitle() {
                        // don't bother if we're not trying to center align the title
                        if (this.titleAlign !== "center" || this.aligned) return;
                        // called after the navbar/title has had a moment to
                        // finish rendering in their correct locations
                        var toolbarEle = this.getNativeElement();
                        var titleEle = toolbarEle.querySelector("ion-title");
                        // don't bother if there's no title element
                        if (!titleEle) return;
                        // get all the dimensions
                        var titleOffsetLeft = titleEle.offsetLeft;
                        var titleOffsetRight = toolbarEle.offsetWidth - (titleOffsetLeft + titleEle.offsetWidth);
                        var marginLeft = 0;
                        var marginRight = 0;
                        if (titleOffsetLeft < titleOffsetRight) {
                            marginLeft = titleOffsetRight - titleOffsetLeft + 5;
                        } else if (titleOffsetLeft > titleOffsetRight) {
                            marginRight = titleOffsetLeft - titleOffsetRight - 5;
                        }
                        if (marginLeft || marginRight) {
                            // only do an update if it has to
                            var innerTitleEle = toolbarEle.querySelector(".toolbar-inner-title");
                            innerTitleEle.style.margin = "0 " + marginRight + "px 0 " + marginLeft + "px";
                        }
                        this.aligned = true;
                    }
                }]);

                return ToolbarBase;
            })(Ion);

            _export("ToolbarBase", ToolbarBase);

            Toolbar = (function (_ToolbarBase) {
                var _class = function Toolbar(elementRef, ionicConfig) {
                    _classCallCheck(this, _class);

                    _get(Object.getPrototypeOf(_class.prototype), "constructor", this).call(this, elementRef, ionicConfig);
                    this.itemEles = [];
                };

                _inherits(_class, _ToolbarBase);

                _createClass(_class, [{
                    key: "onIonInit",
                    value: function onIonInit() {
                        var _this = this;

                        // TODO: THIS IS HORRIBLE, FIX
                        setTimeout(function () {
                            _this.alignTitle();
                            setTimeout(function () {
                                _this.alignTitle();
                            }, 64);
                        }, 32);
                    }
                }]);

                return _class;
            })(ToolbarBase);

            _export("Toolbar", Toolbar);

            _export("Toolbar", Toolbar = __decorate([IonicComponent({
                selector: "ion-toolbar"
            }), View({
                template: "\n    <div class=\"toolbar-inner\">\n      <div class=\"toolbar-title\">\n        <div class=\"toolbar-inner-title\">\n          <ng-content select=\"ion-title\"></ng-content>\n        </div>\n      </div>\n      <div class=\"toolbar-item toolbar-primary-item\">\n        <ng-content select=\"[primary]\"></ng-content>\n      </div>\n      <div class=\"toolbar-item toolbar-secondary-item\">\n        <ng-content select=\"[secondary]\"></ng-content>\n      </div>\n    </div>\n  ",
                directives: [forwardRef(function () {
                    return ToolbarTitle;
                }), forwardRef(function () {
                    return ToolbarItem;
                })]
            }), __metadata("design:paramtypes", [typeof ElementRef !== "undefined" && ElementRef || Object, typeof IonicConfig !== "undefined" && IonicConfig || Object])], Toolbar));

            ToolbarTitle = (function () {
                var _class2 = function ToolbarTitle(toolbar, elementRef) {
                    _classCallCheck(this, _class2);

                    toolbar.titleElement(elementRef);
                };

                return _class2;
            })();

            ToolbarTitle = __decorate([Directive({
                selector: ".toolbar-title"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Toolbar, typeof ElementRef !== "undefined" && ElementRef || Object])], ToolbarTitle);

            ToolbarItem = (function () {
                var _class3 = function ToolbarItem(toolbar, elementRef) {
                    _classCallCheck(this, _class3);

                    toolbar.itemElements(elementRef);
                };

                return _class3;
            })();

            ToolbarItem = __decorate([Directive({
                selector: ".toolbar-item"
            }), __param(0, Ancestor()), __metadata("design:paramtypes", [Toolbar, typeof ElementRef !== "undefined" && ElementRef || Object])], ToolbarItem);
        }
    };
});
System.register('ionic/components/view/view-controller', ['angular2/angular2', 'angular2/src/core/compiler/dynamic_component_loader', 'angular2/src/core/compiler/view_manager', '../ion', '../../config/config', '../app/app', '../../routing/router', './view-item', '../nav/nav-controller', '../nav/pane', '../../transitions/transition', '../../util/click-block', 'ionic/util'], function (_export) {
    'use strict';

    var Compiler, Injector, bind, DynamicComponentLoader, AppViewManager, Ion, IonicConfig, IonicApp, IonicRouter, ViewItem, NavController, PaneController, Transition, ClickBlock, util, ViewController, ACTIVE_STATE, CACHED_STATE, STAGED_ENTERING_STATE, STAGED_LEAVING_STATE, ctrlIds;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x7, _x8, _x9) { var _again = true; _function: while (_again) { var object = _x7, property = _x8, receiver = _x9; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x7 = parent; _x8 = property; _x9 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_angular2Angular2) {
            Compiler = _angular2Angular2.Compiler;
            Injector = _angular2Angular2.Injector;
            bind = _angular2Angular2.bind;
        }, function (_angular2SrcCoreCompilerDynamic_component_loader) {
            DynamicComponentLoader = _angular2SrcCoreCompilerDynamic_component_loader.DynamicComponentLoader;
        }, function (_angular2SrcCoreCompilerView_manager) {
            AppViewManager = _angular2SrcCoreCompilerView_manager.AppViewManager;
        }, function (_ion) {
            Ion = _ion.Ion;
        }, function (_configConfig) {
            IonicConfig = _configConfig.IonicConfig;
        }, function (_appApp) {
            IonicApp = _appApp.IonicApp;
        }, function (_routingRouter) {
            IonicRouter = _routingRouter.IonicRouter;
        }, function (_viewItem) {
            ViewItem = _viewItem.ViewItem;
        }, function (_navNavController) {
            NavController = _navNavController.NavController;
        }, function (_navPane) {
            PaneController = _navPane.PaneController;
        }, function (_transitionsTransition) {
            Transition = _transitionsTransition.Transition;
        }, function (_utilClickBlock) {
            ClickBlock = _utilClickBlock.ClickBlock;
        }, function (_ionicUtil) {
            util = _ionicUtil;
        }],
        execute: function () {
            ViewController = (function (_Ion) {
                function ViewController(parentViewCtrl, injector, elementRef) {
                    _classCallCheck(this, ViewController);

                    var config = injector.get(IonicConfig);
                    _get(Object.getPrototypeOf(ViewController.prototype), 'constructor', this).call(this, elementRef, config);
                    this.parent = parentViewCtrl;
                    this.compiler = injector.get(Compiler);
                    this.loader = injector.get(DynamicComponentLoader);
                    this.viewMngr = injector.get(AppViewManager);
                    this.router = injector.get(IonicRouter);
                    this.app = injector.get(IonicApp);
                    this.config = config;
                    this.router.addViewController(this);
                    this.items = [];
                    this.panes = new PaneController(this);
                    this.sbTransition = null;
                    this.sbActive = false;
                    this.sbEnabled = true;
                    this.id = ++ctrlIds;
                    this._ids = -1;
                    // build a new injector for child ViewItems to use
                    this.bindings = Injector.resolve([bind(ViewController).toValue(this), bind(NavController).toValue(new NavController(this))]);
                }

                _inherits(ViewController, _Ion);

                _createClass(ViewController, [{
                    key: 'push',
                    value: function push(component) {
                        var params = arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments[2] === undefined ? {} : arguments[2];

                        if (!component || this.isTransitioning()) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // do not animate if this is the first in the stack
                        if (!this.items.length) {
                            opts.animation = 'none';
                        }
                        // default the direction to "forward"
                        opts.direction = opts.direction || 'forward';
                        // the active item is going to be the leaving one (if one exists)
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : true;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // create a new ViewItem
                        var enteringItem = new ViewItem(this, component, params);
                        // add the item to the stack
                        this.add(enteringItem);
                        // notify app of the state change
                        this.app.stateChange('push', enteringItem);
                        // start the transition
                        this.transition(enteringItem, leavingItem, opts, function () {
                            resolve();
                        });
                        return promise;
                    }
                }, {
                    key: 'pop',
                    value: function pop() {
                        var opts = arguments[0] === undefined ? {} : arguments[0];

                        if (this.isTransitioning() || this.items.length < 2) {
                            return Promise.reject();
                        }
                        var resolve = undefined;
                        var promise = new Promise(function (res) {
                            resolve = res;
                        });
                        // default the direction to "back"
                        opts.direction = opts.direction || 'back';
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldCache = util.isBoolean(opts.cacheLeavingItem) ? opts.cacheLeavingItem : false;
                        leavingItem.shouldDestroy = !leavingItem.shouldCache;
                        if (leavingItem.shouldDestroy) {
                            leavingItem.willUnload();
                        }
                        // the entering item is now the new last item
                        // Note: we might not have an entering item if this is the
                        // only item on the history stack.
                        var enteringItem = this.getPrevious(leavingItem);
                        if (enteringItem) {
                            // notify app of the state change
                            this.app.stateChange('pop', enteringItem);
                            // start the transition
                            this.transition(enteringItem, leavingItem, opts, function () {
                                // transition completed, destroy the leaving item
                                resolve();
                            });
                        } else {
                            this.transitionComplete();
                            resolve();
                        }
                        return promise;
                    }
                }, {
                    key: 'setItems',

                    /**
                     * Set the item stack to reflect the given component classes.
                     */
                    value: function setItems(components) {
                        var opts = arguments[1] === undefined ? {} : arguments[1];

                        if (!components || !components.length) {
                            return Promise.resolve();
                        }
                        this.app.stateClear();
                        // if animate has not been set then default to false
                        opts.animate = opts.animate || false;
                        // ensure leaving items are not cached, and should be destroyed
                        opts.cacheLeavingItem = false;
                        // get the items to auto remove without having to do a transiton for each
                        // the last item (the currently active one) will do a normal transition out
                        if (this.items.length > 1) {
                            var autoRemoveItems = this.items.slice(0, this.items.length - 1);
                            for (var i = 0; i < autoRemoveItems.length; i++) {
                                autoRemoveItems[i].shouldDestroy = true;
                                autoRemoveItems[i].shouldCache = false;
                                autoRemoveItems[i].willUnload();
                            }
                        }
                        var component = null;
                        var viewItem = null;
                        // create the ViewItems that go before the new active ViewItem in the stack
                        // but the previous views won't should render yet
                        if (components.length > 1) {
                            var newBeforeItems = components.slice(0, components.length - 1);
                            for (var j = 0; j < newBeforeItems.length; j++) {
                                component = newBeforeItems[j];
                                if (component) {
                                    viewItem = new ViewItem(this, component.component || component, component.params);
                                    viewItem.state = CACHED_STATE;
                                    viewItem.shouldDestroy = false;
                                    viewItem.shouldCache = false;
                                    // add the item to the stack
                                    this.add(viewItem);
                                }
                            }
                        }
                        // get the component that will become the active item
                        // it'll be the last one in the given components array
                        component = components[components.length - 1];
                        // transition the leaving and entering
                        return this.push(component && component.component || component, component && component.params, opts);
                    }
                }, {
                    key: 'setRoot',
                    value: function setRoot(component) {
                        var params = arguments[1] === undefined ? {} : arguments[1];
                        var opts = arguments[2] === undefined ? {} : arguments[2];

                        return this.setItems([{
                            component: component,
                            params: params
                        }], opts);
                    }
                }, {
                    key: 'transition',
                    value: function transition(enteringItem, leavingItem, opts, callback) {
                        var _this = this;

                        if (!enteringItem || enteringItem === leavingItem) {
                            return callback();
                        }
                        if (opts.animate === false) {
                            opts.animation = 'none';
                        } else if (!opts.animation) {
                            opts.animation = this.config.setting('viewTransition');
                        }
                        opts.animate = opts.animation !== 'none';
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            enteringItem.shouldDestroy = false;
                            enteringItem.shouldCache = false;
                            enteringItem.willEnter();
                            leavingItem.willLeave();
                            // set that the new item pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct item
                            enteringItem.state = STAGED_ENTERING_STATE;
                            leavingItem.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            var transAnimation = Transition.create(_this, opts);
                            if (!opts.animate) {
                                // force it to not animate the elements, just apply the "to" styles
                                transAnimation.duration(0);
                            }
                            var duration = transAnimation.duration();
                            if (duration > 64) {
                                // block any clicks during the transition and provide a
                                // fallback to remove the clickblock if something goes wrong
                                ClickBlock(true, duration + 200);
                            }
                            // start the transition
                            transAnimation.play().then(function () {
                                // transition has completed, update each item's state
                                enteringItem.state = ACTIVE_STATE;
                                leavingItem.state = CACHED_STATE;
                                // dispose any items that shouldn't stay around
                                transAnimation.dispose();
                                enteringItem.didEnter();
                                leavingItem.didLeave();
                                // all done!
                                _this.transitionComplete();
                                callback();
                            });
                        });
                    }
                }, {
                    key: 'swipeBackStart',
                    value: function swipeBackStart() {
                        var _this2 = this;

                        if (this.isTransitioning() || this.items.length < 2) {
                            return;
                        }
                        this.sbActive = true;
                        this.sbResolve = null;
                        // default the direction to "back"
                        var opts = {
                            direction: 'back'
                        };
                        // get the active item and set that it is staged to be leaving
                        // was probably the one popped from the stack
                        var leavingItem = this.getActive() || new ViewItem();
                        leavingItem.shouldDestroy = true;
                        leavingItem.shouldCache = false;
                        leavingItem.willLeave();
                        leavingItem.willUnload();
                        // the entering item is now the new last item
                        var enteringItem = this.getPrevious(leavingItem);
                        enteringItem.shouldDestroy = false;
                        enteringItem.shouldCache = false;
                        enteringItem.willEnter();
                        // wait for the new item to complete setup
                        enteringItem.stage(function () {
                            // set that the new item pushed on the stack is staged to be entering/leaving
                            // staged state is important for the transition to find the correct item
                            enteringItem.state = STAGED_ENTERING_STATE;
                            leavingItem.state = STAGED_LEAVING_STATE;
                            // init the transition animation
                            _this2.sbTransition = Transition.create(_this2, opts);
                            _this2.sbTransition.easing('linear');
                            _this2.sbTransition.stage();
                            var swipeBackPromise = new Promise(function (res) {
                                _this2.sbResolve = res;
                            });
                            swipeBackPromise.then(function (completeSwipeBack) {
                                if (completeSwipeBack) {
                                    // swipe back has completed, update each item's state
                                    enteringItem.state = ACTIVE_STATE;
                                    leavingItem.state = CACHED_STATE;
                                    enteringItem.didEnter();
                                    leavingItem.didLeave();
                                    // notify app of the state change
                                    _this2.app.stateChange('pop', enteringItem);
                                } else {
                                    // cancelled the swipe back, return items to original state
                                    leavingItem.state = ACTIVE_STATE;
                                    enteringItem.state = CACHED_STATE;
                                    leavingItem.willEnter();
                                    leavingItem.didEnter();
                                    enteringItem.didLeave();
                                    leavingItem.shouldDestroy = false;
                                    enteringItem.shouldDestroy = false;
                                }
                                // all done!
                                _this2.transitionComplete();
                            });
                        });
                    }
                }, {
                    key: 'swipeBackProgress',
                    value: function swipeBackProgress(progress) {
                        if (this.sbTransition) {
                            ClickBlock(true, 4000);
                            this.sbTransition.progress(Math.min(1, Math.max(0, progress)));
                        }
                    }
                }, {
                    key: 'swipeBackEnd',
                    value: function swipeBackEnd(completeSwipeBack, progress, playbackRate) {
                        var _this3 = this;

                        // to reverse the animation use a negative playbackRate
                        if (this.sbTransition && this.sbActive) {
                            this.sbActive = false;
                            if (progress <= 0) {
                                this.swipeBackProgress(0.0001);
                            } else if (progress >= 1) {
                                this.swipeBackProgress(0.9999);
                            }
                            if (!completeSwipeBack) {
                                playbackRate = playbackRate * -1;
                            }
                            this.sbTransition.playbackRate(playbackRate);
                            this.sbTransition.play().then(function () {
                                _this3.sbResolve && _this3.sbResolve(completeSwipeBack);
                                _this3.sbTransition && _this3.sbTransition.dispose();
                                _this3.sbResolve = _this3.sbTransition = null;
                            });
                        }
                    }
                }, {
                    key: 'isSwipeBackEnabled',
                    value: function isSwipeBackEnabled(val) {
                        if (arguments.length) {
                            this.sbEnabled = !!val;
                        }
                        return this.sbEnabled;
                    }
                }, {
                    key: 'canSwipeBack',
                    value: function canSwipeBack() {
                        if (this.sbEnabled) {
                            var activeItem = this.getActive();
                            if (activeItem) {
                                return activeItem.enableBack();
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'transitionComplete',
                    value: function transitionComplete() {
                        var _this4 = this;

                        var destroys = [];
                        this.items.forEach(function (item) {
                            if (item) {
                                if (item.shouldDestroy) {
                                    destroys.push(item);
                                } else if (item.state === CACHED_STATE && item.shouldCache) {
                                    item.shouldCache = false;
                                }
                            }
                        });
                        destroys.forEach(function (item) {
                            _this4.remove(item);
                            item.destroy();
                        });
                        // allow clicks again
                        ClickBlock(false);
                    }
                }, {
                    key: 'isTransitioning',
                    value: function isTransitioning() {
                        var state = undefined;
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            state = this.items[i].state;
                            if (state === STAGED_ENTERING_STATE || state === STAGED_LEAVING_STATE) {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: 'getActive',
                    value: function getActive() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === ACTIVE_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByInstance',
                    value: function getByInstance(instance) {
                        if (instance) {
                            for (var i = 0, ii = this.items.length; i < ii; i++) {
                                if (this.items[i].instance === instance) {
                                    return this.items[i];
                                }
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getByIndex',
                    value: function getByIndex(index) {
                        if (index < this.items.length && index > -1) {
                            return this.items[index];
                        }
                        return null;
                    }
                }, {
                    key: 'getPrevious',
                    value: function getPrevious(item) {
                        if (item) {
                            return this.items[this.items.indexOf(item) - 1];
                        }
                        return null;
                    }
                }, {
                    key: 'getStagedEnteringItem',
                    value: function getStagedEnteringItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_ENTERING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'getStagedLeavingItem',
                    value: function getStagedLeavingItem() {
                        for (var i = 0, ii = this.items.length; i < ii; i++) {
                            if (this.items[i].state === STAGED_LEAVING_STATE) {
                                return this.items[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'navbarViewContainer',
                    value: function navbarViewContainer(nbContainer) {
                        if (nbContainer) {
                            this._nbContainer = nbContainer;
                        }
                        if (this._nbContainer) {
                            return this._nbContainer;
                        }
                        if (this.parent) {
                            return this.parent.navbarViewContainer();
                        }
                    }
                }, {
                    key: 'anchorElementRef',
                    value: function anchorElementRef() {
                        if (arguments.length) {
                            this._anchorER = arguments[0];
                        }
                        return this._anchorER;
                    }
                }, {
                    key: 'anchorViewContainerRef',
                    value: function anchorViewContainerRef() {
                        if (arguments.length) {
                            this._anchorVC = arguments[0];
                        }
                        return this._anchorVC;
                    }
                }, {
                    key: 'childNavbar',
                    value: function childNavbar() {
                        if (arguments.length) {
                            this._childNavbar = arguments[0];
                        }
                        return this._childNavbar;
                    }
                }, {
                    key: 'add',
                    value: function add(item) {
                        item.id = this.id + '-' + ++this._ids;
                        this.items.push(item);
                    }
                }, {
                    key: 'remove',
                    value: function remove(itemOrIndex) {
                        util.array.remove(this.items, itemOrIndex);
                    }
                }, {
                    key: 'indexOf',
                    value: function indexOf(item) {
                        return this.items.indexOf(item);
                    }
                }, {
                    key: 'length',
                    value: function length() {
                        return this.items.length;
                    }
                }, {
                    key: 'instances',
                    value: function instances() {
                        var instances = [];
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = this.items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var item = _step.value;

                                if (item.instance) {
                                    instances.push(item.instance);
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return instances;
                    }
                }, {
                    key: 'isActive',
                    value: function isActive(item) {
                        return item && item.state === ACTIVE_STATE;
                    }
                }, {
                    key: 'isStagedEntering',
                    value: function isStagedEntering(item) {
                        return item && item.state === STAGED_ENTERING_STATE;
                    }
                }]);

                return ViewController;
            })(Ion);

            _export('ViewController', ViewController);

            ACTIVE_STATE = 1;
            CACHED_STATE = 2;
            STAGED_ENTERING_STATE = 3;
            STAGED_LEAVING_STATE = 4;
            ctrlIds = -1;
        }
    };
});
System.register('ionic/components/view/view-item', ['angular2/angular2', 'angular2/src/core/compiler/element_injector', '../nav/nav-controller'], function (_export) {
    'use strict';

    var Component, bind, Injector, ComponentRef, DirectiveBinding, NavParams, ViewItem;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function isComponent(elementBinder, id) {
        return elementBinder && elementBinder.componentDirective && elementBinder.componentDirective.metadata.id == id;
    }
    return {
        setters: [function (_angular2Angular2) {
            Component = _angular2Angular2.Component;
            bind = _angular2Angular2.bind;
            Injector = _angular2Angular2.Injector;
            ComponentRef = _angular2Angular2.ComponentRef;
        }, function (_angular2SrcCoreCompilerElement_injector) {
            DirectiveBinding = _angular2SrcCoreCompilerElement_injector.DirectiveBinding;
        }, function (_navNavController) {
            NavParams = _navNavController.NavParams;
        }],
        execute: function () {
            ViewItem = (function () {
                function ViewItem(viewCtrl, componentType) {
                    var params = arguments[2] === undefined ? {} : arguments[2];

                    _classCallCheck(this, ViewItem);

                    this.viewCtrl = viewCtrl;
                    this.componentType = componentType;
                    this.params = new NavParams(params);
                    this.instance = null;
                    this.state = 0;
                    this.disposals = [];
                    this.protos = {};
                    this._nbItms = [];
                    this._promises = [];
                    this.templateRefs = {};
                }

                _createClass(ViewItem, [{
                    key: 'addProtoViewRef',
                    value: function addProtoViewRef(name, protoViewRef) {
                        this.protos[name] = protoViewRef;
                    }
                }, {
                    key: 'addTemplateRef',
                    value: function addTemplateRef(name, templateRef) {
                        this.templateRefs[name] = templateRef;
                    }
                }, {
                    key: 'stage',
                    value: function stage(callback) {
                        var _this = this;

                        var viewCtrl = this.viewCtrl;
                        if (this.instance || !viewCtrl) {
                            // already compiled this view
                            return callback();
                        }
                        var annotation = new Component({
                            selector: 'ion-view',
                            host: {
                                'class': 'nav-item'
                            }
                        });
                        var ionViewComponentType = DirectiveBinding.createFromType(this.componentType, annotation);
                        // create a unique token that works as a cache key
                        ionViewComponentType.token = 'ionView' + this.componentType.name;
                        // compile the Component
                        viewCtrl.compiler.compileInHost(ionViewComponentType).then(function (hostProtoViewRef) {
                            // figure out the sturcture of this Component
                            // does it have a navbar? Is it tabs? Should it not have a navbar or any toolbars?
                            var itemStructure = _this.sturcture = _this.inspectStructure(hostProtoViewRef);
                            // get the appropriate Pane which this ViewItem will fit into
                            viewCtrl.panes.get(itemStructure, function (pane) {
                                _this.pane = pane;
                                var bindings = viewCtrl.bindings.concat(Injector.resolve([bind(NavParams).toValue(_this.params), bind(ViewItem).toValue(_this)]));
                                // add the content of the view to the content area
                                // it will already have the correct context
                                var contentContainer = pane.contentContainerRef;
                                // the same guts as DynamicComponentLoader.loadNextToLocation
                                var hostViewRef = contentContainer.createHostView(hostProtoViewRef, -1, bindings);
                                var newLocation = viewCtrl.viewMngr.getHostElement(hostViewRef);
                                var newComponent = viewCtrl.viewMngr.getComponent(newLocation);
                                var dispose = function dispose() {
                                    var index = contentContainer.indexOf(hostViewRef);
                                    if (index !== -1) {
                                        contentContainer.remove(index);
                                    }
                                };
                                _this.disposals.push(dispose);
                                var viewComponetRef = new ComponentRef(newLocation, newComponent, dispose);
                                // get the component's instance, and set it to the this ViewItem
                                _this.setInstance(viewComponetRef.instance);
                                _this.viewElementRef(viewComponetRef.location);
                                // // get the item container's nav bar
                                var navbarViewContainer = viewCtrl.navbarViewContainer();
                                // // get the item's navbar protoview
                                var navbarTemplateRef = _this.templateRefs.navbar;
                                // add a navbar view if the pane has a navbar container, and the
                                // item's instance has a navbar protoview to go to inside of it
                                if (navbarViewContainer && navbarTemplateRef) {
                                    (function () {
                                        var navbarView = navbarViewContainer.createEmbeddedView(navbarTemplateRef, -1);
                                        _this.disposals.push(function () {
                                            navbarViewContainer.remove(navbarViewContainer.indexOf(navbarView));
                                        });
                                    })();
                                }
                                // this item has finished loading
                                try {
                                    _this.loaded();
                                } catch (e) {
                                    console.error(e);
                                }
                                // fire callback when all child promises have been resolved
                                Promise.all(_this._promises).then(function () {
                                    callback();
                                    _this._promises = [];
                                });
                            }, function (panesErr) {
                                console.error(panesErr);
                            });
                        }, function (compileInHostErr) {
                            console.error(compileInHostErr);
                        });
                    }
                }, {
                    key: 'addPromise',
                    value: function addPromise(childPromise) {
                        this._promises.push(childPromise);
                    }
                }, {
                    key: 'inspectStructure',
                    value: function inspectStructure(componentProtoViewRef) {
                        var navbar = false;
                        var key = '_';
                        componentProtoViewRef._protoView.elementBinders.forEach(function (rootElementBinder) {
                            if (!rootElementBinder.componentDirective || !rootElementBinder.nestedProtoView) return;
                            rootElementBinder.nestedProtoView.elementBinders.forEach(function (nestedElementBinder) {
                                if (isComponent(nestedElementBinder, 'Tabs')) {
                                    navbar = true;
                                }
                                if (!nestedElementBinder.componentDirective && nestedElementBinder.nestedProtoView) {
                                    nestedElementBinder.nestedProtoView.elementBinders.forEach(function (templatedElementBinder) {
                                        if (isComponent(templatedElementBinder, 'Navbar')) {
                                            navbar = true;
                                        }
                                    });
                                }
                            });
                        });
                        if (this.viewCtrl.childNavbar()) {
                            navbar = false;
                        }
                        if (navbar) key += 'n';
                        return {
                            navbar: navbar,
                            key: key
                        };
                    }
                }, {
                    key: 'enableBack',
                    value: function enableBack() {
                        // update if it's possible to go back from this nav item
                        if (this.viewCtrl) {
                            var previousItem = this.viewCtrl.getPrevious(this);
                            // the previous view may exist, but if it's about to be destroyed
                            // it shouldn't be able to go back to
                            return !!(previousItem && !previousItem.shouldDestroy);
                        }
                        return false;
                    }
                }, {
                    key: 'setInstance',
                    value: function setInstance(instance) {
                        this.instance = instance;
                        this.instance._viewItem = this;
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        for (var i = 0; i < this.disposals.length; i++) {
                            this.disposals[i]();
                        }
                        this.didUnload();
                        // just to help prevent any possible memory leaks
                        for (var _name in this) {
                            if (this.hasOwnProperty(_name)) {
                                this[_name] = null;
                            }
                        }
                    }
                }, {
                    key: 'viewElementRef',
                    value: function viewElementRef(val) {
                        if (arguments.length) {
                            this._vwEle = val;
                        }
                        return this._vwEle;
                    }
                }, {
                    key: 'navbarView',
                    value: function navbarView() {
                        if (arguments.length) {
                            this._nbView = arguments[0];
                        }
                        return this._nbView;
                    }
                }, {
                    key: 'navbarElement',
                    value: function navbarElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.getElementRef();
                        }
                    }
                }, {
                    key: 'titleElement',
                    value: function titleElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.titleElement();
                        }
                    }
                }, {
                    key: 'backButtonElement',
                    value: function backButtonElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonElement();
                        }
                    }
                }, {
                    key: 'backButtonTextElement',
                    value: function backButtonTextElement() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.backButtonTextElement();
                        }
                    }
                }, {
                    key: 'navbarItemElements',
                    value: function navbarItemElements() {
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            return navbarView.itemElements();
                        }
                    }
                }, {
                    key: 'postRender',
                    value: function postRender() {
                        // the elements are in the DOM and the browser
                        // has rendered them in their correct locations
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.alignTitle();
                        }
                    }
                }, {
                    key: 'loaded',

                    /*
                      The view has loaded. This event only happens once per view being
                      created. If a view leaves but is cached, then this will not
                      fire again on a subsequent viewing. This method is a good place
                      to put your setup code for the view; however, it is not the
                      recommended method to use when a view becomes active.
                    */
                    value: function loaded() {
                        this.instance && this.instance.viewLoaded && this.instance.viewLoaded();
                    }
                }, {
                    key: 'willEnter',

                    /*
                      The view is about to enter and become the active view.
                    */
                    value: function willEnter() {
                        this.instance && this.instance.viewWillEnter && this.instance.viewWillEnter();
                    }
                }, {
                    key: 'didEnter',

                    /*
                      The view has fully entered and is now the active view. This
                      will fire, whether it was the first load or loaded from the cache.
                    */
                    value: function didEnter() {
                        if (this.pane) {
                            this.pane.showPane = true;
                        }
                        var navbarView = this.navbarView();
                        if (navbarView) {
                            navbarView.didEnter();
                        }
                        this.instance && this.instance.viewDidEnter && this.instance.viewDidEnter();
                    }
                }, {
                    key: 'willLeave',

                    /*
                      The view has is about to leave and no longer be the active view.
                    */
                    value: function willLeave() {
                        this.instance && this.instance.viewWillLeave && this.instance.viewWillLeave();
                    }
                }, {
                    key: 'didLeave',

                    /*
                      The view has finished leaving and is no longer the active view. This
                      will fire, whether it is cached or unloaded.
                    */
                    value: function didLeave() {
                        this.instance && this.instance.viewDidLeave && this.instance.viewDidLeave();
                    }
                }, {
                    key: 'willUnload',

                    /*
                      The view is about to be destroyed and have its elements removed.
                    */
                    value: function willUnload() {
                        this.instance && this.instance.viewWillUnload && this.instance.viewWillUnload();
                    }
                }, {
                    key: 'didUnload',

                    /*
                      The view has been destroyed and its elements have been removed.
                    */
                    value: function didUnload() {
                        this.instance && this.instance.viewDidUnload && this.instance.viewDidUnload();
                    }
                }, {
                    key: 'index',
                    get: function get() {
                        return this.viewCtrl ? this.viewCtrl.indexOf(this) : -1;
                    }
                }]);

                return ViewItem;
            })();

            _export('ViewItem', ViewItem);
        }
    };
});
System.register('ionic/components/aside/extensions/gestures', ['ionic/gestures/slide-edge-gesture'], function (_export) {
    'use strict';

    var SlideEdgeGesture, AsideTargetGesture, AsideGesture, LeftAsideGesture, RightAsideGesture, TopAsideGesture, BottomAsideGesture;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    return {
        setters: [function (_ionicGesturesSlideEdgeGesture) {
            SlideEdgeGesture = _ionicGesturesSlideEdgeGesture.SlideEdgeGesture;
        }],
        execute: function () {
            AsideTargetGesture = (function (_SlideEdgeGesture) {
                function AsideTargetGesture(aside) {
                    _classCallCheck(this, AsideTargetGesture);

                    var asideElement = aside.getNativeElement();
                    _get(Object.getPrototypeOf(AsideTargetGesture.prototype), 'constructor', this).call(this, asideElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 0
                    });
                    this.aside = aside;
                }

                _inherits(AsideTargetGesture, _SlideEdgeGesture);

                _createClass(AsideTargetGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        return this.aside.isOpen;
                    }
                }, {
                    key: 'onSlideBeforeStart',

                    // Set CSS, then wait one frame for it to apply before sliding starts
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform('translate3d(' + slide.distance + 'px,0,0)');
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setTransform('');
                        this.aside.setSliding(false);
                        if (Math.abs(ev.gesture.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideTargetGesture;
            })(SlideEdgeGesture);

            AsideGesture = (function (_SlideEdgeGesture2) {
                function AsideGesture(aside) {
                    _classCallCheck(this, AsideGesture);

                    // TODO figure out the sliding element, dont just use the parent
                    var contentElement = aside.getContentElement();
                    _get(Object.getPrototypeOf(AsideGesture.prototype), 'constructor', this).call(this, contentElement, {
                        direction: aside.side === 'left' || aside.side === 'right' ? 'x' : 'y',
                        edge: aside.side,
                        threshold: 75
                    });
                    this.aside = aside;
                    this.slideElement = contentElement;
                    this.listen();
                    var contentGesture = new AsideTargetGesture(aside);
                    contentGesture.listen();
                }

                _inherits(AsideGesture, _SlideEdgeGesture2);

                _createClass(AsideGesture, [{
                    key: 'canStart',
                    value: function canStart(ev) {
                        // Only restrict edges if the aside is closed
                        return this.aside.isOpen ? true : _get(Object.getPrototypeOf(AsideGesture.prototype), 'canStart', this).call(this, ev);
                    }
                }, {
                    key: 'onSlideBeforeStart',

                    // Set CSS, then wait one frame for it to apply before sliding starts
                    value: function onSlideBeforeStart(slide, ev) {
                        this.aside.setSliding(true);
                        this.aside.setChanging(true);
                        return new Promise(function (resolve) {
                            requestAnimationFrame(resolve);
                        });
                    }
                }, {
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setOpenAmt(slide.distance / slide.max);
                        this.aside.setTransform('translate3d(' + slide.distance + 'px,0,0)');
                    }
                }, {
                    key: 'onSlideEnd',
                    value: function onSlideEnd(slide, ev) {
                        this.aside.setTransform('');
                        this.aside.setSliding(false);
                        if (Math.abs(ev.gesture.velocityX) > 0.2 || Math.abs(slide.delta) > Math.abs(slide.max) * 0.5) {
                            this.aside.setOpen(!this.aside.isOpen);
                        }
                    }
                }, {
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.max : slide.min;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.width()
                        };
                    }
                }]);

                return AsideGesture;
            })(SlideEdgeGesture);

            LeftAsideGesture = (function (_AsideGesture) {
                function LeftAsideGesture() {
                    _classCallCheck(this, LeftAsideGesture);

                    _get(Object.getPrototypeOf(LeftAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(LeftAsideGesture, _AsideGesture);

                return LeftAsideGesture;
            })(AsideGesture);

            _export('LeftAsideGesture', LeftAsideGesture);

            RightAsideGesture = (function (_LeftAsideGesture) {
                function RightAsideGesture() {
                    _classCallCheck(this, RightAsideGesture);

                    _get(Object.getPrototypeOf(RightAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(RightAsideGesture, _LeftAsideGesture);

                _createClass(RightAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.width(),
                            max: 0
                        };
                    }
                }]);

                return RightAsideGesture;
            })(LeftAsideGesture);

            _export('RightAsideGesture', RightAsideGesture);

            TopAsideGesture = (function (_AsideGesture2) {
                function TopAsideGesture() {
                    _classCallCheck(this, TopAsideGesture);

                    _get(Object.getPrototypeOf(TopAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(TopAsideGesture, _AsideGesture2);

                _createClass(TopAsideGesture, [{
                    key: 'onSlide',
                    value: function onSlide(slide, ev) {
                        this.aside.setTransform('translate3d(0,' + slide.distance + 'px,0)');
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: 0,
                            max: this.aside.height()
                        };
                    }
                }]);

                return TopAsideGesture;
            })(AsideGesture);

            _export('TopAsideGesture', TopAsideGesture);

            BottomAsideGesture = (function (_TopAsideGesture) {
                function BottomAsideGesture() {
                    _classCallCheck(this, BottomAsideGesture);

                    _get(Object.getPrototypeOf(BottomAsideGesture.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(BottomAsideGesture, _TopAsideGesture);

                _createClass(BottomAsideGesture, [{
                    key: 'getElementStartPos',
                    value: function getElementStartPos(slide, ev) {
                        return this.aside.isOpen ? slide.min : slide.max;
                    }
                }, {
                    key: 'getSlideBoundaries',
                    value: function getSlideBoundaries() {
                        return {
                            min: -this.aside.height(),
                            max: 0
                        };
                    }
                }]);

                return BottomAsideGesture;
            })(TopAsideGesture);

            _export('BottomAsideGesture', BottomAsideGesture);
        }
    };
});
System.register('ionic/components/aside/extensions/types', ['ionic/util/dom'], function (_export) {
    'use strict';

    var CSS, asideManipulator, contentManipulator, AsideType, AsideTypeOverlay, AsideTypePush, AsideTypeReveal;

    var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

    var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

    function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

    return {
        setters: [function (_ionicUtilDom) {
            CSS = _ionicUtilDom.CSS;
        }],
        execute: function () {
            // TODO use setters instead of direct dom manipulation
            asideManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.getNativeElement().classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.getNativeElement().classList[open ? 'add' : 'remove']('open');
                },
                setTransform: function setTransform(t) {
                    this.aside.getNativeElement().style[CSS.transform] = t;
                }
            };
            contentManipulator = {
                setSliding: function setSliding(sliding) {
                    this.aside.contentElement.classList[sliding ? 'add' : 'remove']('no-transition');
                },
                setOpen: function setOpen(open) {
                    this.aside.contentElement.classList[open ? 'add' : 'remove']('aside-open-' + this.aside.side);
                },
                setTransform: function setTransform(t) {
                    this.aside.contentElement.style[CSS.transform] = t;
                }
            };

            AsideType = function AsideType(aside) {
                _classCallCheck(this, AsideType);

                this.aside = aside;
                //FIXME(ajoslin): have to wait for for bindings to apply in a component
                setTimeout(function () {
                    aside.contentElement.classList.add('aside-content');
                });
            };

            _export('AsideType', AsideType);

            AsideTypeOverlay = (function (_AsideType) {
                function AsideTypeOverlay() {
                    _classCallCheck(this, AsideTypeOverlay);

                    _get(Object.getPrototypeOf(AsideTypeOverlay.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypeOverlay, _AsideType);

                _createClass(AsideTypeOverlay, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypeOverlay;
            })(AsideType);

            _export('AsideTypeOverlay', AsideTypeOverlay);

            AsideTypePush = (function (_AsideType2) {
                function AsideTypePush() {
                    _classCallCheck(this, AsideTypePush);

                    _get(Object.getPrototypeOf(AsideTypePush.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypePush, _AsideType2);

                _createClass(AsideTypePush, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        asideManipulator.setSliding.call(this, sliding);
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(open) {
                        asideManipulator.setOpen.call(this, open);
                        contentManipulator.setOpen.call(this, open);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        asideManipulator.setTransform.call(this, t);
                        contentManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypePush;
            })(AsideType);

            _export('AsideTypePush', AsideTypePush);

            AsideTypeReveal = (function (_AsideType3) {
                function AsideTypeReveal() {
                    _classCallCheck(this, AsideTypeReveal);

                    _get(Object.getPrototypeOf(AsideTypeReveal.prototype), 'constructor', this).apply(this, arguments);
                }

                _inherits(AsideTypeReveal, _AsideType3);

                _createClass(AsideTypeReveal, [{
                    key: 'setSliding',
                    value: function setSliding(sliding) {
                        contentManipulator.setSliding.call(this, sliding);
                    }
                }, {
                    key: 'setOpen',
                    value: function setOpen(sliding) {
                        contentManipulator.setOpen.call(this, sliding);
                    }
                }, {
                    key: 'setTransform',
                    value: function setTransform(t) {
                        contentManipulator.setTransform.call(this, t);
                    }
                }]);

                return AsideTypeReveal;
            })(AsideType);

            _export('AsideTypeReveal', AsideTypeReveal);
        }
    };
});

/**
 * Hairline Shim
 * Add the "hairline" CSS class name to the body tag
 * if the browser supports subpixels.
 */

(function(document){

  if (window.devicePixelRatio >= 2) {
    var hairlineEle = document.createElement('div');
    hairlineEle.style.border = '.5px solid transparent';
    document.body.appendChild(hairlineEle);

    if (hairlineEle.offsetHeight === 1) {
      document.body.classList.add('hairlines');
    }
    document.body.removeChild(hairlineEle);
  }

})(document);


(function(document){

  var ionicImport = System.import('ionic/components/app/app');

  function importApp(module) {
    if (module) {
      System.import(module);
    }
  }

  var ele = document.querySelectorAll('[module]');
  for (var i = 0; i < ele.length; i++) {
    importApp(ele[i].getAttribute('module'));
  }

})(document);
System.config({ "paths":{ "ionic/*": "ionic/*" }});

// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){b["true"]=a,function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}var c={},d={},e={},f=null;!function(a,b){function c(b,c){var d={delay:0,endDelay:0,fill:c?"both":"none",iterationStart:0,iterations:1,duration:c?"auto":0,playbackRate:1,direction:"normal",easing:"linear"};return"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof d[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==q.indexOf(b[c]))return;if("direction"==c&&-1==r.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;d[c]=b[c]}}):d.duration=b,d}function d(a,b){var d=c(a,b);return d.easing=g(d.easing),d}function e(a,b,c,d){return 0>a||a>1||0>c||c>1?z:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}for(var g=0,h=1;;){var i=(g+h)/2,j=f(a,c,i);if(Math.abs(e-j)<.001)return f(b,d,i);e>j?g=i:h=i}}}function f(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function g(a){var b=x.exec(a);if(b)return e.apply(this,b.slice(1).map(Number));var c=y.exec(a);if(c)return f(Number(c[1]),{start:s,middle:t,end:u}[c[2]]);var d=v[a];return d?d:z}function h(a){return Math.abs(i(a)/a.playbackRate)}function i(a){return a.duration*a.iterations}function j(a,b,c){return null==b?A:b<c.delay?B:b>=c.delay+a?C:D}function k(a,b,c,d,e){switch(d){case B:return"backwards"==b||"both"==b?0:null;case D:return c-e;case C:return"forwards"==b||"both"==b?a:null;case A:return null}}function l(a,b,c,d){return(d.playbackRate<0?b-a:b)*d.playbackRate+c}function m(a,b,c,d,e){return c===1/0||c===-(1/0)||c-d==b&&e.iterations&&(e.iterations+e.iterationStart)%1==0?a:c%a}function n(a,b,c,d){return 0===c?0:b==a?d.iterationStart+d.iterations-1:Math.floor(c/a)}function o(a,b,c,d){var e=a%2>=1,f="normal"==d.direction||d.direction==(e?"alternate-reverse":"alternate"),g=f?c:b-c,h=g/b;return b*d.easing(h)}function p(a,b,c){var d=j(a,b,c),e=k(a,c.fill,b,d,c.delay);if(null===e)return null;if(0===a)return d===B?0:1;var f=c.iterationStart*c.duration,g=l(a,e,f,c),h=m(c.duration,i(c),g,f,c),p=n(c.duration,h,g,c);return o(p,c.duration,h,c)/c.duration}var q="backwards|forwards|both|none".split("|"),r="reverse|alternate|alternate-reverse".split("|"),s=1,t=.5,u=0,v={ease:e(.25,.1,.25,1),"ease-in":e(.42,0,1,1),"ease-out":e(0,0,.58,1),"ease-in-out":e(.42,0,.58,1),"step-start":f(1,s),"step-middle":f(1,t),"step-end":f(1,u)},w="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",x=new RegExp("cubic-bezier\\("+w+","+w+","+w+","+w+"\\)"),y=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,z=function(a){return a},A=0,B=1,C=2,D=3;a.makeTiming=c,a.normalizeTimingInput=d,a.calculateActiveDuration=h,a.calculateTimeFraction=p,a.calculatePhase=j,a.toTimingFunction=g}(c,f),function(a,b){function c(a,b){return a in i?i[a][b]||b:b}function d(a,b,d){var e=f[a];if(e){g.style[a]=b;for(var h in e){var i=e[h],j=g.style[i];d[i]=c(i,j)}}else d[a]=c(a,b)}function e(b){function c(){var a=e.length;null==e[a-1].offset&&(e[a-1].offset=1),a>1&&null==e[0].offset&&(e[0].offset=0);for(var b=0,c=e[0].offset,d=1;a>d;d++){var f=e[d].offset;if(null!=f){for(var g=1;d-b>g;g++)e[b+g].offset=c+(f-c)*g/(d-b);b=d,c=f}}}if(!Array.isArray(b)&&null!==b)throw new TypeError("Keyframes must be null or an array of keyframes");if(null==b)return[];for(var e=b.map(function(b){var c={};for(var e in b){var f=b[e];if("offset"==e){if(null!=f&&(f=Number(f),!isFinite(f)))throw new TypeError("keyframe offsets must be numbers.")}else{if("composite"==e)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};f="easing"==e?a.toTimingFunction(f):""+f}d(e,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing=a.toTimingFunction("linear")),c}),f=!0,g=-(1/0),h=0;h<e.length;h++){var i=e[h].offset;if(null!=i){if(g>i)throw{code:DOMException.INVALID_MODIFICATION_ERR,name:"InvalidModificationError",message:"Keyframes are not loosely sorted by offset. Sort or specify offsets."};g=i}else f=!1}return e=e.filter(function(a){return a.offset>=0&&a.offset<=1}),f||c(),e}var f={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},g=document.createElementNS("http://www.w3.org/1999/xhtml","div"),h={thin:"1px",medium:"3px",thick:"5px"},i={borderBottomWidth:h,borderLeftWidth:h,borderRightWidth:h,borderTopWidth:h,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:h,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.normalizeKeyframes=e}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),h>g?(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,!1):!0},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(a){var c=[];for(var d in a)for(var e=a[d],f=0;f<e.length-1;f++){var g=e[f].offset,h=e[f+1].offset,i=e[f].value,j=e[f+1].value;g==h&&(1==h?i=j:j=i),c.push({startTime:g,endTime:h,easing:e[f].easing,property:d,interpolation:b.propertyInterpolation(d,i,j)})}return c.sort(function(a,b){return a.startTime-b.startTime}),c}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return 0>=c&&0==a.startTime||c>=1&&1==a.endTime||c>=a.startTime&&c<=a.endTime}).forEach(function(d){var e=c-d.startTime,f=d.endTime-d.startTime,g=0==f?0:d.easing(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a,b){function c(a,b,c){f[c]=f[c]||[],f[c].push([a,b])}function d(a,b,d){for(var e=0;e<d.length;e++){var f=d[e];c(a,b,f),/-/.test(f)&&c(a,b,f.replace(/-(.)/g,function(a,b){return b.toUpperCase()}))}}function e(b,c,d){for(var e=c==d?[]:f[b],g=0;e&&g<e.length;g++){var h=e[g][0](c),i=e[g][0](d);if(void 0!==h&&void 0!==i){var j=e[g][1](h,i);if(j){var k=a.Interpolation.apply(null,j);return function(a){return 0==a?c:1==a?d:k(a)}}}}return a.Interpolation(!1,!0,function(a){return a?d:c})}var f={};a.addPropertiesHandler=d,a.propertyInterpolation=e}(d,f),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateTimeFraction(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d._isCurrent=function(d){var e=a.calculatePhase(c,d,b);return e===PhaseActive||e===PhaseBefore},d}b.KeyframeEffect=function(c,e,f){var g,h=d(a.normalizeTimingInput(f)),i=b.convertEffectInput(e),j=function(){i(c,g)};return j._update=function(a){return g=h(a),null!==g},j._clear=function(){i(c,null)},j._hasSameTarget=function(a){return c===a},j._isCurrent=h._isCurrent,j._totalDuration=h._totalDuration,j},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._isCurrent=function(){return!1},b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a,b){function c(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function d(a){this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={};for(var b=0;b<this._style.length;b++){var c=this._style[b];this._surrogateStyle[c]=this._style[c]}this._updateIndices()}function e(a){if(!a._webAnimationsPatchedStyle){var b=new d(a);try{c(a,"style",{get:function(){return b}})}catch(e){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var f={cssText:1,length:1,parentRule:1},g={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},h={removeProperty:1,setProperty:1};d.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(a,b){this._style[a]=b,this._isAnimatedProperty[a]=!0},_clear:function(a){this._style[a]=this._surrogateStyle[a],delete this._isAnimatedProperty[a]}};for(var i in g)d.prototype[i]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(i,i in h);for(var j in document.documentElement.style)j in f||j in g||!function(a){c(d.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(j);a.apply=function(b,c,d){e(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(d,f),function(a){window.Element.prototype.animate=function(b,c){return a.timeline._play(a.KeyframeEffect(this,b,c))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return.5>d?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d,f),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;4>j;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;4>d;d++)for(var e=0;4>e;e++)for(var f=0;4>f;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;4>i;i++)h[i][3]=g[i];for(var i=0;3>i;i++)for(var j=0;3>j;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;3>i;i++)for(var j=0;3>j;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(d,f),function(a,b){var c=0,d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};a.Animation=function(a){this._sequenceNumber=c++,this._currentTime=0,this._startTime=null,this.paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!1,this.onfinish=null,this._finishHandlers=[],this._effect=a,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},a.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,a.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this.finished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(b){b=+b,isNaN(b)||(a.restart(),this.paused||null==this._startTime||(this._startTime=this._timeline.currentTime-b/this._playbackRate),this._currentTimePending=!1,this._currentTime!=b&&(this._tickCurrentTime(b,!0),a.invalidateEffects()))},get startTime(){return this._startTime},set startTime(b){b=+b,isNaN(b)||this.paused||this._idle||(this._startTime=b,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),a.invalidateEffects())},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var b=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&this.play(),null!=b&&(this.currentTime=b)}},get finished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this.paused&&0!=this.playbackRate||this._currentTimePending?"pending":this.paused?"paused":this.finished?"finished":"running"},play:function(){this.paused=!1,(this.finished||this._idle)&&(this._currentTime=this._playbackRate>0?0:this._totalDuration,this._startTime=null,a.invalidateEffects()),this._finishedFlag=!1,a.restart(),this._idle=!1,this._ensureAlive()},pause:function(){this.finished||this.paused||this._idle||(this._currentTimePending=!0),this._startTime=null,this.paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1)},cancel:function(){this._inEffect=!1,this._idle=!0,this.currentTime=0,this._startTime=null},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){var b=this.finished;if((b||this._idle)&&!this._finishedFlag){var c=new d(this,this._currentTime,a),e=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);e.forEach(function(a){a.call(c.target,c)})}this._finishedFlag=b},_tick:function(a){return this._idle||this.paused||(null==this._startTime?this.startTime=a-this._currentTime/this.playbackRate:this.finished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),this._currentTimePending=!1,this._fireEvents(a),!this._idle&&(this._inEffect||!this._finishedFlag)}}}(d,f),function(a,b,c){function d(a){var b=j;j=[],h(a),b.forEach(function(b){b[1](a)}),n&&h(a),g()}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a){m=!1;var c=b.timeline;c.currentTime=a,c._animations.sort(e),l=!1;var d=c._animations;c._animations=[];var f=[],g=[];d=d.filter(function(b){return b._inTimeline=b._tick(a),b._inEffect?g.push(b._effect):f.push(b._effect),b.finished||b.paused||b._idle||(l=!0),b._inTimeline}),o.push.apply(o,f),o.push.apply(o,g),c._animations.push.apply(c._animations,d),n=!1,l&&requestAnimationFrame(function(){})}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.invalidateEffects(),d}};var l=!1,m=!1;b.restart=function(){return l||(l=!0,requestAnimationFrame(function(){}),m=!0),m};var n=!1;b.invalidateEffects=function(){n=!0};var o=[],p=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){return n&&h(q.currentTime),g(),p.apply(this,arguments)}});var q=new f;b.timeline=q}(c,d,f),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){switch(a.t){case"rotatex":var b=a.d[0].rad||0,c=a.d[0].deg||0,d=c*Math.PI/180+b;return[1,0,0,0,0,Math.cos(d),Math.sin(d),0,0,-Math.sin(d),Math.cos(d),0,0,0,0,1];case"rotatey":var b=a.d[0].rad||0,c=a.d[0].deg||0,d=c*Math.PI/180+b;return[Math.cos(d),0,-Math.sin(d),0,0,1,0,0,Math.sin(d),0,Math.cos(d),0,0,0,0,1];case"rotate":case"rotatez":var b=a.d[0].rad||0,c=a.d[0].deg||0,d=c*Math.PI/180+b;return[Math.cos(d),Math.sin(d),0,0,-Math.sin(d),Math.cos(d),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var e=a.d[0],f=a.d[1],g=a.d[2],b=a.d[3].rad||0,c=a.d[3].deg||0,d=c*Math.PI/180+b,h=e*e+f*f+g*g;if(0===h)e=1,f=0,g=0;else if(1!==h){var i=Math.sqrt(h);e/=i,f/=i,g/=i}var j=Math.sin(d/2),k=j*Math.cos(d/2),l=j*j;return[1-2*(f*f+g*g)*l,2*(e*f*l+g*k),2*(e*g*l-f*k),0,2*(e*f*l-g*k),1-2*(e*e+g*g)*l,2*(f*g*l+e*k),0,2*(e*g*l+f*k),2*(f*g*l-e*k),1-2*(e*e+f*f)*l,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var m=a.d[0].deg||0,n=a.d[0].rad||0,o=a.d[1].deg||0,p=a.d[1].rad||0,q=m*Math.PI/180+n,r=o*Math.PI/180+p;return[1,Math.tan(r),0,0,Math.tan(q),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=a.d[0].rad||0,c=a.d[0].deg||0,d=c*Math.PI/180+b;return[1,0,0,0,Math.tan(d),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=a.d[0].rad||0,c=a.d[0].deg||0,d=c*Math.PI/180+b;return[1,Math.tan(d),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var e=a.d[0].px||0,f=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,e,f,0,1];case"translatex":var e=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,e,0,0,1];case"translatey":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,f,0,1];case"translatez":var g=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,g,1];case"translate3d":var e=a.d[0].px||0,f=a.d[1].px||0,g=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,e,f,g,1];case"perspective":var s=a.d[0].px?-1/a.d[0].px:0;return[1,0,0,0,0,1,0,0,0,0,1,s,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function f(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(e).reduce(d)}function g(a){return[h(f(a))]}var h=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;3>o;o++){for(var p=0,q=0;3>q;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;4>d;d++){for(var e=0,f=0;4>f;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;4>m;m++)l.push(k[m].slice());for(var m=0;3>m;m++)l[m][3]=0;if(0===a(l))return!1;var n,o=[];if(k[0][3]||k[1][3]||k[2][3]){o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]);var p=b(l),q=d(p);n=e(o,q)}else n=[0,0,0,1];var r=k[3].slice(0,3),s=[];s.push(k[0].slice(0,3));var t=[];t.push(g(s[0])),s[0]=f(s[0]);var u=[];s.push(k[1].slice(0,3)),u.push(c(s[0],s[1])),s[1]=h(s[1],s[0],1,-u[0]),t.push(g(s[1])),s[1]=f(s[1]),u[0]/=t[1],s.push(k[2].slice(0,3)),u.push(c(s[0],s[2])),s[2]=h(s[2],s[0],1,-u[1]),u.push(c(s[1],s[2])),s[2]=h(s[2],s[1],1,-u[2]),t.push(g(s[2])),s[2]=f(s[2]),u[1]/=t[2],u[2]/=t[2];var v=i(s[1],s[2]);if(c(s[0],v)<0)for(var m=0;3>m;m++)t[m]*=-1,s[m][0]*=-1,s[m][1]*=-1,s[m][2]*=-1;var w,x,y=s[0][0]+s[1][1]+s[2][2]+1;return y>1e-4?(w=.5/Math.sqrt(y),x=[(s[2][1]-s[1][2])*w,(s[0][2]-s[2][0])*w,(s[1][0]-s[0][1])*w,.25/w]):s[0][0]>s[1][1]&&s[0][0]>s[2][2]?(w=2*Math.sqrt(1+s[0][0]-s[1][1]-s[2][2]),x=[.25*w,(s[0][1]+s[1][0])/w,(s[0][2]+s[2][0])/w,(s[2][1]-s[1][2])/w]):s[1][1]>s[2][2]?(w=2*Math.sqrt(1+s[1][1]-s[0][0]-s[2][2]),x=[(s[0][1]+s[1][0])/w,.25*w,(s[1][2]+s[2][1])/w,(s[0][2]-s[2][0])/w]):(w=2*Math.sqrt(1+s[2][2]-s[0][0]-s[1][1]),x=[(s[0][2]+s[2][0])/w,(s[1][2]+s[2][1])/w,.25*w,(s[1][0]-s[0][1])/w]),[r,t,u,x,n]}return j}();a.dot=c,a.makeMatrixDecomposition=g}(d,f),function(a){function b(a,b){var c=a.exec(b);return c?(c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]):void 0}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);return c?[c[0],c[1].replace(/^\s*/,"")]:void 0}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,0>=c))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}return""==c?d:void 0}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;j>k;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);return e&&e[0].length?[d,e[1]]:void 0}function c(c){var d=a.consumeRepeated(b,/^,/,c);return d&&""==d[1]?d[0]:void 0}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(".000","")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){return/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a)?Number(a):void 0}function f(a,b){return[a,b,c]}function g(a,b){return 0!=a?i(0,1/0)(a,b):void 0}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,j,["z-index"]),a.parseNumber=e,a.mergeNumbers=f,a.numberToString=c}(d,f),function(a,b){function c(a,b){return"visible"==a||"visible"==b?[0,1,function(c){return 0>=c?a:c>=1?b:"visible"}]:void 0}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;3>d;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);return b&&""==b[1]?b[0]:void 0},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);return d&&4==d[0].length?d[0]:void 0}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");
a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d,f),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r],void 0===p)return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(f).join(",");return h}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d,f),function(a){function b(a){var b=Number(a);return isNaN(b)||100>b||b>900||b%100!==0?void 0:b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(d),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);return c&&""==c[1]?c[0]:void 0}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(d),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){return b[0]===c[0]?"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0:void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d,f)}()}({},function(){return this}());
//# sourceMappingURL=web-animations.min.js.map